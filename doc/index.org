#+BIBLIOGRAPHY: bibliography ieee

#+LATEX_CLASS: scrreprt
#+LATEX_CLASS_OPTIONS: [10pt, openright, notitlepage]
#+LATEX_HEADER: \usepackage[a4paper, left=25mm, right=25mm, top=27mm, headheight=20mm, headsep=10mm, textheight=242mm, footskip=15mm]{geometry}
#+LATEX_HEADER: \usepackage[backend=biber, style=ieee]{biblatex}
#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor}
#+LATEX_HEADER: % Definition of colors
#+LATEX_HEADER: %---------------------------------------------------------------------------
#+LATEX_HEADER: \RequirePackage{color}
#+LATEX_HEADER: \definecolor{linkblue}{rgb}{0,0,0.8}       % Standard
#+LATEX_HEADER: \definecolor{darkblue}{rgb}{0,0.08,0.45}   % Dark blue
#+LATEX_HEADER: \definecolor{bfhgrey}{rgb}{0.41,0.49,0.57} % BFH grey
#+LATEX_HEADER: \definecolor{linkcolor}{rgb}{0,0,0}
#+LATEX_HEADER: \colorlet{Black}{black}
#+LATEX_HEADER: \definecolor{keywords}{rgb}{255,0,0}
#+LATEX_HEADER: \definecolor{red}{rgb}{0.6,0,0}
#+LATEX_HEADER: \definecolor{green}{rgb}{0,0.5,0}
#+LATEX_HEADER: \definecolor{blue}{rgb}{0,0,0.5}
#+LATEX_HEADER: % Syntax colors
#+LATEX_HEADER: \definecolor{syntaxRed}{rgb}{0.6,0,0}
#+LATEX_HEADER: \definecolor{syntaxBlue}{rgb}{0,0,0.5}
#+LATEX_HEADER: \definecolor{syntaxComment}{rgb}{0,0.5,0}
#+LATEX_HEADER: % Background colors
#+LATEX_HEADER: \definecolor{syntaxBackground}{rgb}{0.95, 0.95, 0.95}
#+LATEX_HEADER: %---------------------------------------------------------------------------
#+LATEX_HEADER: \usepackage{tcolorbox}
#+LATEX_HEADER: \usepackage{pgfgantt}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \restylefloat{listing}
#+LATEX_HEADER: \tcbuselibrary{minted,skins}
#+LATEX_HEADER: \definecolor{bashcodebg}{rgb}{0.85,0.85,0.85}
#+LATEX_HEADER: \addbibresource{bibliography.bib}
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_HEADER_EXTRA:
#+LATEX_COMPILER: pdflatex

#+TITLE: QDE --- A visual animation system.
#+SUBTITLE: MTE-7103: Master-Thesis
#+AUTHOR: Sven Osterwalder
#+EMAIL: sven.osterwalder@students.bfh.ch
#+DATE: February 20, 2017
#+OPTIONS: author:t date:t email:t ^:nil

* TODO Introduction

[Introduction here].

* TODO Administrative aspects

Some administrative aspects of this thesis are covered, while they are not
required for the understanding of the result.

The whole documentation uses the male form, whereby both genera are equally
meant.

** Involved persons

| Author     | Sven Osterwalder[fn:1:sven.osterwalder@students.bfh.ch] |                                           |
| Supervisor | Prof. Claude Fuhrer[fn:2:claude.fuhrer@bfh.ch]          | /Supervises the student doing the thesis/ |

** Structure of the documentation

This thesis is structured as follows:

- Introduction
- Objectives and limitations
- Procedure
- Implementation
- Conclusion

** Deliverable results

- Report
- Implementation

* TODO Scope

** Motivation

[Motivation.]

** Objectives and limitations

[Objectives and limitations.]

** Preliminary activities

[Preliminary activities.]

** New learning contents

[New learning contents.]

* TODO Procedure
** Organization of work
*** Meetings

Various meetings with the supervising professor, Mr. Claude Fuhrer, helped
reaching the defined goals and preventing erroneous directions of the thesis.
The supervisor supported the author of this thesis by providing suggestions
throughout the held meetings. The minutes of the meetings may be found under
<<Meeting minutes>>.

*** Phases of the project and milestones


| Phase                                    | Description | Week / 2017 |
|------------------------------------------+-------------+-------------|
| Start of the project                     |             |           8 |
| Definition of objectives and limitations |             |         8-9 |
| Documentation and development            |             |        8-30 |
| Corrections                              |             |       30-31 |
| Preparation of the thesis' defense       |             |       31-32 |

| Milestone                           | Description | End of week / 2017 |
|-------------------------------------+-------------+--------------------|
| Project structure is set up         |             |                  8 |
| Mandatory project goals are reached |             |                 30 |
| Hand-in of the thesis               |             |                 31 |
| Defense of the thesis               |             |                 32 |

*** Literate programming

This thesis' implementation is done by a procedure named ``literate
programming'', invented by Donald Knuth. What this means, is that the
documentation as well as the code for the resulting program reside in the same
file. The documentation is then /weaved/ into a separate document, which may be
any by the editor support format. The code of the program is /tangled/ into a
run-able computer program.

*************** TODO Provide more information about literate programming.
                    Citations, explain fragments, explain referencing
                    fragments, code structure does not have to be ``normal''
*************** END

  Originally it was planned to develop this thesis' application test driven,
  providing (unit-) test-cases first and implementing the functionality
  afterwards. Initial trails showed quickly that this method, in company with
  literate programming, would exaggerate the effort needed. Therefore conventional
  testing is used. Test are developed after implementing functionality and run
  separately. A coverage as high as possible is intended. Test cases are /tangled/
  too, and may be found in the appendix.
*************** TODO Insert reference/link to test cases here.
*************** END

** Standards and principles
*** Code

 [Code.]

*** Diagrams

 [Diagrams.]

*** Project structure

 [Project structure.]

* TODO Implementation

** Requirements

This chapter describes the requirements to extract the source code out of this
documentation using /tangling/.

At the current point of time, the requirements are the following:

- A Unix derivative as operating system (Linux, macOS).
- Python version 3.5.x or up[fn:3:https://www.python.org].
- Pyenv[fn:4:https://github.com/yyuu/pyenv].
- Pyenv-virtualenv[fn:5:https://github.com/yyuu/pyenv-virtualenv].

The first step is to install a matching version of python for the usage within
the virtual environment. The available Python versions may be listed as follows.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Listing all available versions of Python for use in Pyenv.
#+NAME:       fig:impl-pyenv-list
#+BEGIN_SRC bash :results output silent
pyenv install --list
#+END_SRC

The desired version may be installed as follows. This example shows the
installation of version 3.6.0.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Installation of Python version 3.6.0 for the usage with Pyenv.
#+NAME:       fig:impl-pyenv-install
#+BEGIN_SRC bash :dir ../.
install 3.6.0
#+END_SRC

It is highly recommended to create and use a project-specific virtual Python
environment. All packages, that are required for this project are installed
within this virtual environment protecting the operating systems' Python
packages.
First the desired version of Python has to be specified, then the desired name
of the virtual environment.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Creation of the virtual environment =qde= for Python using version 3.6.0 of Python.
#+NAME:       fig:impl-pyenv-venv
#+BEGIN_SRC bash :dir ../.
pyenv virtualenv 3.6.0 qde
#+END_SRC

All required dependencies for the project may now safely be installed. Those are
listed in the file =python_requirements.txt= and are installed using =pip=.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Installation of the projects' required dependencies.
#+NAME:       fig:impl-pip-install
#+BEGIN_SRC bash :dir ../.
pip install -r python_requirements.txt
#+END_SRC

All requirements and dependencies are now met and the actual implementation of
the project may begin now.

** Project structure

This chapter describes the planned directory structure as well as an instruction
on how to set up that structure.

The whole source code shall be placed in the =src= directory underneath the main
directory.

To prevent multiple modules having the same name, name spaces are
used[fn:6:https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces].
The main name space shall be analogous to the projects' name: =qde=.

In der ersten Phase des Projektes soll der Editor erstellt werden. Dieser dient
der Erstellung und Verwaltung von Echtzeit-Animationen \cite[S. 29]{osterwalder_qde_2016}.

** Editor

Der Editor soll sich im Verzeichnis =editor= unterhalb des =src/qde=-Verzeichnisses
befinden.

Um sicherzustellen, dass Module als solche verwendet werden können, muss pro
Modul und Namespace eine Datei zur Initialisierung vorhanden sein. Es handelt sich
dabei um Dateien namens =__init__.py=, welche im minimalen Fall leer sind. Diese
können aber auch regulären Programmcode, wie zum Beispiel Klassen oder Methoden
enthalten.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Erstellung des =qde=-Namespaces und des =editor=-Namespaces.
#+NAME:       fig:impl-namespaces
#+BEGIN_SRC python :tangle ../src/qde/__init__.py :noweb tangle :comments link :tangle ../src/qde/editor/__init__.py :mkdirp yes
#+END_SRC

Im weiteren Verlauf des Dokumentes wird darauf verzichtet diese Dateien explizit
zu erwähnen, sie werden direkt in den entsprechenden Codeblöcken erstellt und
als gegeben angesehen.

Nun kann mit der eigentlichen Erstellung des Editors begonnen werden.

Der Einstiegspunkt einer Qt-Applikation mit grafischer Oberfläche ist die Klasse
=QtApplication=. Gemäss [fn:7:http://doc.qt.io/Qt-5/qapplication.html] kann die
Klasse direkt instanziert und benutzt werden, es ist unter Umständen jedoch
sinnvoller die Klasse zu kapseln, was schlussendlich eine höhere Flexibilität
bei der Umsetzung bietet. Es soll daher die Klasse =Application= erstellt
werden, welche diese Abstraktion bietet.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Erstellung des =application=-Namespaces.
#+NAME:       fig:impl-application-namespace
#+BEGIN_SRC python :tangle ../src/qde/editor/application/__init__.py :noweb tangle :comments link :mkdirp yes
#+END_SRC

#+RESULTS:

An dieser Stelle macht es Sinn, sich zu überlegen, welche Funktionalität die
Applikation selbst haben soll. Es ist nicht nötig selbst einen Event-Loop zu
implementieren, da ein solcher bereits durch Qt vorhanden
ist[fn:8:http://doc.qt.io/Qt-5/qapplication.html#exec].

Die Applikation hat die Aufgabe die Kernelemente der Applikation zu
initialisieren. So fungiert das Modul als Knotenpunkt zwischen den
verschiedenen Ebenen der Architektur, indem es diese mittels Signalen
verbindet.\cite[S. 37 bis 38]{osterwalder_qde_2016}

Weiter soll es nützliche Schnittstellen, wie zum Beispiel das Protokollieren
von Meldungen, bereitstellen. Und schliesslich soll das Modul eine Möglichkeit
bieten beim Verlassen der Applikation zusätzliche Aufgaben, wie etwa das
Entfernen von temporären Dateien, zu bieten.

Da es sehr nützlich ist, den Zustand einer Applikation jederzeit in Form von
gezielten Ausgaben nachvollziehen zu können, bietet es sich an als ersten
Schritt ein Modul zur Protokollierung zu implementieren.
Protokollierung ist ein sehr zentrales Element, daher wird das Modul im
Namespace =foundation= erstellt.

Die (Datei-) Struktur zur Erstellung und Benennung der Module erfolgt ab diesem
Zeitpunkt nach dem Schichten-Modell gemäss \cite[S. 40]{osterwalder_qde_2016}.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Erstellung und Initialisierung des =foundation=-Namespaces.
#+NAME:       fig:editor-foundation-namespace
#+BEGIN_SRC python :tangle ../src/qde/editor/foundation/__init__.py :noweb tangle :comments link :mkdirp yes
#+END_SRC

Die Protokollierung auf Klassen-Basis stattfinden. Vorerst sollen
Protokollierungen als Stream ausgegeben werden. Pro Klasse muss also eine
=logging=-Instanz instanziert und mit dem entsprechenden Handler ausgestattet
werden. Um den Programmcode nicht unnötig wiederholen zu müssen, bietet sich
hierfür das Decorator-Pattern von Python
an[fn:9:https://www.python.org/dev/peps/pep-0318/].

Die Klasse zur Protokollierung soll also Folgendes tun:

- Einen Logger-Namen auf Basis des aktuellen Moduls und der aktuellen Klasse setzen
  #+NAME: logger-name
  #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
  #+CAPTION:    Setzen des Logger-Names auf Basis des aktuellen Modules und Klasse.
  #+BEGIN_SRC python
  logger_name = "%s.%s" % (cls.__module__, cls.__name__)
  #+END_SRC

  #+RESULTS: logger-name

- Einen Stream-Handler nutzen
  #+NAME: logger-stream-handler
  #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
  #+CAPTION:    Initialisieren eines Stream-Handlers.
  #+BEGIN_SRC python
    stream_handler = logging.StreamHandler()
  #+END_SRC

    #+RESULTS: logger-stream-handler

- Die Stufe der Protokollierung abhängig von der aktuellen Konfiguration setzen
  #+NAME: logger-set-level
  #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
  #+CAPTION:    Setzen des =DEBUG= Log-Levels.
  #+BEGIN_SRC python
    # TODO: Do this according to config.
    stream_handler.setLevel(logging.DEBUG)
  #+END_SRC

    #+RESULTS: logger-set-level

- Protokoll-Einträge ansprechend formatieren
  #+NAME: logger-set-formatter
  #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
  #+CAPTION:    Anpassung der Ausgabe von Protokoll-Meldungen.
  #+BEGIN_SRC python
    # TODO: Set up formatter in debug mode only
    formatter = logging.Formatter("%(asctime)s - %(levelname)-7s - %(name)s.%(funcName)s::%(lineno)s: %(message)s")
    stream_handler.setFormatter(formatter)
  #+END_SRC

    #+RESULTS: logger-set-formatter

- Eine einfache Schnittstelle zur Protokollierung bieten
  #+NAME: logger-return-logger
  #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
  #+CAPTION:    Nutzung des erstellten Stream-Handlers und Rückgabe der Klasse.
  #+BEGIN_SRC python
    cls.logger = logging.getLogger(logger_name)
    cls.logger.propagate = False
    cls.logger.addHandler(stream_handler)

    return cls
  #+END_SRC

    #+RESULTS: logger-return-logger

Nun kann die eigentliche Funktionalität implementiert werden.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Das =common=-Modul und eine Methode zur Protokollierung in Klassen.
#+NAME:       fig:editor-common-logging
#+BEGIN_SRC python :tangle ../src/qde/editor/foundation/common.py :noweb tangle :comments link :mkdirp yes
# -*- coding: utf-8 -*-

"""Module holding common helper methods."""

# System imports
import logging


def with_logger(cls):
    """Add a logger instance (using a steam handler) to the given class
    instance.

    :param cls: the class which the logger shall be added to
    :type  cls: a class of type cls

    :return: the class type with the logger instance added
    :rtype:  a class of type cls
    """

    <<logger-name>>
    <<logger-stream-handler>>
    <<logger-set-level>>
    <<logger-set-formatter>>
    <<logger-return-logger>>
#+END_SRC

#+RESULTS: fig:editor-common-logging

Führt man nun die Testfälle erneut aus, so schlagen diese nicht mehr fehl.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Ausführen der Testfälle für das =common=-Modul.
#+BEGIN_SRC bash :dir ../src
python -m pytest qde/editor/foundation/test_common.py
#+END_SRC

#+RESULTS:

Der Decorator kann nun direkt auf die Klasse der QDE-Applikation angewendet
werden.

#+NAME: app-class-definition
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition der Klasse =Application= mit dem =with_logger=-Dekorator des =common=-Modules.
#+BEGIN_SRC python
@common.with_logger
class QDE(QApplication):
  """Main application for QDE."""

  <<app-class-body>>
#+END_SRC

#+RESULTS: app-class-definition

Damit die Protokollierung jedoch nicht nur via STDOUT in der Konsole statt
findet, muss diese entsprechend konfiguriert werden. Das /logging/-Modul von
Python bietet hierzu vielfältige
Möglichkeiten.[fn:10:https://docs.python.org/3/library/logging.html] So kann die
Protokollierung mittels der ``Configuration API'' konfiguriert werden. Hier
bietet sich die Konfiguration via Dictionary an. Ein Dictionary kann zum
Beispiel sehr einfach aus einer JSON-Datei generiert werden.

Die Haupt-Applikation soll die Protokollierung folgendermassen vornehmen:
- Die Konfiguration erfolgt entweder via externer JSON-Datei oder verwendet die
  Standardkonfiguration, welche von Python mittels =basicConfig= vorgegeben
  wird.
- Als Name für die JSON-Datei wird =logging.json= angenommen.
- Ist in den Umgebungsvariablen des Betriebssystems die Variable /LOG_CFG/
  gesetzt, wird diese als Pfad für die JSON-Datei angenommen. Ansonsten wird
  angenommen, dass sich die Datei =logging.json= im Hauptverzeichnis befindet.
- Existiert die JSON-Konfigurationsdatei nicht, wird auf die
  Standardkonfiguration zurückgegeriffen.
- Die Protokollierung verwendet immer eine Protokollierungsstufe (Log-Level)
  zum Filtern der verschiedenen Protokollnachrichten.

Die Haupt-Applikation nimmt also die Parameter =Pfad=, =Protokollierungsstufe=
sowie =Umgebungsvariable= entgegen.

Um sicherzustellen, dass die Protokollierung wie gewünscht funktioniert, wird
diese durch die entsprechenden Testfälle abgedeckt.

Der einfachste Testfall ist die Standardkonfiguration, also ein Aufruf ohne
Parameter.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Testfall 1 der Protkollierung der Hauptapplikation: Aufruf ohne Argumente.
#+NAME:       test-app-test-logging-default
#+BEGIN_SRC   python
def test_setup_logging_without_arguments():
    """Test logging of QDE application without arguments."""
    app = application.QDE(sys.argv)
    root_logger = logging.root
    handlers = root_logger.handlers
    assert len(handlers) == 1
    handler = handlers[0]
#+END_SRC

#+RESULTS: test-app-test-logging-default

Da obige Testfälle das /logging/-Module benötigen, muss das Importieren der Module
entsprechend erweitert werden.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Erweiterung des Importes von System-Modulen im Modul zum Testen der Applikation.
#+NAME: test-app-system-imports
#+HEADER: :prologue <<test-app-system-imports>>
#+BEGIN_SRC python
import logging
#+END_SRC

Und der Testfall muss den Testfällen hinzugefügt werden.

#+NAME: test-app-test-cases
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Hinzufügen des Testfalles 1 zu den bestehenden Testfällen im Modul zum Testen der Applikation.
#+HEADER: :prologue <<test-app-test-cases>>
#+BEGIN_SRC python

<<test-app-test-logging-default>>
#+END_SRC

Nun kann die eigentliche Umsetzung zur Konfiguration der Protokollierung
umgesetzt und der Klasse hinzugefügt werden.

#+NAME: app-setup-logging
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Methode zum Initialisieren der Protokollierung der Applikation.
#+BEGIN_SRC python
def setup_logging(self,
    default_path='logging.json',
    default_level=logging.INFO,
    env_key='LOG_CFG'
):
    """Setup logging configuration"""

    path = default_path
    value = os.getenv(env_key, None)

    if value:
        path = value

    if os.path.exists(path):
        with open(path, 'rt') as f:

            config = json.load(f)
            logging.config.dictConfig(config)
    else:
        logging.basicConfig(level=default_level)
#+END_SRC


#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Haupt-Modul und Einstiegspunkt der Applikation.
#+BEGIN_SRC python :tangle ../src/qde/editor/application/application.py :noweb tangle :comments link :mkdirp yes
  # -*- coding: utf-8 -*-

  """Main application module for QDE."""

  <<app-imports>>

  <<app-class-definition>>
#+END_SRC

#+RESULTS:

#+NAME: app-imports
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition der Importe des Haupt-Modules.
#+BEGIN_SRC python
<<app-system-imports>>

<<app-project-imports>>
#+END_SRC

#+NAME: app-system-imports
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Importe von Python-eigenen Modulen im Haupt-Modul.
#+BEGIN_SRC python
# System imports
from   PyQt5.Qt import QApplication
from   PyQt5.Qt import QIcon
import logging
import os
#+END_SRC

#+NAME: app-project-imports
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Importe von selbst verfassten Modulen im Haupt-Modul.
#+BEGIN_SRC python
# Project imports
from qde.editor.foundation import common
#+END_SRC

#+NAME: app-constructor
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Konstruktor des Haupt-Modules.
#+BEGIN_SRC python
def __init__(self, arguments):
    """Constructor.

    :param arguments: a (variable) list of arguments, that are
                      passed when calling this class.
    :type  argv:      list
    """

    super(QDE, self).__init__(arguments)
    self.setWindowIcon(QIcon("assets/icons/im.png"))
    self.setApplicationName("QDE")
    self.setApplicationDisplayName("QDE")

    self.setup_logging()
#+END_SRC

Der Konstruktor und die Methode zum Einrichten der Protokollierung werden
schliesslich der Klasse hinzugefügt.

#+NAME: app-class-body
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Hinzufügen des Konstruktors sowie der Methode zum Einrichten der Protokollierung zum Körper des Haupt-Modules.
#+HEADER: :prologue <<app-class-body>>
#+BEGIN_SRC python
<<app-constructor>>

<<app-setup-logging>>
#+END_SRC

Somit ist es nun möglich die Testfälle der Applikation auszuführen.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Ausführen der Testfälle für das Haupt-Modul.
#+BEGIN_SRC bash :dir ../src :results output silent
python -m pytest qde/editor/application/test_application.py
#+END_SRC

* Footnotes

[fn:8] https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces 

[fn:7] https://docs.python.org/3/library/logging.html

[fn:6] https://www.python.org/dev/peps/pep-0318/

[fn:5] http://doc.qt.io/Qt-5/qapplication.html#exec

[fn:4] http://doc.qt.io/Qt-5/qapplication.html

[fn:3] https://github.com/yyuu/pyenv-virtualenv

[fn:2] https://github.com/yyuu/pyenv

[fn:1] https://www.python.org

* Worklog

<2017-02-20 Mon> Initiale Struktur des Dokumentes

* Bibliography

\printbibliography{}

* Appendix

** Meeting minutes

*** Meeting mintutes 2017-02-23

| No.:              | 01                                                                   |
| Date:             | 2017-02-23 13:00 - 13:30                                             |
| Place:            | Cafeteria, Main building, Berne University of applied sciences, Biel |
| Involved persons: | Prof. Claude Fuhrer (CF)                                             |
|                   | Sven Osterwalder (SO)                                                |

Kick-off meeting for the thesis.

**** Presentation and discussion of the current state of work

- Presentation of the workflow. Emacs and Org-Mode is used to write the
  documentation as well as the actual code. (SO)
  - This is a very interesting approach. The question remains if the effort of
    this method does not prevail the method of developing the application and
    the documentation in parallel. It is important to reach a certain state of
    the application. Also the report should not exceed around 80 pages. (CF)
    - A decision about the used method is made until the end of this week. (SO)
- The code will unit-tested using py.test and / or hypothesis. (SO)
- Presentation of the structure of the documentation. It follows the schematics
  of the preceding documentations. (SO)

**** Further steps / proceedings

- The expert of the thesis, Mr. Dubuis, puts mainly emphasis on the
  documentation. The code of the thesis is respected too, but is clearly not the
  main aspect. (CF)
- Mr. Dubuis also puts emphasis on code metrics. Therefore the code needs to be
  (automatically) tested and a coverage of at least 60 to 70 percent must be
  reached. (CF)
- A meeting with Mr. Dubuis shall be scheduled at the end of March or beginning
  of April 2017. (CF)
- The administrative aspects as well as the scope should be written until end of
  March 2017 for being able to present them to Mr. Dubuis. (CF)
- Mr. Dubuis should be asked if the publicly available access to the whole
  thesis is enough or if he wishes to receive the particular status right before
  the meetings. (CF)
- Regularly meetings will be held, but the frequency is to be defined yet.
  Further information follows per e-mail. (CF)
- At the beginning of the studies, a workplace at the Berne University of
  applied sciences in Biel was offered. Is this possibility still available?
  (SO)
  - Yes, that possibility is still available and details will be clarified and
    follow per e-mail. (CF)

**** To do for the next meeting

***** TODO Create GitHub repository for the thesis. (SO)

****** TODO Inform Mr. Fuhrer about the creation of the repository. (SO)

***** TODO Ask Mr. Dubuis by mail how he wants to receive the documentation. (SO) 

***** TODO Set up appointments with Mr. Dubuis (CF)

***** DONE Clarify possibility of a workplace at Berne University of applied sciences in Biel. (CF)
      CLOSED: [2017-02-24 Fri 07:49]

****** A workplace was found at the RISIS laboratory and may be used instantly. (CF)

***** DONE Decide about the method used for developing this thesis. (SO)
      CLOSED: [2017-02-24 Fri 16:29]

****** After discussions with a colleague the method of literate programming is
       kept. The documentation containing the literate program will although be
       attached as appendix as it most likely will exceed 80 pages. Instead the
       method will be introduced in the report and the report will be endowed
       with examples from the literate program.

**** Scheduling of the next meeting

- To be defined
