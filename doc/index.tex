\newcommand{\NWtarget}[2]{\hypertarget{#1}{#2}}
\newcommand{\NWlink}[2]{\hyperlink{#1}{#2}}
\newcommand{\NWtxtMacroDefBy}{Fragment defined by}
\newcommand{\NWtxtMacroRefIn}{Fragment referenced in}
\newcommand{\NWtxtMacroNoRef}{Fragment never referenced}
\newcommand{\NWtxtDefBy}{Defined by}
\newcommand{\NWtxtRefIn}{Referenced in}
\newcommand{\NWtxtNoRef}{Not referenced}
\newcommand{\NWtxtFileDefBy}{File defined by}
\newcommand{\NWtxtIdentsUsed}{Uses:}
\newcommand{\NWtxtIdentsNotUsed}{Never used}
\newcommand{\NWtxtIdentsDefed}{Defines:}
\newcommand{\NWsep}{${\diamond}$}
\newcommand{\NWnotglobal}{(not defined globally)}
\newcommand{\NWuseHyperlinks}{}
% -*- mode: latex; coding: utf-8 -*-

\documentclass[%
    a4paper,    % Use A4, not US letter!
    justified,  % Use justified text
    nobib,      % Disable natbib
    openany     % Remove blank pages used for two page layout
]{tufte-book}

% -*- mode: latex; coding: utf-8 -*-

\makeatletter
% textwidth Tuftian float for listings
\newenvironment{listing}[1][htbp]
  {\ifvmode\else\unskip\fi\begin{@tufte@float}[#1]{lstlisting}{}}
  {\end{@tufte@float}}
% fullwidth Tuftian float for listings
\newenvironment{listing*}[1][htbp]%
  {\ifvmode\else\unskip\fi\begin{@tufte@float}[#1]{lstlisting}{star}}
  {\end{@tufte@float}}
% enable re-use of \listoflistings facility
\def\ext@lstlisting{lol}
% show listing number in caption even though \lst@@caption is empty
\def\fnum@lstlisting{\lstlistingname~\thelstlisting}
\makeatother

\renewcommand{\label}[1]{\@tufte@label{##1}}%
% Handle subfigure package compatibility
\ifthenelse{\boolean{@tufte@packages@subfigure}}{%
  % don't move the label while inside a \subfigure or \subtable command
  \global\let\label\@tufte@orig@label%
}{}% subfigure package is not loaded

\makeatletter
\setboolean{@tufte@packages@subfigure}{true}
\makeatother

% Load packages
% ---------------------------------------------------------------------------
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\usepackage{minted}
\usepackage[english]{babel}              % English hyphenation
\usepackage[utf8]{inputenc}              % UTF-8 input encoding
% \usepackage[T1]{fontenc}                 % hyphenation of words with ä,ö and ü
\usepackage{booktabs,tabularx}           % package for nicer tables
\usepackage{pgfgantt}                    % Provides GANTT charts
\usepackage[owncaptions]{vhistory}       % Provides framework for creating history outline
\usepackage{csquotes}                    % Quotes
\usepackage{nameref}                     % Allows referencing of names
\usepackage{blindtext}                   % Dummy text
\usepackage[pages=some]{background}            % Backgrounds
\usepackage[absolute,overlay]{textpos}
\usepackage{hyperref}
\usepackage{makeidx}
\usepackage[nonumberlist,nomain]{glossaries}
\usepackage{todonotes}
\usepackage[
    backend=biber,
    doi=true,
    eprint=false,
    natbib=true,
    style=ieee,
    url=false
]{biblatex}
\usepackage{bookmark}
\usepackage{esvect}                          % Provides nicer vector display in math mode
\usepackage[inline]{enumitem}
\usepackage{tikz}
\usepackage{float}
\usepackage{cleveref}
\usepackage[figuresright]{rotating}

% Settings
%---------------------------------------------------------------------------
% TIKZ: A lot of arrows for TIKZ
\usetikzlibrary{arrows.meta}

% TUFTE: Do not break when there already is a break
% Source: https://tex.stackexchange.com/questions/291746/tufte-latex-newthought-after-section
\makeatletter
\def\tuftebreak{%
  \if@nobreak\else
    \par
    \ifdim\lastskip<\tufteskipamount
      \removelastskip \penalty -100
      \tufteskip
    \fi
  \fi
}
\makeatother

% Environments
% ---------------------------------------------------------------------------
\newenvironment{loggentry}[2]% date, heading
{\noindent\textbf{#1}\marginnote{#2}\\}

% Commands
%---------------------------------------------------------------------------
% -*- mode: latex; coding: utf-8 -*-

% Prints the month name (e.g., January) and the year (e.g., 2008)
\newcommand{\monthyear}{%
  \ifcase\month\or January\or February\or March\or April\or May\or June\or
  July\or August\or September\or October\or November\or
  December\fi\space\number\year
}

% Provide references to footnotes to re-use existing.
\newcommand{\footref}[1]{\textsuperscript{\ref{#1}}}

% Used for tables
\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}}

% Provide possibility to cite also the first name of an author
% https://tex.stackexchange.com/questions/211755/controlling-first-name-display-in-biblatex-citeauthor
\DeclareCiteCommand{\citeauthorfin}
  {\renewcommand*{\mkbibnamelast}[1]{####1}%
   \boolfalse{citetracker}%
   \boolfalse{pagetracker}%
   \usebibmacro{prenote}}
  {\ifciteindex
     {\indexnames{labelname}}
     {}%
   % \printnames[initsonly]{author} % too strong, all is initials (D.E.K.)
   %\printnames[firstinits=true,first-last]{author}} % cannot:
   % \ExecuteBibliographyOptions{firstinits=false} % only in preamble!
   % so must use setkeys:
   \setkeys{blx@opt@pre}{firstinits=true}%
   \printnames[first-last]{author}%
   \setkeys{blx@opt@pre}{firstinits=false}% restore - assuming false is default, which here it is
  }
  {\multicitedelim}
  {\usebibmacro{postnote}}
\makeatother%
\DeclareCiteCommand{\citeauthorffn}
  {\renewcommand*{\mkbibnamelast}[1]{####1}%
   \boolfalse{citetracker}%
   \boolfalse{pagetracker}%
   \usebibmacro{prenote}}
  {\ifciteindex
     {\indexnames{labelname}}
     {}%
   \printnames[first-last]{author}}
  {\multicitedelim}
  {\usebibmacro{postnote}}

% Multiple footnotes
% https://tex.stackexchange.com/questions/28465/multiple-footnotes-at-one-point
\let\oldFootnote\footnote
\newcommand\nextToken\relax
\renewcommand\footnote[1]{%
    \oldFootnote{#1}\futurelet\nextToken\isFootnote}
\newcommand\isFootnote{%
    \ifx\footnote\nextToken\textsuperscript{,}\fi}
% Definition of colors
%---------------------------------------------------------------------------
% -*- mode: latex; coding: utf-8 -*-

\definecolor{linkblue}{rgb}{0,0,0.8}       % Standard
\definecolor{darkblue}{rgb}{0,0.08,0.45}   % Dark blue
\definecolor{bfhgrey}{rgb}{0.41,0.49,0.57} % BFH grey
\definecolor{linkcolor}{rgb}{0,0,0}
\colorlet{Black}{black}
\definecolor{keywords}{rgb}{255,0,0}
\definecolor{red}{rgb}{0.6,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{blue}{rgb}{0,0,0.5}
% Syntax colors
\definecolor{syntaxRed}{rgb}{0.6,0,0}
\definecolor{syntaxBlue}{rgb}{0,0,0.5}
\definecolor{syntaxComment}{rgb}{0,0.5,0}
% Background colors
\definecolor{titlepagecolor}{cmyk}{1,.60,0,.40}
\definecolor{syntaxBackground}{rgb}{0.95, 0.95, 0.95}

% (Code-) Listings
%---------------------------------------------------------------------------
% -*- mode: latex; coding: utf-8 -*-

\newminted{python}{%
    bgcolor=LightGray,
    escapeinside=||,
    linenos=true,
    mathescape=true,
}

% Generate index
%---------------------------------------------------------------------------
\makeindex

% Global variables
%---------------------------------------------------------------------------
\newcommand{\titletext}{QDE.}
\newcommand{\subtitletext}{A system for composing real time computer graphics.}
\newcommand{\subsubtitletext}{MTE7103 --- Master thesis}
\author[Sven Osterwalder]{Sven Osterwalder}
\publisher{Berne University of Applied Sciences}
\title[\titletext{}~\subtitletext{}]{\titletext{}~\subtitletext{}}

% Commands
%----------------------------------------------------------------------------
\renewcommand\labelenumi{(\theenumi)}

% Background set up
%---------------------------------------------------------------------------
\backgroundsetup{
    scale=1,
    angle=0,
    opacity=1,
    contents={
        \begin{tikzpicture}[remember picture,overlay]
            \node[anchor=south west, inner sep=0pt,outer sep=0pt] at (current page.south west) {%
                \includegraphics[width=1.0\paperwidth,height=0.5\paperheight]{images/bg}
            };
        \end{tikzpicture}
    }
}
\makeatletter
\def\printauthor{%
    {\large \@author}}
\makeatother

% Set up bibliography
%----------------------------------------------------------------------------
\addbibresource{inc/bibliography.bib}
\DefineBibliographyStrings{ngerman}{
    andothers = {{et\,al\adddot}},
}

\begin{document}

% Title Page and Abstract
%---------------------------------------------------------------------------
\setcounter{page}{1}
% -*- mode: latex; coding: utf-8 -*-

\begin{titlepage}
    \BgThispage
    \begin{fullwidth}%
        \sffamily%
        \fontsize{36}{40}\selectfont\par\noindent\textcolor{darkgray}{\allcaps{\titletext{}}}
        \vspace{3mm}
        \fontsize{18}{20}\selectfont\par\noindent\textcolor{darkgray}{\allcaps{\subtitletext{}}}
        \vspace{6mm}
        \fontsize{14}{16}\selectfont\par\noindent\allcaps{\subsubtitletext{}}%
        \vspace{24mm}
        \normalsize\normalfont%
        \begin{tabbing}
        xxxxxxxxxxxxxxx \= xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \kill
        Major:          \> Computer science                              \\
        Author:         \> Sven Osterwalder\protect\footnotemark[1]{}    \\
        Advisor:        \> Prof.~Claude Fuhrer\protect\footnotemark[2]{} \\
        Expert:         \> Dr.~Eric Dubuis\protect\footnotemark[3]{}     \\
        Date:           \> \vhCurrentDate{}                              \\
        Version:        \> \vhCurrentVersion                             \\
        \end{tabbing}
        \vspace{10mm}
        \begin{tabularx}{0.5\textwidth}{@{}XX@{}}
            \includegraphics[width=50px]{images/by-sa-big} & 
            \includegraphics[height=20pt]{images/BFH_Logo_B} \\

            \tiny{\sffamily{This work is licensed under
            a~\href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative
            Commons Attribution-ShareAlike 4.0 International
            License}.}}\index{license}
            & \tiny{\sffamily{Berne University of Applied Sciences}}\\
        \end{tabularx}
        \footnotetext[1][-10pt]{sven.osterwalder@students.bfh.ch}
        \footnotetext[2]{claude.fuhrer@bfh.ch}
        \footnotetext[3]{eric.dubuis@comet.ch}
    \end{fullwidth}%
\end{titlepage}
\restoregeometry
\thispagestyle{empty}%
\clearpage%

% -*- mode: latex; coding: utf-8 -*-

% Versions:
% -----------------------------------------------

\chapter*{}
\label{chap:versions}

\begin{versionhistory}
    \vhEntry{ 89c7544 }{ 2017-02-28 17:09:43 }{ SO }{ Set up initial project structure, provide first content }
    \vhEntry{ 10192d8 }{ 2017-03-02 22:37:17 }{ SO }{ Set up project schedule }
    \vhEntry{ 54f4b23 }{ 2017-03-05 22:53:15 }{ SO }{ Set up project structure, implement main entry point and main window }
    \vhEntry{ ffda0e5 }{ 2017-03-15 10:58:51 }{ SO }{ Scene graph, logging, adapt project schedule }
    \vhEntry{ 34b09b7 }{ 2017-03-24 17:08:22 }{ SO }{ Update meeting minutes, thoughts about node implementation }
    \vhEntry{ 06fe268 }{ 2017-04-03 23:00:35 }{ SO }{ Add requirements, node graph implemenetation }
    \vhEntry{ d264175 }{ 2017-04-10 16:07:01 }{ SO }{ Conversion from Org-Mode to Nuweb, revise editor implementation }
    \vhEntry{ f8b524b }{ 2017-04-30 23:42:57 }{ SO }{ Approach node graph and nodes }
    \vhEntry{ 2f46832 }{ 2017-05-04 21:13:41 }{ SO }{ Impel node definitions further }
    \vhEntry{ ae34fc5 }{ 2017-05-24 13:56:31 }{ SO }{ Change class to tufte-book, title page, introduction, further implementation }
    \vhEntry{ 27c549c }{ 2017-05-24 22:28:41 }{ SO }{ Change document structure, re-work admin. aspects }
    \vhEntry{ 6772ef9 }{ 2017-05-27 14:18:09 }{ SO }{ Adapt document structure, fundamentals: introduction and rendering }
    \vhEntry{ 399669d }{ 2017-05-29 09:10:48 }{ SO }{ Finish fundamentals }
    \vhEntry{ 66f4421 }{ 2017-06-11 22:41:25 }{ SO }{ Add methodologies, begin adding results }
    \vhEntry{ a1e709d }{ 2017-06-27 12:43:16 }{ SO }{ Update meeting minutes, restructure appendix, add results }
    \vhEntry{ 52bb736 }{ 2017-07-11 17:16:21 }{ SO }{ Remove obsolete parts, first corrections }
    \vhEntry{ 2a95fb7 }{ 2017-07-20 16:19:39 }{ SO }{ Finish corrections and implementation }
    \vhEntry{ 9f4da06 }{ 2017-07-28 23:56:18 }{ SO }{ Final version of the main part }
    \vhEntry{ 3cbe0dc }{ 2017-07-30 22:29:46 }{ SO }{ Addendum to original hand-in: fix scraps and references }
    
\end{versionhistory}% -*- coding: utf-8; mode: latex; -*-

\chapter*{Abstract}
\label{chap:abstract}

% Richtet sich der Bericht an eine breitere Öffentlichkeit oder an technische Laien, die aufgrund fehlender
% Sachkenntnis nicht den ganzen Bericht lesen wollen, dann kann die Zusammenfassung zum
% wichtigsten Teil eines Berichts werden [3, p. 24]. Die Zusammenfassung ist der meistgelesene Teil
% einer Publikation. Sie gibt einen Überblick zur Problemstellung, zum Inhalt und zu den Resultaten des
% Berichts. Eine gute Zusammenfassung kann die Leserin, den Leser ermutigen, ausgewählte Teile der
% Arbeit oder den gesamten Bericht zu studieren.
% Die Zusammenfassung muss unabhängig vom Rest der Arbeit verständlich sein und besonders
% schlüssig formuliert werden. Literaturangaben werden in der Zusammenfassung keine gemacht.
% Die Zusammenfassung gehört an den Anfang eines Berichts. Oft wird sie auch mit Abstract oder
% Summary bezeichnet.
% Je nach Länge der Arbeit werden der Auftrag, die Ausgangslage, das Vorgehen und die wesentlichen
% Ergebnisse und Schlussfolgerungen des Berichts im Umfang zwischen einer halben und maximal einer
% ganzen A4-Seite dargelegt. Die eigenen Resultate bilden den inhaltlichen Schwerpunkt der
% Zusammenfassung.
% Die Zusammenfassung wird erst am Ende des Arbeitsprozesses verfasst.

\newthought{Computer science has always strived} to create representations of
scenes and models as near to human reality as possible. One such representation
is~\emph{ray tracing}, based on the physics of light as well as the properties
of surface materials. In contrast to ray tracing,~\emph{sphere tracing} allows
the rendering of ray traced images in real-time.

\newthought{The de facto way of representing objects} however, using triangle
based meshes, cannot be used directly with this method. Instead, an alternative
basis uses distance fields defined by implicit functions. At present there are
no solutions known to the author that provide a convenient way to use implicit
functions for modeling and sphere tracing for rendering.

\newthought{This thesis presents the design and development} of a program which
provides both a modular, node based approach for modeling and animating objects
using implicit functions, and allows rendering in real-time using sphere
tracing.

\newthought{To reach the intended goal}, the approach was to develop a software
architecture and to use literate programming and the agile methodology of
extreme programming for development.~\emph{Literate programming} considers
programs as works of literature. A literate program includes documentation which
explains in human terms what the computer must do.
% To overcome one of the main
% challenges when developing the software --- continual change --- an adapted
% version of extreme programming was used. This methodology was selected because
% of experiences with projects involving continual adaption in which exact
% planning, analysis and design (as traditional methodologies require) would not
% have been very practical.

\newthought{The results of this thesis} are an architecture for a software
program, and the program itself, written using the literate programming
paradigm.
\newthought{Three aspects define the software architecture}:
\begin{enumerate*}
  \item the model-view-view model software design pattern using controllers in
    addition,
  \item the layered software architectural pattern and
  \item the observer software design pattern, allowing communication between
    components of the software.
\end{enumerate*}

\newthought{The software itself} is an editor which allows modeling objects,
composing objects to scenes and rendering scenes in real-time. Scenes are stored
in a scene graph structure and are represented by a tree view. Each scene can
contain one or more objects, defined by external files and represented as nodes
in the graph structure. The parameters of objects are used for interconnections
between nodes. For rendering, the sphere tracing algorithm established in the
preceding project work was used.

\newthought{Literate programming takes some accustomization} as it requires a
different way of thinking to that of conventional software development. Despite
this, the basic goals could be reached. Sphere tracing is a very interesting and
promising approach to rendering which is coming into use in the industry, for
example for calculating ambient occlusion or soft shadows. Time will tell if the
method will establish itself further and become practicable for rendering
conventional meshes.
% Table of contents / Lists of
%---------------------------------------------------------------------------
\tableofcontents{}
\listoffigures{}
\listoftables{}

% Main part
%---------------------------------------------------------------------------
\newpage{}
% -*- mode: latex; coding: utf-8 -*-

\chapter{Introduction}
\label{chap:introduction}

% Die Einleitung gibt Antwort auf die Frage, weshalb es den Bericht gibt und wie
% er zustande gekommen ist [3, p. 25]. Im ersten Teil wird das Thema der Arbeit
% eingeführt. Die Relevanz und Aktualität des Themas oder der fachliche Kontext
% der Untersuchung werden dazu kurz umschrieben. Die Einleitung hält explizit
% fest, welchen Auftrag der Bericht erfüllt [3, p. 25]. Der Auftrag muss so klar
% und präzise wie möglich formuliert werden. Auftraggeber und Auftragnehmer werden
% festgehalten. Der zweite Teil der Einleitung stellt den Ist-Zustand oder den
% bisherigen Wissensstand knapp dar. Darauf aufbauend wird das eigene Thema
% eingegrenzt. Es gibt Untersuchungen, bei denen es für das Verständnis wichtig
% ist, den genauen Ist-Zustand zu kennen. Wenn es für ein Projekt bereits ein
% Vorprojekt gibt, auf dessen Resultate der Bericht aufbaut, oder in Bauprojekten
% ist es üblich, die Ausgangslage in einem gesonderten Kapitel zu beschreiben. Im
% dritten Teil wird die präzise Fragestellung formuliert. Das Ziel des Berichts
% wird genannt und es wird erläutert, welchen Nutzen die Untersuchung haben soll.

\newthought{The application area of computer graphics} exists since the
beginning of modern computing. Computer scientists have always strived to create
realistic depictions of the observable reality.

\newthought{Over time various approaches} for creating artificial images (the so
called rendering) have evolved. One of these approaches is ray tracing. This was
introduced in~\citeyear{appel_techniques_1968}
by~\citeauthorfin{appel_techniques_1968} in the
article~\citetitle{appel_techniques_1968}~\cite{appel_techniques_1968}. In
\citeyear{whitted_improved_1980} this methods were improved
by~\citeauthorfin{whitted_improved_1980} in his work
\citetitle{whitted_improved_1980}~\cite{whitted_improved_1980}.

\newthought{Ray tracing captivates} through simplicity while providing a very
high image quality, including perfect refractions and reflections of light. For
a long time although, the approach was not efficient enough to deliver images in
real time, which requires creating at least 25 rendered images (frames) per
second. Otherwise, due to the human anatomy, the output is perceived as either
still and jerky images or as a too slow animation.

\newthought{Sphere tracing} is a ray tracing approach introduced
in~\citeyear{hart_sphere_1994} by~\citeauthorfin{hart_sphere_1994} in his
work~\citetitle{hart_sphere_1994}~\cite{hart_sphere_1994}. This approach is
faster than the classical ray tracing approaches in its method of finding
intersections between rays and objects.

\newthought{Graphics processing units (GPUs)} have evolved over time and have
become exponentially more powerful in processing power. Since around 2009, GPUs are able to
produce real time computer graphics using sphere tracing. While allowing ray
tracing in real time on modern GPUs, sphere tracing has, however, a clear
disadvantage. The de facto way of representing the surface of objects using triangle based
meshes cannot be used directly. Instead, distance functions are used for
modeling the surfaces as seen from any view point.

\section{Purpose and conditions}
\label{sec:purpose}

\subsection{Motivation}
\label{subsec:motivation}

\newthought{Up to this point in time} there are no solutions (at least none are
known to the author) that provide a convenient way for modeling, animating and
rendering objects and scenes using signed distance functions for modeling and
sphere tracing for rendering.
Most of the solutions using sphere tracing implement it by having one or
multiple big fragment shaders containing everything from modeling to lighting.
Other solutions provide node based approaches, but they allow either no sphere
tracing at all, meaning they use rasterization, or they provide nodes containing
(fragment-) shader code, which leads again to a single big fragment shader.

\newthought{This thesis} aims at designing and developing a program which
provides both, a node based approach for modeling and animating objects using
signed distance functions and allowing the rendering of scenes using sphere
tracing, efficiently enough to be executed in real time on the GPU.

\subsection{Objectives and limitations}
\label{subsec:objectives}

\newthought{The objective of this thesis} is the design and development of a
program for \textit{modeling}, \textit{composing} and \textit{rendering} real
time computer graphics by providing a graphical toolbox.

\newthought{Modeling} is done by composing simple objects into complex objects
and scenes using a node based graph structure of~\enquote{nodes}.

\newthought{Composing} includes two aspects: the combination of objects into
scenes, and the creation of an animation which is defined by multiple scenes
which follow a chronological order. The first aspect is realized by a scene
graph structure. The second aspect is realized by a time line.

\newthought{For rendering}, a highly optimized algorithm based on ray tracing is
used. The algorithm is called sphere tracing and allows the rendering of ray
traced scenes in real time on the GPU. Contingent upon the rendering algorithm
used all objects are modeled using distance functions.

\newthought{Required objectives} are the following:
\begin{itemize}
  \item Development of an editor for creating and editing real time rendered
    scenes, containing the following features.
    \begin{itemize}
      \item A scene tree, allowing management (creation and deletion) of
        scenes.
      \item One node-based graph structure for each scene in the scene tree.
        This allows the composition of scenes using
        nodes and connections between the nodes.
    \item Nodes
      \begin{itemize}
        \item Simple objects defined by signed distance functions: In this
          thesis the objects are limited to cube and sphere (other solids could
          be modeled in the same way).
        \item Simple operations: Union, Intersection, Subtraction.
        \item Transformations: Rotate, Translate and Scale.
        \item Camera.
        \item Renderer (ray traced rendering using sphere tracing)
        \item Point light sources.
      \end{itemize}
    \end{itemize}
\end{itemize}

\section{Related works}
\label{sec:related-works}

\newthought{Preliminary} to this thesis two project works were completed.
The first was \enquote{Volume ray casting --- basics \&
principles}~\cite{osterwalder-volume-2016}, which describes the concepts
of sphere tracing The second was \enquote{QDE
--- a visual animation system, architecture}~\cite{osterwalder-qde-2016}, which
established the concepts of an editor and a player component, as well as
the basis for a possible software architecture for these components.

\newthought{For clarity in the explanation} of this thesis first the
architecture is presented, see section~\enquote{\nameref{soarch}}. Then the rendering is
presented in section~\enquote{\nameref{sec:rendering}}.

\section{Document structure}
\label{sec:document-structure}

\newthought{This document is divided into six chapters}, the first being this
chapter,~\enquote{\nameref{chap:introduction}}. The second
chapter~\enquote{\nameref{chap:administrative-aspects}} shows the planning of
the project, including the persons involved, the deliverables, and phases and
milestones.

\newthought{The administrative aspects are followed by} the
chapter~\enquote{\nameref{chap:fundamentals}}. The purpose of this chapter is to
present the principles, based on the previous project works mentioned above that
this thesis is built upon.

\newthought{The next chapter} on~\enquote{\nameref{chap:methodologies}}
introduces a concept called literate programming and elaborates some details of
the implementation using this. Additionally it introduces standards and
principles for implementation of the developed software.

\newthought{The following chapter} on~\enquote{\nameref{chap:implementation}}
describes the editor component.

\newthought{The last chapter}~\enquote{\nameref{chap:discussion-conclusion}}
considers the methodologies as well as the results. Some further work on the
editor and the player components is proposed as well.

\newthought{After the regular content} follow appendices,
see~\enquote{\nameref{part:appendix}}, detailing the requirements for building
the above-mentioned components, and the actual source code in form of a literal
program.
% -*- mode: latex; coding: utf-8 -*-

\chapter{Administrative aspects}
\label{chap:administrative-aspects}

% Link to previous
% Make a connection to what has immediately gone before. Recap the last chapter.
% In the last chapter I showed that… Having argued in the previous chapter that…
% As a result of x, which I established in the last chapter….. It is also possible
% to make a link between this chapter and the whole argument… The first step in
% answering my research question (repeat question) .. was to.. . In the last
% chapter I …
\newthought{The previous chapter} provided an introduction to this thesis by
outlining the purpose and conditions, the previous works and structure of this
work.

% Focus: What does this chapter specifically do?
% Now focus the reader’s attention on what this chapter is specifically going to
% do and why it is important. In this chapter I will examine.. I will present… I
% will report … This is crucial in (aim of thesis/research question) in order to….
\newthought{This chapter} covers administrative aspects of this project,
although they are not required for an understanding of the results.

% Overview: How is it done?
% The third paragraph simply outlines the way that you are going to achieve the
% aim spelled out in the previous paragraph. It’s really just a statement of the
% contents in the order that the reader will encounter them. It is important to
% state these not simply as topics, but actually how they build up the internal
% chapter argument… I will begin by examining the definitions of, then move to
% seeing how these were applied… I first of all explain my orientation to the
% research process, positioning myself as a critical scholar.. I then explain the
% methodology that I used in the research, arguing that ethnography was the most
% suitable approach to provide answers to the question of…
\newthought{The first section} defines the persons involved and their roles
during this thesis. Afterwards the deliverable items are defined and described.
The last section elaborates on the organization of the project work involved,
including meetings, phases and milestones as well as the work schedule.

\section{Involved persons}
\label{sec:involved_persons}

\begin{table}[h]
  \caption{List of the involved persons.}
  \begin{tabularx}{\textwidth}{llX}
    \toprule
    \textbf{Role} & \textbf{Name} & \textbf{Task} \\
    \midrule
    \textit{Author}  & Sven Osterwalder\protect\footnotemark[1]{} & Author of the thesis.\\
    \textit{Advisor} & Prof.\ Claude Fuhrer\protect\footnotemark[2]{} & Supervises the student doing the thesis.\\
    \textit{Expert}  & Dr.\ Eric Dubuis\protect\footnotemark[3]{}     & Provides expertise concerning the thesis's subject, monitors and grades the thesis.\\
    \bottomrule
  \end{tabularx}
\end{table}
\footnotetext[1]{sven.osterwaldertudents.bfh.ch}
\footnotetext[2]{claude.fuhrer@bfh.ch}
\footnotetext[3]{eric.dubuis@comet.ch}

\newpage{}

\section{Deliverables}
\label{sec:deliverables}

\begin{table}[h]
  \caption{List of deliverables.}
  \begin{tabularx}{\textwidth}{lX}
    \toprule
    \textbf{Deliverable}    & \textbf{Description}                            \\
    \midrule
    \textit{Report}         & The report contains the theoretical and technical details for
    implementing a system for composing real time computer graphics.          \\
    \midrule
    \textit{Implementation} & The implementation of the system for composing real time
    computer graphics, developed during this project.                         \\
    \midrule
    \textit{Presentation}   & The presentation of the defense of this thesis. \\
    \bottomrule
  \end{tabularx}
\end{table}

\section{Organization of work}
\label{sec:organization-of-work}

\subsection{Meetings}
\label{subsec:meetings}

\newthought{Various meetings} with the supervisor and the expert helped to reach
the defined goals and to prevent erroneous directions during the project. The
supervisor and the expert supported the author by providing suggestions
throughout the work period. 

\subsection{Phases and milestones}
\label{subsec:project-phases-milestones}

\begin{table}[h]
  \caption{Phases of the project.}
  \begin{tabularx}{\textwidth}{Xr}
    \toprule
    \textbf{Phase}   & \textbf{Week / 2017} \\
    \midrule
    Start of the project & 8 \\
    Definition of objectives and constraints & 8-9 \\
    Documentation and development & 8-30 \\
    Final review & 30-31 \\
    Preparation for the defense of the thesis & 31-32 \\
    \bottomrule
  \end{tabularx}
\end{table}

\begin{table}[h]
  \caption{Milestones of the project.}
  \begin{tabularx}{\textwidth}{Xr}
    \toprule
    \textbf{Milestone}   & \textbf{End of week / 2017} \\
    \midrule
    Project structure is set up & 8 \\
    Mandatory project goals are reached & 30 \\
    Hand-in of the thesis & 31 \\
    Defense of the thesis & 32 \\
    \bottomrule
  \end{tabularx}
\end{table}

\newpage{}

\subsection{Schedule}
\label{subsec:project-schedule}

\begin{figure*}[ht]
    \begin{ganttchart}[
        vgrid,
        x unit=4.5mm,
        y unit chart=0.87cm,
        bar/.append style={fill=bfhgrey!50},
    ]{1}{26}
        \gantttitle{2017}{26} \ganttnewline{}
        \gantttitlelist{7,...,32}{1} \ganttnewline{}
        \ganttbar{Start of the project}{1}{1} \ganttnewline{}
        \ganttmilestone{Project is set up}{1} \ganttnewline{}
        \ganttlinkedbar{Objectives and limitations}{2}{3} \ganttnewline{}
        \ganttlinkedbar{Documentation}{3}{23} \ganttnewline{}
        \ganttbar{Development}{3}{23} \ganttnewline{}
        \ganttmilestone{Goals reached}{23} \ganttnewline{}
        \ganttlinkedbar{Corrections}{23}{24} \ganttnewline{}
        \ganttmilestone{Hand-in}{24} \ganttnewline{}
        \ganttlinkedbar{Thesis' defense preparation}{25}{26} \ganttnewline{}
        \ganttmilestone{Thesis defense}{26}
    \end{ganttchart}
    \caption{Schedule of the project. The subtitle displays calendar weeks.}
\end{figure*}

% TODO: Risk analysis and management
% -*- mode: latex; coding: utf-8 -*-

\chapter{Fundamentals}
\label{chap:fundamentals}

% Der aktuelle Wissensstand zum behandelten Thema oder zur Fragestellung muss zu
% Beginn der Arbeit beschrieben werden. Die Vorarbeiten und Publikationen, auf die
% sich der Bericht stützt, werden genannt [3, p. 26]. Je nach Arbeit und
% Zielpublikum werden die Grundlagen kurz zusammengefasst und einander
% gegenübergestellt. Der theoretische Hintergrund oder Normen, die für die
% Untersuchung eine Rolle spielen, werden objektiv dargestellt. Gibt es nur sehr
% wenige Grundlagen, die eingangs der Arbeit erläutert werden müssen, können diese
% Informationen auch als Absatz in der Einleitung oder als Unterkapitel zum
% Kapitel der Einleitung verfasst werden.

% Link to previous
% Make a connection to what has immediately gone before. Recap the last chapter.
% In the last chapter I showed that… Having argued in the previous chapter that…
% As a result of x, which I established in the last chapter….. It is also possible
% to make a link between this chapter and the whole argument… The first step in
% answering my research question (repeat question) .. was to.. . In the last
% chapter I …
\newthought{The previous chapter} covered administrative aspects including the
persons involved, phases and the schedule, and milestones of the project work.

% Focus: What does this chapter specifically do?
% Now focus the reader’s attention on what this chapter is specifically going to
% do and why it is important. In this chapter I will examine.. I will present… I
% will report … This is crucial in (aim of thesis/research question) in order to….
\newthought{This chapter} presents the fundamentals which are required for
an understanding of this thesis.

% Overview: How is it done?
% The third paragraph simply outlines the way that you are going to achieve the
% aim spelled out in the previous paragraph. It’s really just a statement of the
% contents in the order that the reader will encounter them. It is important to
% state these not simply as topics, but actually how they build up the internal
% chapter argument… I will begin by examining the definitions of, then move to
% seeing how these were applied… I first of all explain my orientation to the
% research process, positioning myself as a critical scholar.. I then explain the
% methodology that I used in the research, arguing that ethnography was the most
% suitable approach to provide answers to the question of…
\newthought{The first section of this chapter} defines the software architecture
that would be used for the implementation of the program implemented. It is
mainly a summary of the previous project work,~\enquote{QDE --- a visual
animation system, architecture}~\cite{osterwalder-qde-2016}. The second section
shows the algorithm which is used for rendering. It is a summary of a previous
project work,~\enquote{Volume ray casting --- basics \&
principles}~\cite{osterwalder-volume-2016}.

\section{Software architecture}
\label{soarch}
% \label{fundamentals:sec:software-architecture}

\newthought{This section} is a summary of the previous project work of the
author,~\enquote{QDE --- a visual animation system,
architecture}~\cite{osterwalder-qde-2016}. It describes the fundamentals for the
architecture for the program implemented for this thesis.

\newthought{Software architecture} is inherent to software engineering and
software development. It may be implicit, for example when developing a smaller
program where the concepts are intuitively clear and the design decisions are
self-explanatory. Unfortunately, sometimes momentary~\enquote{self-explanatory}
decisions are in retrospect deceptive, so that some documentation may be
necessary. But the architecture may also be developed as an initial conceptual
process, for instance when developing large and complex programs.

\newthought{But what is software
architecture?}~\citeauthorfin{kruchten_rup_2003}~\cite{kruchten_rup_2003} defines
software architecture as follows:~\enquote{An architecture is the \textit{set of
significant decisions} about the organization of a software system, the
selection of \textit{structural elements} and their interfaces by which the
system is composed, together with their \textit{behavior} as specified in the
collaborations among those elements, the \textit{composition} of these elements
into progressively larger subsystems, and the \textit{architectural style} that
guides this organization --- these elements and their interfaces, their
collaborations, and their composition.}

Or as~\citeauthorfin{fowler_architect_2003}~\cite{fowler_architect_2003} puts
it:~\enquote{Whether something is part of the architecture is entirely based on
whether the developers think it is important. [\ldots] So, this makes it hard to
tell people how to describe their architecture.~\enquote{Tell us what is
important.} Architecture is about the important stuff. Whatever that
is.}

\newthought{The idea envisaged for this thesis} of using a node based graph for
modeling objects and scenes and rendering them using sphere tracing was
developed in advance of this thesis. To ensure that this technical
implementation was really feasible, a prototype was developed during the
previous project work~\enquote{Volume ray casting --- basics \&
principles}~\cite{osterwalder-volume-2016}.

\newthought{The architecture of this prototype} had however evolved implicitly,
and showed itself as hard to maintain and extend by providing no clear
segregation between the data model and its representation.

\newthought{With the next project work},~\enquote{QDE --- a visual animation
system, architecture}~\cite{osterwalder-qde-2016}, a software architecture was
developed to prevent the occurrence of such problems. The software architecture
is based on the rational unified process (RUP)~\cite{kruchten_rup_2003} what
leads to an iterative approach.

\newthought{Based on the vision} of this thesis and using the methodologies of
RUP, actors are defined. The actors in turn are participants in use cases that
define functional requirements for the behavior of a system. The definition of
use cases shows the limitations of the program and define its functionality and
therefore the requirements.

\newthought{The components}, shown in~\autoref{table:software-components}
and~\autoref{fig:editor-components}, are established based on these
requirements.

\begin{table}[h]
  \begin{tabularx}{\textwidth}{lX}
    \toprule
    \textbf{Component} & \textbf{Description} \\
    \midrule
    Player & Reads objects and scenes defined by the editor component and plays
    them back in the defined chronological order.\\
    \midrule
    Editor & Allows modeling and composing of objects and
    scenes using a node based graphical user interface. Renders objects
    and scenes in real time using sphere tracing. \\
    \bottomrule
  \end{tabularx}
  \caption{Description of the components of the program implemented.}
\label{table:software-components}
\end{table}

\begin{table}[h]
  \begin{tabularx}{\textwidth}{lX}
    \toprule
    \textbf{Sub component} & \textbf{Description} \\
    Scene tree & Holds scenes in a tree like structure. A scene is a directed
    graph holding nodes.                                           \\
    Node graph & Contains all nodes which define a single scene.   \\
    Parameter  & Holds the parameters of a node of the node graph. \\
    Rendering  & Renders a node, presenting it for a viewer.       \\
    Time line  & Depicts temporal events in terms of scenes which follow a
    chronological order.                                           \\
    \bottomrule
  \end{tabularx}
  \caption{Description of the sub components of the editor component.}
\label{table:editor:sub-components}
\end{table}

\begin{figure}[ht]
  \caption{%
    A mock up of the editor application showing its components.\newline{}
    1: Scene tree.\newline{}
    2: Node graph.\newline{}
    3: Parameter view.\newline{}
    4: Rendering view.\newline{}
    5: Time line.
  }
\label{fig:editor-components}
  \includegraphics[width=0.95\linewidth]{images/editor-components}
\end{figure}

\newthought{Identifying the components} helps finding the important conceptual items.
Decomposing a domain into noteworthy concepts is~\enquote{the quintessential object-oriented analysis
step}~\cite{larman-applying-2004}.~\enquote{The domain model is a visual
representation of conceptual classes or real-situation objects in a
domain.}~\cite{larman-applying-2004}

\newthought{The editor and player components} are shown
in~\autoref{fig:editor-domain-model} and in~\autoref{fig:player-domain-model}
respectively in the form of a domain model. Each domain model is composed of
components which build the sub components of the parent component, in this case
the editor and player. These sub components represent the objects of the
respective domain.

%\begin{figure*}[h]
\begin{sidewaysfigure}
  \centering
  \caption{Domain model of the editor component.}
\label{fig:editor-domain-model}
  \includegraphics[width=0.95\linewidth]{images/editor-domain-model}
\end{sidewaysfigure}
%\end{figure*}

\begin{figure*}
  \caption{Domain model of the player component.}
\label{fig:player-domain-model}
  \includegraphics[width=0.85\linewidth]{images/player-domain-model}
\end{figure*}

\newthought{Identifying the important concepts} allows the
definition of the logical architecture and shows the overall image of
(software) classes in form of packets, subsystems and layers. For a detailed
definition of these items the reader is referred to the previous project
work~\cite[pp. 37 ff.]{osterwalder-volume-2016}.

\newthought{To reduce dependencies and the coupling} of components
a~\enquote{relaxed layered} architecture is used. In contrast to a strict
layered architecture, which allows any layer to call services or interfaces only
from the layer below, a relaxed layered architecture allows higher layers to
communicate with any lower layer. The architecture defines five layers, as shown
in~\autoref{table:layers}.

\newthought{To ensure low coupling and dependencies} also for the graphical user
interface, the models and their views are segregated using the principle of
model-view separation which states that domain objects, which are data models,
should have no direct knowledge about their corresponding objects of the
graphical user interface.

\newthought{Workflow objects} control the user interaction with the visual
objects by keeping track of the data models. Such~\textit{controllers} support the
model-view separation principle and exist in the application layer.

\begin{table}[h]
  \caption{Layers as envisaged during the conceptual phase and used for
    the program implemented.}
\label{table:layers}
  \begin{tabularx}{\textwidth}{lX}
    \toprule
    \textbf{Layer} & \textbf{Description}\\
    \midrule
    UI                 & All elements of the graphical user interface.                                       \\
    Application        & Controllers (workflow objects).                                                     \\
    Domain             & Data models according to the logic of the application.                              \\
    Technical services & Technical infrastructure, such as graphics, window creation and so on.              \\
    Foundation         & Basic elements and low level services, such as timer, arrays or other data classes. \\
    \bottomrule
  \end{tabularx}
\end{table}

\newthought{Class diagrams are used to provide a software point of view},
whereas domain models provide rather a conceptual point of view. A class
diagram~\footnote{The concepts of RUP and OOP are as used in the previous
project (QDE) and therefore will not be detailed here.} shows classes,
interfaces and their relationships.~\autoref{fig:editor-class-diagram} shows the
class diagram of the editor component and~\autoref{fig:player-class-diagram}
shows the class diagram for the player component.

\begin{sidewaysfigure}
  \caption{Class diagram of the editor component.}
\label{fig:editor-class-diagram}
  \includegraphics[width=0.85\linewidth]{images/editor-class-diagram}
\end{sidewaysfigure}

%\begin{figure*}[ht]
\begin{sidewaysfigure}
  \centering
  \caption{Class diagram of the player component.}
\label{fig:player-class-diagram}
  \includegraphics[width=0.9\linewidth]{images/player-class-diagram}
\end{sidewaysfigure}
%\end{figure*}

\newpage{}

\section{Rendering}
\label{sec:rendering}

\newthought{This section} is a summary of the previous project
work of the author,~\enquote{Volume ray casting --- basics \&
principles}~\cite{osterwalder-volume-2016}. It describes the fundamentals for
the rendering algorithm that is used for the program implemented in this thesis.

\newthought{Rendering} is the second main aspect of this thesis, as the
objective is the design and development of a program for modeling, composing and
\textit{rendering} real time computer graphics by providing a graphical toolbox.

\newthought{\citeauthorfin{foley_computer_1996} describes rendering}
as a~\enquote{process of creating images from
models}~\cite{foley_computer_1996}. The basic idea of rendering is to determine
the color of a surface at each point. For this task two concepts have
evolved: \textit{illumination models} and \textit{shading models}.

\newthought{Illumination models} describe the amount of light that is
transmitted from a point on a surface to a viewer. There exist two kinds of
illumination models: local illumination models and global illumination models.
Whereas local illumination models aggregate local data from adjacent surfaces
and directly incoming light from light sources, global illumination models
consider also indirect light from reflections and refractions. The algorithm
used for rendering in the implemented program uses a \textit{global illumination
model}.

\newthought{Shading models} define when and how to use which illumination model.

\newthought{Global illumination models}~\enquote{express the light being
transferred from one point to another in terms of the intensity of the light
emitted}~\cite[pp. 775 and 776]{foley_computer_1996}. Additionally to this
direct intensity, the indirect intensity is considered, meaning~\enquote{the
intensity of light emitted from all other points that reaches the first and is
reflected from the first to the second}~\cite[pp. 775 and
776]{foley_computer_1996} point is added.

\newpage{}

\newthought{In 1986 James Kajiya} set up the so called rendering equation, which
expresses this behavior.~\parencites{kajiya_rendering_1986}[p.
776]{foley_computer_1996} The rendering equation is shown
in~\autoref{eq:rendering-equation}.

\begin{figure}
  \begin{equation}
    I(x, x') = g(x, x')\left[\varepsilon(x, x') + \int\limits_{S}\rho(x, x', x'')I(x', x'')dx''\right]
  \end{equation}
  \caption{The rendering equation as defined by James~\enquote{Jim} Kajiya.}
\label{eq:rendering-equation}
\end{figure}

\marginnote{%-130pt
  \begin{description}
    \item[$x, x' \text{and } x''$] Points in space.
    \item[$I(x, x')$] Intensity of the light going from point $x'$ to point $x$.
    \item[$g(x, x')$] A geometrical scaling factor:
      \begin{itemize}
        \item[--] $0$ if $x$ or $x'$ are occluded by each other.
        \item[--] $\frac{1}{r^2}$ if $x$ and $x'$ are visible to one other, $r$ being
          the distance them.
      \end{itemize}
    \item[$\varepsilon(x, x')$] Intensity of the light being emitted from point
      $x'$ to point $x$.
    \item[$\rho(x, x', x'')$] Intensity of the light going from $x''$ to $x$, being
      scattered on the surface near point $x'$.
    \item[$\int\limits_{S}$] Integral over the union of all surfaces, hence $S =
      \bigcup\limits_{i=0}^{n} S_{i}$, $n$ being the number of surfaces.
      All points $x$, $x'$ and $x''$ brush all surfaces of all objects within
      the scene. Where $S_{i}$ is the surface of object $i$, and so $S_{0}$
      being an additional surface in form of a hemisphere which spans the whole
      scene and acts as background.
  \end{description}
}

% \begin{table}[h]
%   \caption{Description of the single aspects of the rendering equation.}
%   \begin{tabularx}{\textwidth}{lX}
%     \toprule
%     \textbf{Part} & \textbf{Description} \\
%     \midrule
%     $x, x' \text{and } x''$ & Points in space. \\
%     \midrule
%     $I(x, x')$ & Intensity of the light going from point $x'$ to point $x$. \\
%     \midrule
%     $g(x, x')$ & A geometrical term. \newline
%         \hspace*{4mm} $0$: \hspace*{2mm} $x$ and $x'$ are occluded by each other.
%         \newline
%         \hspace*{4mm} $1\over{r^2}$: \hspace*{1mm} $x$ and $x'$ are visible to one
%         other, $r$ being the \newline
%         \hspace*{12mm} distance between the two points. \\
%     \midrule
%     $\varepsilon(x, x')$ & Intensity of the light being emitted from point $x'$
%     to point $x$. \\
%     \midrule
%     $\rho(x, x', x'')$ & Intensity of the light going from $x''$ to $x$, being
%     scattered on the surface of point $x'$. \\
%     \midrule
%     $\int\limits_{S}$ & Integral over the union of all surfaces, hence $S =
%     \bigcup\limits_{i=0}^{n} S_{i}$, $n$ being the number of
%     surfaces.
%     All points $x$, $x'$ and $x''$ brush all surfaces of all objects within the
%     scene. $S_{0}$ being an additional surface in form of a hemisphere which
%     spans the whole scene and acts as background.\\
%     \bottomrule
%   \end{tabularx}
% \end{table}

\newthought{Implementing a global illumination model} or the rendering equation
directly for rendering images in viable (computational feasible in a workflow
for instance for the production of animated films) or even real time is not
really feasible, even on the fastest modern hardware (as of 2017). The procedure
is computationally complex and very time demanding.

\newthought{A simplified approach} to implement global illumination models (and
the rendering equation) is ray tracing. Ray tracing is able to produce high
quality, realistic looking images. Although it is still demanding in terms of
time and computations, the time complexity is viable for producing still
images. For producing images in real time however, the algorithm is still too
demanding. This is where a special form of ray tracing comes in.

\newthought{Sphere tracing} is a ray tracing approach for implicit surfaces
introduced in~\citeyear{hart_sphere_1994} by~\citeauthorfin{hart_sphere_1994} in
his work~\citetitle{hart_sphere_1994}~\cite{hart_sphere_1994}. 
Sphere tracing is faster than the classical ray tracing approaches in its method
of finding
intersections between rays and objects. In contrast to the classical ray tracing
approaches, the~\enquote{marching distance} of rays is not defined by an absolute or a
relative distance, but instead, distance functions are used. The distance functions
are used to expand unbounding volumes (in this concrete case spheres, hence the
name) along rays.~\autoref{fig:sphere-tracing-1} illustrates this procedure.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.75\linewidth]{images/sphere-tracing-principle}
  \caption{Illustration of the sphere tracing
    algorithm.
    Ray~\textit{e} hits no objects until reaching the horizon.
    Rays~\textit{f},~\textit{g} and~\textit{h} hit
    the solid~\textit{poly1}.}
\label{fig:sphere-tracing-1}
\end{figure}

\newthought{Bounding volumes} are defined as the enclosure of a solid. On the
other hand, unbounding volumes are the space outside of a bounding volume,
including the surface of the solid itself. For calculating a unbounding volume,
the distance between an object and any defined origin point is evaluated. If
this distance is known, it can be taken as the radius of a sphere centered at
the origin point.

\newthought{Sphere tracing} defines objects as implicit surfaces using distance
functions. Therefore the distance from every point in space to every other point
in space and to every surface of every object can be calculated. These distances
build a so called distance field.

\newthought{The sphere tracing algorithm} is as follows. A ray is shot
from an origin point (for example, the viewer such as an eye or a pinhole camera) into a scene.
The radius of an unbounding volume in form of a sphere is calculated from
the origin, as described above. The ray intersects with the sphere, which gives
the distance that the ray will travel in a first step. From this
intersection the next unbounding volume (sphere) is expanded and its radius is
calculated, which gives the next intersection of the ray. This procedure
continues until an object is hit or until a predefined maximum distance of
the ray is being reached, defined as the~\enquote{horizon}. An object is
considered as~\enquote{hit} whenever the
returned radius of the distance function is below a predefined constant
$\epsilon$, the~\enquote{convergence precision}.

\newthought{A possible implementation} of the sphere tracing algorithm is shown
in~\autoref{alg:sphere-tracing}, although this shows only the distance
estimation. Shading is done in another implementation, for example in a
render method which calls the sphere trace method. Shading means in this context
the determination of the color of a surface or pixel.

\begin{figure*}
  \begin{pythoncode}
def sphere_trace():
    ray_distance          = 0
    estimated_distance    = 0
    max_distance          = 9001
    max_steps             = 100
    convergence_precision = 0.000001

    while ray_distance < max_distance:
        # sd_sphere is a signed distance function defining the implicit surface.
        # cast_ray defines the ray equation given the current traveled /
        # marched distance of the ray.
        estimated_distance = sd_sphere(cast_ray(ray_distance))

        if estimated_distance < convergence_precision:
            # the estimated distance is already smaller than the desired
            # precision of the convergence, so return the distance the ray has
            # travelled as we have an intersection
            return ray_distance

        ray_distance = ray_distance + estimated_distance

    # When we reach this point, there was no intersection between the ray and a
    # implicit surface, so simply return 0
    return 0
  \end{pythoncode}
  \caption{%
    An abstract implementation of the sphere tracing algorithm. Algorithm in
    pseudo code, after~\cite{hart_sphere_1994}[S. 531, Fig. 1]
  }
\label{alg:sphere-tracing}
\end{figure*}

\newthought{Shading} is done as proposed by~\citeauthorfin{whitted_improved_1980}
in~\citetitle{whitted_improved_1980}~\cite{whitted_improved_1980}. This means,
that the sphere tracing algorithm must return which object was hit and its material.
Depending on the material, four cases can occur. The material may be:
\begin{enumerate*}
  \item reflective and refractive,
  \item reflective only,
  \item diffuse or
  \item emissive.
\end{enumerate*}
For simplicity only the third case is being taken into account. For the actual
shading a local illumination method is used, called~\emph{Phong shading}.

\newpage{}

\newthought{The Phong illumination model}~\cite[p. 123]{foley_computer_1996} describes (reflected) light intensity
$I$ as a composition of the ambient, the diffuse and the perfect specular
reflection of a surface.~\autoref{eq:phong-equation} shows the Phong
illumination model.

\begin{figure}
  \begin{equation}
    I(\vv{V}) = k_{a} \cdot L_{a} + k_{d} \displaystyle\sum_{i=0}^{n - 1} L_{i} \cdot (\vv{S_{i}} \cdot \vv{N}) + k_{s} \displaystyle\sum_{i=0}^{n - 1} L_{i} \cdot {(\vv{R_{i}} \cdot \vv{V})}^{k_{e}}
  \end{equation}
  \caption{%
    The Phong illumination model as defined by Phong Bui-Tuong.~\cite[p. 123]{foley_computer_1996} Note that
    the emissive term was left out intentionally as it is mainly used to achieve
    special effects.
  }
\label{eq:phong-equation}
\end{figure}

\marginnote[20pt]{
% \marginnote{
  \begin{description}
    \item[$I(x, x')$] Intensity of the light at point $\vv{V}$.
    \item[$k_{a}$] A constant defining the ratio of reflection of the ambient
      term of all points in the scene.
    \item[$L_{a}$] Intensity of the ambient light.
    \item[$k_{d}$] A constant defining the ratio of the diffuse term of incoming
      light.
    \item[$\displaystyle\sum_{i=0}^{n-1}$] Sum over all light sources in the scene.
    \item[$L_{i}$] Intensity of the~\emph{i}-th light source.
    \item[$\vv{S_{i}}$] Direction vector from the point on the surface toward
      light source~\emph{i}.
    \item[$\vv{N}$] Normal vector at the point of the surface.
    \item[$\vv{R_{i}}$] Direction that a perfectly reflected ray of light would
      take from this point on the surface.
    \item[$\vv{V}$] Direction pointing toward the viewer.
    \item[$k_{e}$] Shininess constant for the material.
  \end{description}
}% -*- mode: latex; coding: utf-8; outline-minor-mode: t -*-

\chapter{Methodologies}
\label{chap:methodologies}

% Das Kapitel der Methoden erklärt, was (Material) untersucht wurde und wie
% (Methode) ersteres untersucht wurde. Aufgrund der Beschreibung der Methoden muss
% es möglich sein, den Versuch oder die Studie zu wiederholen. Ist die
% Beschreibung der Versuchsanordnung oder des Vorgehens von sehr geringem Umfang,
% können diese nach Rücksprache mit der Betreuungsperson auch als Absatz in der
% Einleitung oder als Unterkapitel zum Kapitel der Einleitung verfasst werden.

% Link to previous
% Make a connection to what has immediately gone before. Recap the last chapter.
% In the last chapter I showed that… Having argued in the previous chapter that…
% As a result of x, which I established in the last chapter….. It is also possible
% to make a link between this chapter and the whole argument… The first step in
% answering my research question (repeat question) .. was to.. . In the last
% chapter I …
\newthought{The previous chapter} provided the fundamentals that are required for
understanding the results of this thesis.

% Focus: What does this chapter specifically do?
% Now focus the reader’s attention on what this chapter is specifically going to
% do and why it is important. In this chapter I will examine.. I will present… I
% will report … This is crucial in (aim of thesis/research question) in order to….
\newthought{This chapter} presents the methodologies that are used to implement
this thesis.

% Overview: How is it done?
% The third paragraph simply outlines the way that you are going to achieve the
% aim spelled out in the previous paragraph. It’s really just a statement of the
% contents in the order that the reader will encounter them. It is important to
% state these not simply as topics, but actually how they build up the internal
% chapter argument… I will begin by examining the definitions of, then move to
% seeing how these were applied… I first of all explain my orientation to the
% research process, positioning myself as a critical scholar.. I then explain the
% methodology that I used in the research, arguing that ethnography was the most
% suitable approach to provide answers to the question of…
\newthought{The first section of this chapter} shows a principle called literate
programming, which is used to generate this documentation and the practical
implementation in terms of a software. The second section describes the agile
methodologies, that are used to implement this thesis.

\section{Literate programming}
\label{sec:literate-programming}

\newthought{Software may be documented in different ways.} It may be in terms of
a documentation, e.g.\ in the form of a software architecture which
describes the software conceptually and hints at its implementation. Or it may
be in terms of documenting within the software itself through inline comments.
Frequently both methodologies are used. However, all too
frequently the documentation is not done properly, and even neglected as it can
be quite costly with seemingly little benefit.

\newthought{Documenting software is critical.} Whenever software is written,
decisions are made. In the moment a decision is made, it may seem intuitively
clear, as it has evolved through creative thought processes. The seeming clarity
of the decision is most of the time deceptive. Is a decision still clear when
some time has passed since making that decision? What were the considerations
that led to it? Is the decision also clear for other, may be less-involved
persons? All these concerns show that documenting software is critical. No
documentation at all, or outdated or irrelevant documentation, can lead to
unforeseen and costly efforts concerning work and time.

\newthought{\citeauthorfin{hoare-hpl-1973} states~\citeyear{hoare-hpl-1973}} in his
work~\citetitle{hoare-hpl-1973} that~\enquote{documentation must be regarded as
an integral part of the process of design and coding}~\cite[p.
195]{hoare-hpl-1973}:~\enquote{The purpose of program documentation is to
explain to a human reader the way in which a program works so that it can be
successfully adapted after it goes into service, to meet the changing
requirements of its users, or to improve it in the light of increased knowledge,
or just to remove latent errors and oversights. The view that documentation is
something that is added to a program after it has been commissioned seems to be
wrong in principle and counter-productive in practice. Instead, documentation
must be regarded as an integral part of the process of design and coding. A good
programming language will encourage and assist the programmer to write clear
self-documenting code, and even perhaps to develop and display a pleasant style
of writing. The readability of programs is immeasurably more important than
their writeability.}~\cite[p. 195]{hoare-hpl-1973}

\newthought{Literate programming}, a paradigm proposed
in~\citeyear{knuth-lp-1984} by~\citeauthorfin{knuth-lp-1984}, goes even further.
\citeauthorfin{knuth-lp-1984} believes that \enquote{significantly better
documentation of programs} can be best achieved~\enquote{by considering programs
to be works of literature}~\cite[p.
1]{knuth-lp-1984}.~\citeauthorfin{knuth-lp-1984} proposes to change
the~\enquote{traditional attitude to the construction of programs}~\cite[p.
1]{knuth-lp-1984}. Instead of imagining that the main task is to instruct a
computer what to do, one should concentrate on explaining to human beings what
the computer shall do.~\cite[p. 1]{knuth-lp-1984}

\newthought{The ideas of literate programming} have been embodied in several
software systems, the first being~\emph{WEB}, introduced
by~\citeauthorfin{knuth-lp-1984} himself. These systems are a combination of two
languages:
\begin{enumerate*}
  \item a document formatting language and
  \item a programming language
\end{enumerate*}.
Such a software system uses a single document as input (which can be split up in
multiple parts) and generates two outputs:
\begin{enumerate*}
  \item a document in a formatting language, such as
    Knuth's~\LaTeX{}~\cite{knuth-tex-1987} (which may then be converted in a
    printable and viewable form, such as PDF) and
  \item a compilable program in a programming language, such as Python or C
    (which may then be converted into an executable program).
\end{enumerate*}~\cite{knuth-lp-1984}
The first process is called~\emph{weaving} and the second~\emph{tangling}. This
process is illustrated in~\cref{fig:weave-and-tangle}.

\begin{figure}
  \begin{tikzpicture}
    \begin{scope}[every node/.style={minimum size=4em,circle,thick,draw}]
      \node (input) at (0,  0) {Input};
      \node (tex)   at (3,  2) {file.tex};
      \node (c)     at (3, -2) {file.c};
      \node (pdf)   at (8,  2) {file.pdf};
      \node (bin)   at (8, -2) {binary};
    \end{scope}
    \begin{scope}[>={Stealth[black]},
      every node/.style={fill=white,circle},
      every edge/.style={draw=black,thick}]
      \path [->] (input) edge[bend left=30] node {weave} (tex);
      \path [->] (input) edge[bend right=30] node {tangle} (c); 
      \path [->] (tex) edge node {convert} (pdf); 
      \path [->] (c) edge node {compile} (bin); 
    \end{scope}
  \end{tikzpicture}
  \caption{Illustration showing the processes of~\emph{weaving}
    and~\emph{tangling} documents from an input document.~\cite{knuth-lp-1984}}
\label{fig:weave-and-tangle}
\end{figure}

\newthought{Several literate programming (LP) systems were evaluated} during the
first phase of this thesis:
CWEB~\sidenote{\url{http://www-cs-faculty.stanford.edu/~uno/cweb.html}},
Noweb~\sidenote{\url{https://www.cs.tufts.edu/~nr/noweb/}},
lit~\sidenote{\url{http://cdosborn.github.io/lit/lit/root.html}},
PyLiterate~\sidenote{\url{https://github.com/bslatkin/pyliterate}},
pyWeb~\sidenote{\url{http://pywebtool.sourceforge.net/}} and
Babel~\sidenote{\url{http://orgmode.org/worg/org-contrib/babel/}}. All of these
tools have their strengths and weaknesses.
However, none of these systems fulfill all the needed requirements of this
project:
\begin{enumerate*}
  \item Provide~\enquote{pretty printing}~\footnotemark[8]{} of the program parts.
  \item Provide automatic references between the definition of program parts and
    their usage.
  \item Expand program parts having the same name instead of redefining them.
  \item Support Python as programming language.
  \item Allow the inclusion of files for both parts, the document formatting
    language and the programming language.
\end{enumerate*}
\footnote{pretty printing refers to content-based formatting (e.g.\ line color
  and indentation to improve readability).}

\newthought{Ultimately a further literate programming system},
nuweb~\footnote{\url{http://nuweb.sourceforge.net/}}, was chosen as it fulfills
all these requirements. It has adapted and simplified the ideas of
FunnelWeb~\footnote{\url{http://www.ross.net/funnelweb/}}. It is independent of
the programming language for the source code. As document formatting language it
uses~\LaTeX{}. Although the documentation of nuweb states that it is not
designed for the pretty printing of source code, it does provide an option to
display source code as listings. This facility has been modified to support
visualizing the expansion of parts as well as to use syntax highlighting of the
code within~\LaTeX{}.

\newthought{The nuweb system provides several commands to process files.} All
commands begin with an at sign (@). Whenever a file or part does not contain
any commands the file is copied unprocessed.\ nuweb provides a single executable
program, which processes the input files and generates the output files (weaving
and tangling, in document formatting language and as source code respectively).

\newthought{A fragment consists of scraps} which in this project contain the
source code. They may also contain for instance paragraphs for formatted text or
mathematical equations.

\newthought{Literate programming can be very expressive} when all concepts are
explicitly defined before implementation.~\citeauthorfin{knuth-lp-1984} sees
this expressiveness an advantage as one is forced to clarify thoughts before
programming~\cite[p. 13]{knuth-lp-1984}. This is surely very true for small
software but only partly true for larger software. The problem with larger
software is, that when using literate programming, the documentation tends to be
correspondingly large. \emph{To overcome this problem} in this project, the
actual implementation of the software is placed into to the appendix,
see appendix~\enquote{\nameref{chap:code-fragments}}.

\newthought{Another problematic aspect} is the implementation of repeating
fragments or parts with similar but not identical technical details (such as imports
or getter and setter methods). This might be interesting only for
software developers or technically oriented readers who want to grasp all the
details.~\emph{This aspect can
be overcome} by moving recurring or uninteresting fragments to a separate
file (see appendix~\enquote{\nameref{chap:code-fragments}}).

\newthought{To show the principles of literate programming}, without annoying
the reader, only an excerpt of some details is given here.

\newthought{One of the more interesting things} of the software might be the
definition of a node and its loading from external files. These two aspects are
shown below. More details of this example would go beyond the scope of this
thesis.

\newthought{Some essential thoughts about classes and objects} may help to stay
consistent when developing the software, before implementing the node class.
Each class should at least have four parts:
\begin{enumerate}
  \item Signals --- to inform other objects about events.
  \item A constructor --- creator of an initial instance of a class.
  \item Various methods --- actions which can be executed by the object.
  \item Slots --- receive signals from other objects.
\end{enumerate}
This structure is applied to the declaration of the node class.

\newpage{}

\newthought{Implementing the class called~\enquote{NodeDefinition}} means simply
defining a scrap called~\enquote{\emph{Node definition declaration}}
using the above structure. The scrap does not have any content at the
moment, except references to other scraps, that build the body of the scrap.
These will be defined later on.~\Cref{scrap1} shows the
scrap.

\begin{figure}[h]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap1}\raggedright\small
\NWtarget{nuweb49}{} $\langle\,${\itshape Node definition declaration}\nobreak\ {\footnotesize {49}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeDefinition(object):
    """Represents a definition of a node.
    """

    # Signals

    |\hbox{$\langle\,${\itshape Node definition constructor}\nobreak\ {\footnotesize \NWlink{nuweb50}{50}}$\,\rangle$}|

    # Methods

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Declaration of the node definition class.}
% \label{lst:node-def-class-decl}
\end{figure}
\phantomsection{}

\newthought{The constructor} might be the first thing to implement. In Python
the constructor defines properties of a class~\sidenote[][-20pt]{Properties do
not need to be defined in the constructor, they may be defined anywhere within
the class. However, this can lead to confusion and it is therefore considered as
good practice to define the properties of a class in its constructor.}. In
context of the program, one might come up with the properties
in~\autoref{table:node-properties} defining a node definition.

\begin{table*}[!htp]\centering
%\begin{table}\centering
  \ra{1.3}
  \begin{tabularx}{\textwidth}{@{}lX@{}}
    \toprule
    \textbf{Property}    & \textbf{Description}                                \\
    \hline
    \textit{ID}          & A global unique identifier.                         \\
    \textit{Name}        & The name of the node, e.g. "Sphere".                \\
    \textit{Description} & A description of the node's purpose.                \\
    \textit{Inputs}      & Parameters given to the node. These may have 
    distinct types, e.g. scalars as floating point numbers or character strings
    of type text, references to other nodes.                                   \\
    \textit{Outputs}     & Values delivered by the node.                       \\
    \textit{Definitions} & A list of the node's definitions. This may be an
    actual definition of a (shader-) function in terms of an implicit surface. \\
    \textit{Invocation}  & The format of a call to the node definition, including
    placeholders which will be replaced by parameters.                         \\
    \textit{Parts}       & Defines text that may be processed when calling the node.
    Contains code which can be interpreted directly.                           \\
    \textit{Nodes}       & The children a node has (child nodes). These entries are
    references to other nodes only.                                            \\
    \textit{Parameters}  & A list of the node's inputs and outputs in form of
    tuples.
    Each tuple is composed of two parts:~\begin{enumerate*}
      \item a reference to another node and
      \item a reference to an input parameter or an output value of that node.
    \end{enumerate*} If the first reference is not set, this means that the
    parameter is internal.                                                     \\
    \bottomrule
  \end{tabularx}
  \caption{Properties/attributes of a node definition.}
\label{table:node-properties}
\end{table*}

\newthought{Implementing the constructor} of the node definition may now follow
from the properties defined
in~\autoref{table:node-properties}.~\Cref{scrap2} shows the
scrap containing the definition of the constructor.

\begin{figure}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap2}\raggedright\small
\NWtarget{nuweb50}{} $\langle\,${\itshape Node definition constructor}\nobreak\ {\footnotesize {50}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, id_):
    """Constructor.

    :param id_: the globally unique identifier of the node.
    :type  id_: uuid.uuid4
    """

    self.id_         = id_

    self.name        = ""
    self.description = ""
    self.parent      = None
    self.inputs      = []
    self.outputs     = []
    self.invocations = []
    self.parts       = []
    self.nodes       = []
    self.connections = []
    self.instances   = []
    self.was_changed = False|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb49}{49}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the node definition class. Note that the
    identifier is given by a corresponding parameter. Identifiers have to be
    generated when defining a node using an external file.}
% \label{lst:node-def-constructor}
\end{figure}

\newthought{One of the problems mentioned before} can be seen
in~\cref{scrap2}: it shows a rather simple constructor without
any useful logic. Additional modules would be needed, e.g.\ Qt bindings for
Python or system modules. At this point the implementation of node definitions
will not be detailed further, as this is beyond the scope of this thesis.

\newthought{The following pages} demonstrate the use of literate programming to
document and manage the code of the loading of node definitions.

\newthought{Node definitions will be loaded from external files} in JSON format.
This happens within the node controller component (not shown here).
The method for loading the nodes,
\mintinline{python}{load_node_definitions}, defined
in~\cref{scrap3}, does not have any arguments. Everything
needed for loading nodes is encapsulated in the node controller.

\begin{figure}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap3}\raggedright\small
\NWtarget{nuweb51a}{} $\langle\,${\itshape Load node definitions}\nobreak\ {\footnotesize {51a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def load_node_definitions(self):
    """Loads all files with the ending NODES_EXTENSION
    within the NODES_PATH directory, relative to
    the current working directory.
    """
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb51a}{51a}\NWlink{nuweb51b}{b}.
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Head of the method that loads node definitions from external JSON
    files. Words written in uppercase are class constants.}
% \label{lst:load-node-definitions}
\end{figure}

\newthought{When loading node definitions}, there are two cases (and
consequences) at the first instance:
\begin{enumerate*}
  \item the directory containing the node definitions exists, so the node
    definitions may be loaded or
  \item the directory does not exit.
\end{enumerate*}
In the first case the directory possibly containing node definitions is being
searched for such files, in the second case a warning message is logged. This is
shown in~\cref{scrap4}.

\begin{figure*}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap4}\raggedright\small
\NWtarget{nuweb51b}{} $\langle\,${\itshape Load node definitions}\nobreak\ {\footnotesize {51b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
if os.path.exists(self.nodes_path):
    |\hbox{$\langle\,${\itshape Find and load node definition files}\nobreak\ {\footnotesize \NWlink{nuweb52a}{52a}, \ldots\ }$\,\rangle$}|
else:
    |\hbox{$\langle\,${\itshape Output warning when directory with node definitions does not exist}\nobreak\ {\footnotesize \NWlink{nuweb54a}{54a}}$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb51a}{51a}\NWlink{nuweb51b}{b}.
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Check whether the path containing the node definition files exist or
    not.}
% \label{lst:nodes-controller-load-nodes-2}
\end{figure*}

\newthought{In the first case}, when the directory containing the node
definitions exists, files containing node definitions are searched. The files
are searched by wildcard pattern matching the extension:~\verb|*.node|. This can
be seen in~\cref{scrap5}.

\newthought{In the second case}, a warning or error message must be generated.
This is detailed at the end of this section.

\begin{figure}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap5}\raggedright\small
\NWtarget{nuweb52a}{} $\langle\,${\itshape Find and load node definition files}\nobreak\ {\footnotesize {52a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
node_definition_files = glob.glob("{path}{sep}*.{ext}".format(
    path=self.nodes_path,
    sep=os.sep,
    ext=self.nodes_extension
))
num_node_definitions = len(node_definition_files)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb52a}{52a}\NWlink{nuweb52b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb51b}{51b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{When the directory containing the node definitions exists, files
    matching the pattern~\emph{*.node} are searched.}
% \label{lst:nodes-controller-find-node-def-files}
\end{figure}

\newthought{Having searched for node definition files}, there are again two
cases, similar as before:
\begin{enumerate*}
  \item files (possibly) containing node definitions exist within the source
    directory, or
  \item no files with the ending \verb|.node| exist.
\end{enumerate*}
Again, as before, in the first case the node definitions will be loaded, in the
second case a warning message will be logged, which is shown in~\cref{scrap6}.

\begin{figure}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap6}\raggedright\small
\NWtarget{nuweb52b}{} $\langle\,${\itshape Find and load node definition files}\nobreak\ {\footnotesize {52b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
if num_node_definitions > 0:
    |\hbox{$\langle\,${\itshape Load found node definitions}\nobreak\ {\footnotesize \NWlink{nuweb52c}{52c}, \ldots\ }$\,\rangle$}|
else:
    |\hbox{$\langle\,${\itshape Output warning when no node definitions are found}\nobreak\ {\footnotesize \NWlink{nuweb54b}{54b}}$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb52a}{52a}\NWlink{nuweb52b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb51b}{51b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{When files containing node definition files are found, they are
    loaded (if possible). When no such files are found, a warning message is
    logged.}
% \label{lst:nodes-controller-find-node-def-files-2}
\end{figure}

\newthought{In the case (1) when node definitions are present}, they are loaded
from the file system, parsed and then stored in an object in memory. To maintain
readability, these text parts (fragments or scraps) are is encapsulated in a
method,~\mintinline{python}{load_node_definition_from_file_name}, which is not
shown here. If the node definition cannot be loaded or parsed a null object
(Python~\mintinline{python}{None}) is being returned. This can be seen
in~\cref{scrap7}.

\begin{figure}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap7}\raggedright\small
\NWtarget{nuweb52c}{} $\langle\,${\itshape Load found node definitions}\nobreak\ {\footnotesize {52c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.logger.info(
    "Found %d node definition(s), loading.",
    num_node_definitions
)
t0 = time.perf_counter()
for file_name in node_definition_files:
    self.logger.debug(
        "Found node definition %s, trying to load",
        file_name
    )
    node_definition = self.load_node_definition_from_file_name(
        file_name
    )|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb52c}{52c}\NWlink{nuweb53}{, 53}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb52b}{52b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Loading and parsing of the node definitions found within the folder
    containing (possibly) node definition files.}
% \label{lst:nodes-controller-load-node-defs}
\end{figure}

\newpage{}

\newthought{When a node definition could be loaded}, a view model based on the
domain model is being created. Both models are then stored internally and a
signal about the loaded node definition is being emitted, to inform other
components which are interested in this event. This process is explained in
detail in the next chapter.

\begin{figure*}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap8}\raggedright\small
\NWtarget{nuweb53}{} $\langle\,${\itshape Load found node definitions}\nobreak\ {\footnotesize {53}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    if node_definition is not None:
        node_definition_view_model = node_view_model.NodeViewModel(
            id_=node_definition.id_,
            domain_object=node_definition
        )
        self.node_definitions[node_definition.id_] = (
            node_definition,
            node_definition_view_model
        )
        |\hbox{$\langle\,${\itshape Node controller load node definition emit}\nobreak\ {\footnotesize \NWlink{nuweb162}{162}}$\,\rangle$}|

t1 = time.perf_counter()
self.logger.info(
    "Loading node definitions took %.10f seconds",
    (t1 - t0)
)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb52c}{52c}\NWlink{nuweb53}{, 53}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb52b}{52b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A view model, based on the domain model, for the node definition is
    being created. Both models are then stored internally and the signal, that a
    node definition was loaded is being emitted.}
% \label{lst:nodes-controller-load-node-defs-2}
\end{figure*}

\newpage{}

\newthought{The implementation of the warnings} is still remaining at this
point. When such an event happens, a corresponding message is logged. The
warnings are:

\begin{enumerate}
  \item the directory holding the node definitions does not exist
\end{enumerate}

\begin{figure*}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap9}\raggedright\small
\NWtarget{nuweb54a}{} $\langle\,${\itshape Output warning when directory with node definitions does not exist}\nobreak\ {\footnotesize {54a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
    message = QtCore.QCoreApplication.translate(
        __class__.__name__,
        "The directory holding the node definitions, %s, does not exist." % self.nodes_path
    )
    self.logger.fatal(message)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb51b}{51b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Output a warning when the path containing the node definition files
    does not exist.}
% \label{lst:nodes-controller-load-node-defs-warning}
\end{figure*}

\tuftebreak{}or

\begin{enumerate}[resume]
  \item no files containing node definitions are found.
\end{enumerate}

\begin{figure*}[!htbp]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap10}\raggedright\small
\NWtarget{nuweb54b}{} $\langle\,${\itshape Output warning when no node definitions are found}\nobreak\ {\footnotesize {54b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
    message = QtCore.QCoreApplication.translate(
        __class__.__name__,
        "No files with node definitions found at %s." % self.nodes_path
    )
    self.logger.fatal(message)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb52b}{52b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Output a warning when no node definitions are being found.}
% \label{lst:nodes-controller-load-node-defs-warning-2}
\end{figure*}

\section{Agile software development}
\label{sec:agile-software-development}

\newthought{Software engineering always invokes a methodology,} be it wittingly
or unwittingly. For a (very) small project the methodology may follow intuitively,
by experience and it may be a mixture of methodologies. For medium to large
projects however, using certain methodologies or principles is necessary to
ensure (the success of) a project.

\newthought{Every commonly used software engineering methodology} has advantages
but buries also certain risks. Be it a traditional method like the waterfall
model, incremental development, the v-model, the spiral model or a more recent
method like agile development. It depends largely on the project what
methodology fits best and buries the least risks.~\cite{haneen-risk-2012,
mens-se-2008}

\newthought{Examples of risks of software development}~\cite{beck-xp-2004} are:
incomplete and misunderstood needs, delays and schedule slippage, increased
error rate, new changes requested, superfluity of features,
etc.~\cite{beck-xp-2004}

\newthought{Traditional software engineering methodologies}, such as the
waterfall model or incremental development, struggle with the management of change. In case of the
waterfall model changes are deprecated or lead to followup projects. In the case of incremental
development, the phases can be very long, which allows only slow reaction to
change requests.~\autoref{fig:waterfall} and~\autoref{fig:iterative-dev}
illustrate these methodologies.

\begin{figure*}[!htbp]
  \includegraphics[width=0.95\linewidth]{images/waterfall}
  \caption{Phases of the water fall methodology.~\cite[p. 16]{shore-aad-2007}}
\label{fig:waterfall}
\end{figure*}

\begin{figure*}[ht]
  \includegraphics[width=0.95\linewidth]{images/iterative-dev}
  \caption{Phases of iterative development.~\cite[p. 16]{shore-aad-2007}}
\label{fig:iterative-dev}
\end{figure*}

\newthought{By applying some alternative basic principles}, agile development
methodologies try
to overcome these problems. These principles may vary depending on the used
methodology, but the fundamental ones are:
\begin{enumerate*}
  \item rapid feedback,
  \item minimize complexity,
  \item incremental change,
  \item no fear of changes and
  \item high quality work.
\end{enumerate*}~\cite{beck-xp-2004}
Further details can be found at~\cite{beck-xp-2004, shore-aad-2007}.

\newthought{An adapted version of extreme programming} is used for this thesis.
This methodology was chosen as at the end of the work of the previous project
(\enquote{QDE --- a visual animation system,
architecture}~\cite{osterwalder-qde-2016}), some needs were still continuously
changing or even not yet well-defined. An exact planning, analysis and design,
as traditional methodologies require it, would not be very practical. The
following~\autoref{fig:xp} illustrates the use of an agile methodology.

\begin{figure*}[!htbp]
  \includegraphics[width=0.95\linewidth]{images/xp}
  \caption{Iterations in the extreme programming methodology and phases of an
    interation.~\cite[p. 18]{shore-aad-2007}}
\label{fig:xp}
\end{figure*}
% -*- mode: latex; coding: utf-8 -*-

\chapter{Implementation}
\label{chap:implementation}

% Gestützt auf Quellen, Messungen und Datenerhebungen werden die anhand der
% Fragestellung gewon- nenen Ergebnisse präsentiert [3, p. 116]. Während das
% Kapitel zu Material und Methoden ( 3.2.3) oder das entsprechende Unterkapitel
% der Einleitung die Versuchsanordnung beschreibt, werden im Kapitel Ergebnisse
% der Versuchsablauf mit den Resultaten objektiv wiedergegeben. Alle Überlegungen,
% Berechnungen oder Experimente des Berichts müssen vollständig nachvollziehbar
% sein [3, p. 26]. Zusammen mit der Diskussion und den Folgerungen machen die
% Ergebnisse qualitativ und quantitativ den Hauptteil des Berichts aus [3, p. 26].

% Link to previous
% Make a connection to what has immediately gone before. Recap the last chapter.
% In the last chapter I showed that… Having argued in the previous chapter that…
% As a result of x, which I established in the last chapter….. It is also possible
% to make a link between this chapter and the whole argument… The first step in
% answering my research question (repeat question) .. was to.. . In the last
% chapter I …
\newthought{The previous chapter} introduced the methodologies that are required
for understanding the results of this thesis.

% Focus: What does this chapter specifically do?
% Now focus the reader’s attention on what this chapter is specifically going to
% do and why it is important. In this chapter I will examine.. I will present… I
% will report … This is crucial in (aim of thesis/research question) in order to….
\newthought{This chapter} contours three sections. The first section shows the
software architecture that was developed and that is used for the program
implemented. Aspects of the literate form of this program implemented are shown
in the second section. The main concepts and the components of the program are
shown in the third section.

% Overview: How is it done?
% The third paragraph simply outlines the way that you are going to achieve the
% aim spelled out in the previous paragraph. It’s really just a statement of the
% contents in the order that the reader will encounter them. It is important to
% state these not simply as topics, but actually how they build up the internal
% chapter argument… I will begin by examining the definitions of, then move to
% seeing how these were applied… I first of all explain my orientation to the
% research process, positioning myself as a critical scholar.. I then explain the
% methodology that I used in the research, arguing that ethnography was the most
% suitable approach to provide answers to the question of…
% * Software architecture
% ** Reference to actual chapter
% ** Layers
% ** Signals
%
% * Literate programming
% ** Just mention, reference to actual chapter
%
% * Software
% ** Editor
% ** Player
% ** Components
%
% Nope, merged this already with focus.

% Input CF
% Resultate weniger kritisch, erst in Diskussion, überlappt sich aber.

\section{Software architecture}
\label{results:sec:software-architecture}

\newthought{The software architecture} defines the significant decisions of the
program implemented, such as the selection of structural elements, their
behavior and their interfaces.~\cite{kruchten_rup_2003} The architecture is
derived from the experiences based on the former projects,~\enquote{Volume ray
casting --- basics \& principles}~\cite{osterwalder-volume-2016}
and~\enquote{QDE --- a visual animation system,
architecture}~\cite{osterwalder-qde-2016}, which build the fundamentals of this
thesis, see~\autoref{chap:fundamentals}~\enquote{\nameref{chap:fundamentals}}.

\newthought{Three aspects} define the software architecture:
\begin{enumerate}
  \item an architectural software design pattern,
  \item layers and
  \item signals and slots, which allow communication between components.
\end{enumerate}

\subsection{Software design}
\label{results:subsec:software-design}

\newthought{A [software] design pattern}~\enquote{names, abstracts, and
identifies the key aspects of a common design structure that make it useful for
creating a reusable object-oriented design. The design pattern identifies the
participating classes and instances, their roles and collaborations, and the
distribution of responsibilities. Each design pattern focuses on a particular
object-oriented design problem or issue.}~\cite[p. 16]{gamma-dpe-1995}

\newthought{To separate data from its representation} and to ensure a coherent
design, a combination of the model-view-controller (MVC)~\cite{krasner-mvc-1988}
and the model-view-view model pattern (MVVM)~\cite{fowler-presentation-2004,
gossman-mvvm-2005} is used as architectural software design pattern. This
decision is based on experiences from the previous projects and allows
individual parts to be modified and reused. This is especially necessary as the
data created in the editor component will be reused by the player component.

\newthought{Four kinds of components} build the basis of the pattern
used.~\Cref{table:software-design-pattern-components} provides a description of
the components.~\Cref{fig:software-design-pattern-components-editor} shows an
overview of the components of the editor (the colored items) including their
communication in an informal way. Additionally the user as well as the display
is shown (in gray color). As the player component only plays animations, no view
models are needed and therefore only the MVC pattern is used, which is shown
in~\cref{fig:software-design-pattern-components-player}.

\begin{table*}[h]
  \begin{tabularx}{\textwidth}{llX}
    \toprule
    \textbf{Component} & \textbf{Description} & \textbf{Examples} \\
    \midrule
    Model      & Represents the data or the business logic, & Scene, Node
                                                              Parameter\\
               & completely independent from the user       & \\
               & interface. It stores the state and does    & \\
               & the processing of the problem domain.      & \\
    \midrule
    View       & Consists of the visual elements.           & Scene tree view,
                                                              Scene view\\
    \midrule
    View model & \enquote{Model of a view}, the abstraction & Scene tree view
                                                              model, Scene\\
               & of the view, provides a specialization of  & view model, Node
                                                              view model\\
               & the model which the view can use for       & \\
               & data-binding. It also stores the state and & \\
               & may provide complex operations.            & \\
    \midrule
    Controller & Holds the data in terms of models.         & Scene tree
                                                              controller, scene
                                                              controller,\\
               & models. Acts as an interface between the   & node controller\\
               & components.                                & \\
    \bottomrule
  \end{tabularx}
  \caption{Description of the types of components of the software design
    pattern used.~\cite{fowler-presentation-2004, gossman-mvvm-2005}}
\label{table:software-design-pattern-components}
\end{table*}

\vspace{5mm}
  
\begin{figure*}[!htbp]
  \includegraphics[width=0.8\linewidth]{images/mvvmc}
  \caption{Components of the used pattern for the editor and their
    communication.}
\label{fig:software-design-pattern-components-editor}
\end{figure*}

\begin{figure*}[!htbp]
  \includegraphics[width=0.8\linewidth]{images/mvvmc-player}
  \caption{Components of the used pattern for the player and their
    communication.}
\label{fig:software-design-pattern-components-player}
\end{figure*}

\newthought{The Qt framework} which is used, offers a very similar pattern
called~\enquote{model/view pattern}. It combines the view and the controller
into a single object. The pattern introduces a delegate between view and model,
similar to a view model. The delegate allows editing the model and communicates
with the view. The communication is done by so called model indexes, which are
references to items of data.~\cite{qt-mvp-2017}~\enquote{By supplying model
indexes to the model, the view can retrieve items of data from the data source.
In standard views, a delegate renders the items of data. When an item is edited,
the delegate communicates with the model directly using model
indexes.}~\cite{qt-mvp-2017} \Cref{fig:software-design-pattern-qt-mvp} shows
this model/view pattern.

\begin{figure}[ht]
  \includegraphics[width=0.6\linewidth]{images/model-view-pattern}
  \caption{Qt's model/view pattern.~\cite{qt-mvp-2017}}
\label{fig:software-design-pattern-qt-mvp}
\end{figure}

\newthought{Although offering advantages}, such as to customize the presentation
of items or the usage of a wide range of data sources, the model/view pattern was
not used in this project. This is mainly due to two reasons:
\begin{enumerate*}
  \item the developed and intended components use no data source other than external
    files and
  \item the concept of using model indexes may add flexibility but also
    introduces overhead.
\end{enumerate*}

\newthought{The scene tree component} of the editor was developed using the Qt
class for the abstract item model, which uses the model/view pattern. This
showed that the usage of this pattern introduces unnecessary overhead and
requires more effort to implement, while not using the advantages of features of
the pattern. Therefore a decision was taken against the usage of the pattern in
this case.

\subsection{Layers}
\label{results:subsec:layers}

\newthought{To reduce coupling and dependencies} a relaxed layered architecture
is used, as written
in~\autoref{results:sec:software-architecture}~\enquote{\nameref{results:sec:software-architecture}}.
In contrast to a strict layered architecture, which allows any layer to call
only services or interfaces from the layer below, the relaxed layered
architecture allows higher layers to communicate with any lower
layer.~\Cref{table:results:layers} provides a graphical overview as well as a
description of the layers. The colors have no significance except to distinguish
the layers visually for the reader.

\begin{table*}[h]
  \begin{tabularx}{\textwidth}{XXX}
    \toprule
    \textbf{Layer} & \textbf{Description} & \textbf{Examples} \\
    \midrule
    \includegraphics[width=1.0\linewidth]{images/layers-gui}         & All elements of the graphical user interface, views.                                & Scene tree view, scene view, render view                                   \\
    \includegraphics[width=1.0\linewidth]{images/layers-gui-domain}  & View models.                                                                        & Scene tree view model, node view model                                     \\
    \includegraphics[width=1.0\linewidth]{images/layers-application} & Controller (workflow objects).                                                      & Main application, scene tree controller, scene controller, node controller \\
    \includegraphics[width=1.0\linewidth]{images/layers-domain}      & Data models according to the logic of the application.                              & Scene model, parameter model, node definition model, node domain model     \\
    \includegraphics[width=1.0\linewidth]{images/layers-technical}   & Technical infrastructure, such as graphics, window creation and so on.              & JSON parser, camera, culling, graphics, renderer                           \\
    \includegraphics[width=1.0\linewidth]{images/layers-foundation}  & Basic elements and low level services, such as timer, arrays or other data classes. & Colors, common, constants, flags                                           \\
    \bottomrule
  \end{tabularx}
  \vspace*{\baselineskip}
  \caption{Layers of the program implemented.}
\label{table:results:layers}
\end{table*}

\subsection{Coupling and cohesion, signals and slots}
\label{results:subsec:signals}

\newthought{Whenever designing and developing} software, coupling and cohesion
can occur and may pose a problem if not considered early and well enough.

\newthought{Coupling} measures how strongly a component is connected to other
components, or has knowledge of them or depends on them. High coupling impedes
the readability and maintainability of software, so programmers should strive
towards low coupling. \citeauthorfin{larman-applying-2004} states that the
principle of low coupling applies to many dimensions of software development and
that it is a major objective in building software.~\cite{larman-applying-2004}

\newthought{Cohesion} is a measurement of~\enquote{how functionally related the
operations of a software element are, and also measures how much work a software
element is doing}.~\cite{larman-applying-2004} Or put otherwise, it
is~\enquote{a measure of the strength of association of the elements within a
module}.~\cite[p. 52]{ieee-swebok-2014} Low (or poor) cohesion does not imply
that a component works only by itself, indeed it probably collaborates with many
other objects. But low cohesion tends to create high (poor) coupling. It is
therefore desirable to keep objects focused, understandable and manageable while
supporting low coupling.~\cite{larman-applying-2004}

\newthought{To overcome the problems} of high coupling and low
cohesion,~\emph{signals and slots} are used. Signals and slots are a generalized
implementation of the observer pattern, which can be seen informally
in~\cref{fig:signals-observer-pattern}
and~\cref{fig:signal-and-slot-relationship}.

\begin{figure}[!htbp]
  \includegraphics[width=0.8\linewidth]{images/observer-pattern}
  \caption{The observer pattern.~\cite{gamma-dpe-1995}}
\label{fig:signals-observer-pattern}
\end{figure}

\newthought{A signal is an observable event.} A slot is a potential observer,
typically a method of an object. An example of an observer is given
in~\cref{lst:signal-slot:observer-slot}.

\begin{figure}[!htbp]
  \begin{pythoncode}
class Observer:

    @slot(type)
    def on_signal(self, parameter):
        """Listens on the signal 'signal'. Expects the
        signal to send the parameter 'parameter' of
        type 'type'."""

        ...
  \end{pythoncode}
  \caption{An example of a class called~\enquote{Observer} with a slot
    called~\enquote{on\_signal}. The slot expects the signal to send a parameter
    of type~\enquote{type}.
  }
\label{lst:signal-slot:observer-slot}
\end{figure}

\newthought{Slots are registered as observers} to signals as shown
in~\cref{lst:signal-slot:connect}.

\begin{figure}[!htbp]
  \begin{pythoncode}
subject.signal.connect(
    observer.on_signal
)
  \end{pythoncode}
  \caption{The~\enquote{on\_signal} slot (which is a method of the
    object~\enquote{observer}) is registered to the signal~\enquote{signal} of
    the object~\enquote{subject}.}
\label{lst:signal-slot:connect}
\end{figure}

\newthought{Whenever a signal is emitted}, the emitting class must call all the
registered observers for that signal as shown in~\cref{lst:signal-slot:emit}.

\begin{figure}[!htbp]
  \begin{pythoncode}
subject.signal.emit(some_parameter)
  \end{pythoncode}
  \caption{The signal~\enquote{signal} of the object~\enquote{subject} is
    emitted. The signal contains a parameter called~\enquote{some\_parameter}.
    This means that the emitting class,~\enquote{Signal}, will call the
    registered method~\enquote{on\_signal} of the observer
    called~\enquote{observer}.}
\label{lst:signal-slot:emit}
\end{figure}

\newthought{The relationship between signals and slots} is a many-to-many
relationship. One signal may be connected to any number of slots and a slot may
listen to any number of signals. A relationship between a signal and a slot is
shown in~\cref{fig:signal-and-slot-relationship}

\begin{figure}[!htbp]
  \includegraphics[width=0.8\linewidth]{images/signal-and-slot}
  \caption{An observer is listening to a signal sent by a subject. The subject
    emits the signal and calls then the observers that are registered for that
    signal (or the registered slots of the observers respectively).}
\label{fig:signal-and-slot-relationship}
\end{figure}

\newthought{Signals can carry additional information}, such as single values or
even references to objects. A simple example of a signal-slot relationship is
loading node definitions from files. The node controller, when it loads node
definitions, could emit two signals to inform other components. For example,
signal 1
\begin{enumerate*}
  \item gives the number of node definitions to load, and signal
  \item the index of the last loaded node definition and a reference to it.
\end{enumerate*}
This information could for example be used in a dialog showing the progress of
loading from the file system.

\begin{figure}[!htbp]
  \begin{pythoncode}
self.total_node_definitions.emit(num_node_definitions)
  \end{pythoncode}
  \caption{%
    An example of emitting a signal including a value.
  }
\label{lst:signal-slot-example-1}
\end{figure}

\begin{figure*}[!htbp]
  \begin{pythoncode}
for index, definition_file in enumerate(node_definition_files):
    node_definition = self.load_node_definition_from_file(
        definition_file
    )
    self.node_definition_loaded(index, node_definition)
  \end{pythoncode}
  \caption{%
    An example of emitting a signal including a value and a reference to an
    object.
  }
\label{lst:signal-slot-example-2}
\end{figure*}

\section{Literate programming}
\label{results:sec:literate-programming}

\newthought{Documentation is crucial to the maintenance or modification} of any
software project. However, all too frequently the documentation is not done
properly or is even neglected because of seemingly low benefit related to
effort. No documentation at all, outdated or irrelevant documentation can cause
unforeseen cost and time overruns. Using the literate programming paradigm
prevents these problems, as the software as well as the documentation are
derived from a literate program. For this thesis the LP system nuweb was used,
as described
under~\autoref{sec:literate-programming}~\enquote{\nameref{sec:literate-programming}}.

\newthought{Using literate programming to develop software} requires a different
way of thinking from traditional methodologies. The approach is completely
different. Traditional methodologies focus on instructing the computer what to
do by writing program code. Literate programming focuses on explaining to human
beings what the computer shall do by combining the documentation with code in a
single document. From this single document a program which can be compiled or
run directly is extracted. The order of the code fragments matters only
indirectly, they may appear in any order throughout the text. The code fragments
are put into the right order for compilation or running by defining the output
files containing the needed code fragments in the right order.

\newthought{The need to include every detail} makes literate programming very
expressive and verbose. While this expressiveness may be an advantage for small
software and partly also for larger software, it can also be a problem,
especially for larger software: the documentation becomes lengthy and hard to
read, especially when including the full implementation of technical details.

\newthought{These problems} in the writing of this thesis were overcome by
moving the implementation into the appendix,
see~\autoref{part:appendix}~\enquote{\nameref{part:appendix}} and by outsourcing
technical parts into a separate file,
see~\autoref{chap:code-fragments}~\enquote{\nameref{chap:code-fragments}}.

\section{Program}
\label{results:sec:program}

\newthought{To recall}, the objective of this thesis is the design and
development of a program for modeling, composing and rendering real-time
computer graphics by providing a graphical toolbox.

\newthought{Using the introduced methodologies}
(see~\autoref{chap:methodologies}~\enquote{\nameref{chap:methodologies}}) and
the developed software architecture
(see~\autoref{results:sec:software-architecture}~\enquote{\nameref{results:sec:software-architecture}})
a program was implemented.

\newthought{The program implemented} should to have two main components:
the~\textit{editor} and~\textit{player}.

\newthought{The editor component} provides a graphical system for modeling,
composing and rendering of scenes. It allows composing scenes into an animation
and saving the animation in an external file. Rendering is done using the shown
sphere tracing algorithm combined with Phong shading.

\newthought{The player component} simply plays an animation which has been
created with the editor component. This includes loading and rendering of all
scenes.

\newthought{Due to time constraints}, however, only the editor component was
implemented.~\autoref{fig:editor} shows an image of the program implemented.

\newthought{For the implementation} the following tools were used: the Python
programming language~\protect\footnote{version 3.5.2,
\url{http://www.python.org}}, the Qt cross-platform application development
framework~\protect\footnote{version 5.7, \url{https://www.qt.io/}}, the PyQt5
bindings~\protect\footnote{version 5.7,
\url{https://riverbankcomputing.com/software/pyqt/intro}} for Qt and
OpenGL~\protect\footnote{version 3.3, \url{https://www.opengl.org/}}.

\vspace{10mm}

\begin{figure}[!htbp]
  \includegraphics[width=0.95\linewidth]{images/editor}
  \caption{The implemented editor component.}
\label{fig:editor}
\end{figure}

\newthought{The quintessence of both components} is to output respectively to
read a data structure in the JSON~\cite{ecma-json-2013} format which defines an
animation. This data structure provides an animation which contains scenes,
which contain nodes. This data structure is evaluated and the result is
shader-specific code which is executed by the graphical processing unit (GPU)
and seen by the viewer.

\newthought{An animation} is simply a composition of scenes which run in a
sequential order within a defined time span.

\newthought{A scene} is a composition of nodes stored in the form of a directed
graph.

\newthought{Nodes} are instances of node definitions and define the content of a
scene and therefore of an animation.

\newthought{Node definitions} provide content in a specific structure, shown
in~\autoref{table:node-definition-components}.

\begin{table}[!htbp]\centering
  \ra{1.3}
  \begin{tabularx}{\textwidth}{@{}lX@{}}
    \toprule
    \textbf{Property}    & \textbf{Description}                                \\
    \hline
    \textit{ID}          & A global unique identifier.                         \\
    \textit{Name}        & The name of the node, e.g. "Sphere".                \\
    \textit{Description} & A description of the node's purpose.                \\
    \textit{Inputs}      & Parameters given to the node. These may have 
    distinct types, e.g. scalars as floating point numbers or character strings
    of type text, references to other nodes.                                   \\
    \textit{Outputs}     & Values delivered by the node.                       \\
    \textit{Definitions} & A list of the node's definitions. This may be an
    actual definition of a (shader-) function in terms of an implicit surface. \\
    \textit{Invocation}  & The format of a call to the node definition, including
    placeholders which will be replaced by parameters.                         \\
    \textit{Parts}       & Defines text that may be processed when calling the node.
    Contains code which can be interpreted directly.                           \\
    \textit{Nodes}       & The children a node has (child nodes). These entries are
    references to other nodes only.                                            \\
    \textit{Parameters}  & A list of the node's inputs and outputs in form of
    tuples.
    Each tuple is composed of two parts:~\begin{enumerate*}
      \item a reference to another node and
      \item a reference to an input parameter or an output value of that node.
    \end{enumerate*} If the first reference is not set, this means that the
    parameter is internal.                                                     \\
    \bottomrule
  \end{tabularx}
  \caption{Properties/attributes of a node definition.}
\label{table:node-definition-components}
\end{table}

\newthought{Content} is whatever a node definition provides in terms of the
definitions but the output has always to be an atomic type as defined
in~\cref{table:node-definition-atomic-types}.

\begin{table}[!htbp]\centering
  \ra{1.3}
  \begin{tabularx}{\textwidth}{@{}lX@{}}
    \toprule
    \textbf{Atomic type} & \textbf{Description}                       \\
    \midrule
    \textit{Generic}     & A global unique identifier.                \\
    \textit{Float}       & A floating point value.                    \\
    \textit{Text}        & Characters as text string.                 \\
    \textit{Scene}       & Used for nesting scenes.                   \\
    \textit{Image}       & An image, typically a texture.             \\
    \textit{Dynamic}     & Dynamic values, e.g.\ time or sine values. \\
    \textit{Mesh}        & Triangle based meshes.                     \\
    \textit{Implicit}    & Implicit objects.                          \\
    \bottomrule
  \end{tabularx}
  \caption{Atomic types, that define a node (definition).}
\label{table:node-definition-atomic-types}
\end{table}

\newthought{An example} of an node definition of type~\emph{implicit} for
rendering a sphere is given
in~\autoref{results:subsec:program:node-graph}~\enquote{\nameref{results:subsec:program:node-graph}}.

\newthought{Subsequent each component of the editor} is shown in a component
diagram in adapted form~\cite[pp. 653 -- 654]{larman-applying-2004} and an
entity relationship diagram~\cite[pp. 501 ff.]{larman-applying-2004} (if
appropriate), followed by a description of the component. The component diagram
is used to show the signals that a component emits and receives. The entity
relationship diagram is used to show the relationships between components. Only
the relations immediately related to the presented component are shown, because
the diagrams would otherwise be too crowded and confusing.

\newthought{To preserve clarity} all components are described in discrete
sections of this chapter. Although the implementation of the components is very
specific, in terms of the programming language, their logic may be reused later
for the player component.

\newpage{}

\subsection{Editor}
\label{results:subsec:program:editor}

\begin{figure*}[!htbp]
  \includegraphics[width=0.55\linewidth]{images/editor-component-diagram}
  \caption{Component diagram of the editor component.}
\label{fig:editor-component-diagram}
\end{figure*}

\begin{figure}[!htbp]
  \includegraphics[width=0.75\linewidth]{images/editor-erd}
  \caption{Entity relationship diagram of the editor component.}
\label{fig:editor-erd}
\end{figure}

\newthought{The editor component} is the main component, which acts as entry
point for the application and ties all components together.
The~\verb=Application= class sets up all the controllers and the main window.
The~\verb=MainWindow= class sets up all the view-related components, therefore
the scene tree view, the scene view and the renderer.

\subsection{Scene tree}
\label{results:subsec:program:scene-tree}

\begin{figure*}[!htbp]
  \caption{Component diagram of the scene tree component.}
\label{fig:scene-graph-component-diagram}
  \includegraphics[width=0.5\linewidth]{images/scene-graph-component-diagram}
\end{figure*}

\begin{figure}[!htbp]
  \caption{Entity relationship diagram of the scene tree component.}
\label{fig:scene-graph-erd}
  \includegraphics[width=0.5\linewidth]{images/scene-graph-erd}
\end{figure}

\newthought{The scene tree component} enables the scenes of the animation to be
managed. User interaction is provided through a tree-like view, which lets the
user add, remove and select scenes.

\subsection{Node graph}
\label{results:subsec:program:node-graph}

\begin{figure*}[!htbp]
  \caption{Component diagram of the node graph component.}
\label{fig:node-graph-component-diagram}
  \includegraphics[width=0.5\linewidth]{images/node-graph-component-diagram}
\end{figure*}

\begin{figure}[!htbp]
  \caption{Entity relationship diagram of the node graph component.}
\label{fig:node-graph-erd}
  \includegraphics[width=0.5\linewidth]{images/node-graph-erd}
\end{figure}

\newthought{The node graph component} enables the nodes of a scene to be
managed. The nodes of a scene define its content.

\newthought{Each node has parameters} which define the properties of a node.
Such a parameter is for example the radius of a sphere for a node providing a
sphere of type implicit.

\newthought{Nodes have multiple inputs and one output} where each is of a
specific type, as described in~\cref{table:node-definition-atomic-types}. Inputs
point to parameters of a node whereas outputs provide values. An output of a
node may be connected to the input of another node. Every scene has a fixed
input by default which is currently limited to implicit types (outputs) and acts
as output of the scene.

\newthought{The~\emph{content} of a node} is depending on the type of the
node. The basis of the content is built by three things however:
\begin{enumerate*}
  \item its~\emph{definition},
  \item its~\emph{invocation} and
  \item its so called~\emph{part}.
\end{enumerate*}

\newthought{A definition of a node} is essentially a method written in OpenGL
Shading Language which defines the function of the
node.~\cref{fig:node-definition-example} shows an example of such a definition.
It defines an implicit sphere with a certain radius at a certain position.

\begin{figure}[!htbp]
  \begin{minted}[%
    bgcolor=LightGray,
    escapeinside=||,
    linenos=true,
    mathescape=true,
    tabsize=4]{js}
{
    "id_": "99d20a26-f233-4310-adb2-5e540726d079",
    "script": [
        "// Returns the signed distance to a sphere with",
        "//given radius for the given position.",
        "float sphere(vec3 position, float radius)",
        "{",
        "    return length(position) - radius;",
        "}"
    ]
}
  \end{minted}
\caption{Implementation of an implicit sphere in the OpenGL Shading Language
  (GLSL) as definition in JSON format.}
\label{fig:node-definition-example}
\end{figure}

\newpage{}

\newthought{The~\emph{invocation} of a node} is the call to a method defined by
the definition of a node. Invocations are also written in the OpenGL Shading
Language.~\cref{fig:node-invocation-example} shows an example of a invocation.

\begin{figure}[!htbp]
  \begin{minted}[%
    bgcolor=LightGray,
    escapeinside=||,
    linenos=true,
    mathescape=true,
    tabsize=4]{js}
{
    "id_": "4cd369d2-c245-49d8-9388-6b9387af8376",
    "type": "implicit",
    "script": [
        "float s = sphere(",
        "  16d90b34-a728-4caa-b07d-a3244ecc87e3-position,",
        "  5c6a538-1dbc-4add-a15d-ddc4a5e553da",
        ");"
    ]
}
  \end{minted}
\caption{Calling of the previously defined GLSL function of an implicit sphere
  as invocation in JSON format.}
\label{fig:node-invocation-example}
\end{figure}

\newthought{A~\emph{part} of a node} defines what happens when a node is
evaluated. This means usually evaluating the inputs of the node and use them as
parameters.~\cref{fig:node-invocation-example} shows an example of a part.

\begin{figure*}[!htbp]
  \begin{minted}[%
    bgcolor=LightGray,
    escapeinside=||,
    linenos=true,
    mathescape=true,
    tabsize=4]{js}
{
    "id_": "74b73ce7-8c9d-4202-a533-c77aba9035a6",
    "name": "Implicit sphere node function",
    "type_": "implicit",
    "script": [
      "# -*- coding: utf-8 -*-",
      "",
      "from PyQt5 import QtGui",
      "",
      "",
      "class Class_ImplicitSphere(object):",
      "    def __init__(self):",
      "        self.position = QtGui.QVector3D()",
      "",
      "    def process(self, context, inputs):",
      "      shader = context.current_shader.program",
      "      ",
      "      radius = inputs[0].process(context).value",
      "      shader_radius_location = shader.uniformLocation(",
      "          \"f5c6a538-1dbc-4add-a15d-ddc4a5e553da\"",
      "      )",
      "      shader.setUniformValue(",
      "          shader_radius_location, radius",
      "      )",
      "      ",
      "      position = self.position",
      "      shader_position_location = shader.uniformLocation(",
      "          \"16d90b34-a728-4caa-b07d-a3244ecc87e3-position\"",
      "      )",
      "      shader.setUniformValue(",
      "          shader_position_location,",
      "          position",
      "      )",
      "      ",
      "      return context"
    ]
}
  \end{minted}
\caption{The~\emph{part} of the node providing an implicit sphere in JSON
  format. Here the node node has two parameters: a radius and a position. The
  value for the radius is derived from the first input of the node, the position
  is a fixed vector. As the node is of type implicit it will be executed by a
  shader on the graphics processing unit.}
\label{fig:node-part-example}
\end{figure*}

\newpage{}

\newthought{Evaluation of nodes} is done in two ways, the node is
\begin{enumerate*}
  \item directly selected or
  \item connected to a scene (either through another node or
    through the scene's input) and that scene is evaluated.
\end{enumerate*}

\newthought{Nodes are derived from} node definitions. The workflow object of the
component, the~\verb=NodeController= class, reads node definitions from the file
system. A dialog window allows to add the read node definitions as instances to
a scene. When a node is selected it is rendered by the renderer component.

\subsection{Rendering}
\label{results:subsec:program:rendering}

\begin{figure}[!htbp]
  \caption{Entity relationship diagram of the renderer component.}
\label{fig:renderer-erd}
  \includegraphics[width=0.95\linewidth]{images/renderer-erd}
\end{figure}

\newthought{The rendering component} renders nodes and scenes. Nodes are
rendered according to their type whereby only nodes of type implicit are
currently supported. For rendering scenes the fixed input is evaluated
recursively.

\newthought{OpenGL is used for rendering}. Due to the usage of~\enquote{modern}
OpenGL, everything that is rendered is rendered through a shader defined in the
OpenGL Shading Language (GLSL).

\newthought{As algorithm for rendering} the sphere tracing algorithm is used as
described in~\autoref{sec:rendering}~\enquote{\nameref{sec:rendering}}
and shown in~\cref{fig:sphere-tracing-implementation}.

\begin{figure}[!htbp]
  \begin{minted}[%
    bgcolor=LightGray,
    linenos=true,
    mathescape=true,
    tabsize=4]{glsl}
// Casts a ray from given origin in given direction. Stops
// at given maximal distance and after the given amount of
// steps. Maintains given precision.
vec3 castRay(in vec3 rayOrigin, in vec3 rayDirection,
             in float maxDistance,
             in float precision, in int steps)
{
    float latest          = precision * 2.0;
    float currentDistance = 0.0;
    float result          = -1.0;
    vec3  ray             = vec3(0);

    for(int i = 0; i < steps; i++) {
        if (abs(latest)     < precision ||
            currentDistance > maxDistance) {
                continue;
        }

        ray = rayOrigin + rayDirection * currentDistance;
        latest = scene1(ray);
        currentDistance += latest;
    }

    if (currentDistance < maxDistance) {
        result = currentDistance;
    }

    return result;
}
  \end{minted}
\caption{The sphere tracing algorithm as implemented.}
\label{fig:sphere-tracing-implementation}
\end{figure}

\newpage{}

\newthought{For the shading} of objects Phong shading is used as
described in~\autoref{sec:rendering}~\enquote{\nameref{sec:rendering}}
and shown in~\cref{fig:phong-shading-implementation}.

\begin{figure*}
  \begin{minted}[%
    bgcolor=LightGray,
    linenos=true,
    mathescape=true,
    tabsize=4]{glsl}
// Calculates the lighting for the given position, normal and direction,
// the given light (position and color) respecting the 'material'.
//
// This is mainly applying the phong lighting model.
//
// Returns the calculated color as three-dimensional vector.
vec3 calcLighting(in vec3 position, in vec3 normal, in vec3 rayDirection,
                  in vec3 material, in vec3 lightPosition, in vec3 lightColor,
                  in float currentDistance)
{
    vec3 color             = material;

    vec3 lightDirection    = normalize(lightPosition);
    vec3 reflection        = reflect(rayDirection, normal);

    vec3  directColor      = vec3(1.0, 1.0, 1.0);
    float kDirectLight     = 0.1;
    vec3  direct           = kDirectLight * directColor;

    vec3  ambientColor     = vec3(0.5, 0.7, 1.0);
    float kAmbient         = 1.2;
    float ambientExponent  = clamp(0.5 + 0.5 * normal.y, 0.0, 1.0);
    vec3  ambient          = kAmbient * ambientExponent * ambientColor;

    vec3  diffuseColor     = vec3(1.0, 0.85, 0.55);
    float kDiffuse         = 1.20;
    float expDiffuse       = clamp(dot(lightDirection, normal), 0.0, 1.0);
    vec3  diffuse          = kDiffuse * expDiffuse * diffuseColor;

    vec3  specularColor    = vec3(1.0, 0.85, 0.55);
    float kSpecular        = 1.2;
    float specularFactor   = 160.0;
    float specularExponent = pow(
                                 clamp(dot(reflection, normal), 0.0, 1.0),
                                 specularFactor
                             );
    vec3  specular         = kSpecular * specularExponent * specularColor * expDiffuse;

    vec3 light             = direct + diffuse + specular + ambient;
    color                  = color * light;
    color                  = mix(
                                 color,
                                 vec3(0.8, 0.9, 1.0),
                                 1.0 - exp(-0.002 * currentDistance * currentDistance)
                             );

    return color;
}
  \end{minted}
\caption{Phong shading as implemented.}
\label{fig:phong-shading-implementation}
\end{figure*}

\newthought{Lighting and materials} are currently implemented statically. For
lighting a light source is hard-coded within the
shader.~\Cref{fig:lights-implementation} shows the implementation of the light
source. Concerning materials currently the same material for all objects is
used.~\Cref{fig:material-implementation} shows the implementation of the
material.

\begin{figure}
  \begin{minted}[%
    bgcolor=LightGray,
    linenos=true,
    mathescape=true,
    tabsize=4]{glsl}
vec3 light1Color = vec3(0.9, 0.49, 0.83);
vec3 light1Position = vec3(0.6, 0.7, 1.5);
color = calcLighting(position, normal, rayDirection,
                     material, light1Position,
                     light1Color, currentDistance);
  \end{minted}
\caption{The hard-coded light source as implemented in the shader.}
\label{fig:lights-implementation}
\end{figure}

\begin{figure*}
  \begin{minted}[%
    bgcolor=LightGray,
    linenos=true,
    mathescape=true,
    tabsize=4]{glsl}
// Calculates the material based on a given distance.
vec3 calcMaterial(in float currentDistance)
{
    return 0.45 + 0.3 * sin(vec3(0.05, 0.08, 0.10) * (currentDistance - 10.0));
}
  \end{minted}
\caption{The hard-coded material as implemented in the shader.}
\label{fig:material-implementation}
\end{figure*}% -*- mode: latex; coding: utf-8 -*-

\chapter{Discussion and conclusion}
\label{chap:discussion-conclusion}

\newthought{The previous chapter} showed the results of this thesis.

\newthought{This chapter} offers a discussion of the results and a conclusion.

\newthought{In the first section} the results of this thesis are interpreted.
The first section builds the basis for the second section, the conclusion. The
second section summarizes the most important results relating to the
objectives and provides an outlook what might follow up this thesis.


\section{Discussion}
\label{sec:discussion-conclusion:discussion}

% Im Kapitel Diskussion setzt sich die Autorin, der Autor mit den erzielten
% Ergebnissen auseinander. Diese werden interpretiert und mit Erkenntnissen aus
% anderen Studien zur gleichen Fragestellung beurteilt. Die Diskussion schafft die
% nötigen Grundlagen, damit die in der Einleitung formulierte Fragestellung
% möglichst gut und sachlich richtig beantwortet werden kann.

\newthought{The results of this thesis} are a software architecture, a literate
program and an implement program. The software architecture builds the basis for
the program implemented. The literate program documents the program implemented
while at the same time providing the actual implementation.

\subsection{Software architecture}
\label{subsec:discussion-conclusion:discussion:software-architecture}

\newthought{The software architecture} is defined by three aspects: an
architectural software design pattern, layers and signals and slots.

\newthought{The used architectural software design pattern} is a combination of
the model-view-view model and the model-view-controller software design
patterns. The pattern separates data from its representation and ensures a
coherent design.

\newthought{A relaxed layered architecture} is used to reduce coupling and
dependencies. The architecture allows higher layers to communicate with any
lower layer.

\newthought{Signals and slots}, which are a generalized implementation of the
observer pattern, are used to allow communication between components. This
prevents high coupling and low cohesion.

\subsection{Literate program}
\label{subsec:discussion-conclusion:discussion:literate-program}

\newthought{The developed literate program} explains how a program for modeling,
composing and rendering real time computer graphics using sphere tracing is
developed. The used literate programming paradigm allows to explain to human
beings what the computer shall do instead of focusing on instructing the
computer what to do by writing program code and forcing readers to read the
program code.

\newthought{The literate program starts} with a description of what will be
achieved. From this description the main components are derived and then
subsequently implemented. This shows also the overall structure of the literate
program: a certain concept is first introduced by describing it and then
implemented.

\subsection{Program}
\label{subsec:discussion-conclusion:discussion:program}

\newthought{Using the introduced methodologies} and the developed software
architecture the editor component of the program was implemented.

\newthought{Animations are the building blocks} of the editor component and
contain scenes, which contain nodes. Currently the developed editor component
allows one animation to be managed.

\newthought{Scenes build the basis} of an animation. They can be managed using a
tree like structure. Each scene holds nodes in a graph structure.

\newthought{Nodes represent the content} of a scene and therefore of an
animation. Nodes are defined by node definitions which are read from the file
system. The program implemented supports currently only nodes which define
implicit objects.

\newthought{Animations are evaluated} for rendering. Evaluating an animation means
evaluating scenes which means evaluating nodes. The result is OpenGL Shading
Language specific code which is executed by the graphical processing unit (GPU)
and seen by the viewer.

\newthought{Rendering is done} using the sphere tracing algorithm. For shading
the Phong shading technique is used.

\section{Conclusion}
\label{sec:conclusion}

% In den Folgerungen können die wichtigsten Ergebnisse in ihrer kritischen
% Würdigung prägnant zusammengefasst werden. Es wird eine Art Schlussbilanz
% gezogen. Aus der detaillierten Darstellung der Ergebnisse und deren Diskussion
% lässt sich in der Regel eine Antwort auf die Ausgangsfrage ableiten [3, p. 26].
% Die Antwort auf die Fragestellung kann zu Empfeh- lungen für die Ausführung in
% der Praxis oder für weitere Studien führen. Die Folgerungen dürfen keine neuen
% Elemente und Aspekte enthalten, welche nicht schon in den Ergebnissen und in der
% Diskussion behandelt wurden. Wenn die Problemstellung der Arbeit nur sehr wenige
% Folgerungen verlangt, können diese auch als Schlussteil in die Diskussion
% integriert werden.

\newthought{The main objective of this thesis} is the design and development of
a program for modeling, composing and rendering real time computer graphics by
providing a graphical toolbox. To reach this main objective additional
objectives were defined, which can be found
at~\autoref{subsec:objectives}~\enquote{\nameref{subsec:objectives}}

\newthought{All of the objectives could be reached}, not all of the objectives
and components are as elaborated as originally intended however. The program
implemented provides at this time no possibility to store and load animations
and supports only nodes which define implicit objects. As the whole node
structure is very generalized (by using definitions for nodes) new node types
can be implemented without much effort. At this time no connections between
nodes are possible, the program implemented only allows the evaluation of a
single node at a time. Point light sources are directly implemented (hard-coded)
within the shader and not as nodes as intended. The same applies for materials
of objects.

\newthought{The use of the literate programming paradigm} was a whole new
experience to the author.

\newthought{Literate programming has a lot of advantages}, such as focusing on
explaining to human beings what the computer shall do in terms of ideas and
concepts instead of instructing the computer what to do by writing only program
code. As combining the documentation with code in a single document builds the
basis of literate programming, the documentation of the program is inherent.
This prevents unforeseen cost and time overruns.

\newthought{Literate programming faces also several problems however}: it
requires a different way of thinking from traditional methodologies, it is very
expressive and verbose, and the documentation can become lengthy and hard to
read, especially when including the full implementation of technical details.
Although these problems were overcome in the writing of this thesis, they led to
significant overhead which affected the whole thesis in terms of less
productivity. When someone is used to the paradigm these problems can be
prevented upfront and the paradigm may be not much more costly than using
traditional methodologies (at least for smaller programs).

\newthought{Sphere tracing}, the algorithm used for rendering, is able to
produce high quality, realistic looking images in real time without being overly
complex. It has however a clear disadvantage: the de facto way of representing
the surface of objects using triangle based meshes cannot be used directly.
Instead, distance functions have to be used for modeling the surfaces as seen
from any view point. This disadvantage may be the reason that sphere tracing
seems not to be used production. However, the algorithm seems to coming into use
in production, for example for calculating ambient
occlusion~\cite{epic-games-ao-2017} or soft
shadows~\cite{epic-games-soft-shadows-2017}. Time will tell if the method will
establish itself further and become practicable for rendering conventional
meshes.

\newthought{As this thesis has a limited time frame} of one semester, not all
desired topics could be treated and not all of the set objectives and
components are as elaborated as originally intended.

\newthought{Further topics} for the continuation of this thesis might be
additional features for the editor component and the development of the player
component, which can be used as standalone program.

\newthought{Additional features for the editor} component could be the
following: a sequencer, allowing a time-based scheduling of defined scenes.
Additional nodes, such as operations (e.g.\ replication of objects) or
post-processing effects (glow/glare, color grading and so on).

\newthought{Additional features for rendering} could be the implementation of
ambient occlusion, the implementation of realistic materials based on the
bidirectional reflectance distribution function and the acceleration of the
sphere tracing algorithm.
% Backmatter
%---------------------------------------------------------------------------
\backmatter{}

% Appendix
% -*- mode: latex; coding: utf-8 -*-

\appendix
\part*{Appendix}
\label{part:appendix}

% -*- mode: latex; coding: utf-8 -*-

\chapter{Implementation}
\label{appendix:chap:implementation}

\newthought{To begin with the implementation} of a project, it is necessary to
first think about the goal that one wants to reach and about some basic
structures and guidelines which lead to the fulfillment of that goal.

\newthought{The main goal is} to have a visual animation system, which allows
the creation and rendering of visually appealing scenes, using a graphical user
interface for creation, and a ray tracing based algorithm for
rendering.

\newthought{The thoughts to reach this goal} were already developed
in~\nameref{chap:fundamentals} and~\nameref{chap:methodologies} and will
therefore not be repeated again.

\newthought{As stated in~\nameref{chap:methodologies}}, the literate programming
paradigm is used to implement the components. To maintain readability only
relevant code fragments are shown in place. The whole code fragments, which are
needed for tangling, are found
at~\autoref{chap:code-fragments}~\enquote{\nameref{chap:code-fragments}}.

\newthought{The editor component is described first} as it is the basis for the
whole project and also contains many concepts, that are re-used by the player
component. Before starting with the implementation it is necessary to define
requirements and some kind of framework for the implementation.

% -*- mode: latex; coding: utf-8 -*-

\section{Requirements}
\label{appendix:sec:requirements}

\newthought{The requirements for running the implementation} are currently the
following:

\begin{itemize}
  \item A Unix derivative as operating system (Linux, macOS).
  \item Python~\footnote{\url{http://www.python.org}} version 3.5.x or above
  \item PyQt5~\footnote{%
      \url{https://riverbankcomputing.com/software/pyqt/intro}} version 5.7 or
    above
  \item OpenGL~\footnote{\url{https://www.opengl.org/}} version 3.3 or above
\end{itemize}% -*- mode: latex; coding: utf-8 -*-

\section{Name spaces and project structure}
\label{appendix:sec:name-spaces}

\newthought{To provide a structure for the whole project} and for being able to
stick to the thoughts established in~\nameref{chap:fundamentals}
and~\nameref{chap:methodologies}, it may be wise to structure the project a
certain way.

\newthought{The source code shall be placed} in the~\verb+src+ directory
underneath the main directory. The creation of the single directories is not
explicitly shown, it is done by parts of this documentation which are tangled
but not exported.

\newthought{When dealing with directories and files}, Python uses the
term~\emph{package} for (sub-) directories and~\emph{module} for files within
directories.\footnote{\url{https://docs.python.org/3/reference/import.html\#packages}}

\newthought{To prevent having multiple modules having the same name,} name
spaces are
used.\footnote{\url{https://docs.python.org/3/tutorial/classes.html\#python-scopes-and-namespaces}}
The main name space shall be analogous to the project's name:~\verb+qde+.
Underneath the source code folder~\verb+src+, each sub-folder represents a
package and acts therefore also as a name space.

\newthought{To allow a whole package and its modules} being
imported~\emph{as modules}, it needs to have at least a file inside,
called~\verb+__init__.py+. Those files may be empty or they may contain
regular source code such as classes or methods.

\section{Coding style}
\label{appendix:sec:coding-style}

\newthought{To stay consistent throughout implementation} of components, a
coding style is applied which is defined as follows.

\begin{itemize}
  \item Classes use camel case, e.g. \verb+class SomeClassName+.
  \item Folders respectively name spaces use only small letters, e.g.
    \verb+foo.bar.baz+.
  \item Methods are all small caps and use underscores as spaces, e.g.
    \verb+some_method_name+.
  \item Signals are methods, which are prefixed by the word~\enquote{do}, e.g.
    \verb+do_something+.
  \item Slots are methods, which are prefixed by the word~\enquote{on}, e.g.
    \verb+on_something+.
  \item Importing is done by the \verb+from Foo import Bar+ syntax, whereas
    \verb+Foo+ is a module and \verb+Bar+ is either a module, a class or a
    method.
\end{itemize}

\subsection{Importing of modules}
\label{appendix:subsec:imports}

\newthought{For the implementation python is used}, as mentioned in
section~\enquote{\nameref{appendix:sec:requirements}}. Python
has~\enquote{batteries included}, which means that it offers a lot of
functionality through various modules, which have to be imported first before
using them. The same applies of course for self written modules. Python offers
multiple possibilities concerning
imports~\footnote{\url{https://docs.python.org/3/tutorial/modules.html}}.

However, PEP number 8 recommends to either import modules directly or to import
the needed functionality
directly.~\footnote{\url{https://www.python.org/dev/peps/pep-0020/}}. As defined
by the coding
style,~\autoref{appendix:subsec:framework}~\enquote{\nameref{appendix:subsec:framework}},
imports are done by the \verb+from Foo import Bar+ syntax.

\newthought{The imported modules are always split up:} first the system modules
are imported, modules which are provided by Python itself or by external
libraries, then project-related modules are imported.

\subsection{Framework for implementation}
\label{appendix:subsec:framework}

\newthought{To stay consistent when implementing} classes an methods, it makes
sense to define a rough framework for their implementation, which is as follows:
\begin{enumerate*}
  \item Define necessary signals,
  \item define the constructor and
  \item implement the remaining functionality in terms of methods and slots.
\end{enumerate*}
Concerning the constructor, the following pattern may be applied:
\begin{enumerate*}
  \item Set up the user interface when it is a class concerning the graphical
    user interface,
  \item set up class-specific aspects, such as the name, the tile or an icon,
  \item set up other components used by that class and
  \item initialize the connections, meaning hooking up the defined signals
    with corresponding methods.
\end{enumerate*}

Now, having defined the~\emph{requirements}, a~\emph{project structure},
a~\emph{coding style} and a~\emph{framework for} the
actual~\emph{implementation}, the implementation of the editor may be
approached.
%-*- mode: latex; coding: utf-8 -*-

\chapter{Editor}
\label{appendix:chap:editor}

\newthought{Before diving right into the implementation} of the editor, it may
be good to reconsider what shall actually be implemented, therefore what the
main functionality of the editor is and what its components are.

\newthought{The quintessence of the editor} is to output a structure, be it in
the JSON format or even in bytecode, which defines an animation.

\newthought{An animation} is simply a composition of scenes which run in a
sequential order within a time span. A scene is then a composition of nodes,
which are at the end of their evaluation nothing else as shader specific code
which gets executed on the GPU.\@As this definition is rather abstract, it may be
easier to define what shall be achieved in terms of content and then work
towards this definition.

\newthought{A very basic definition of what shall be achieved} is the following.
It shall be possible to create an animated scene using the editor application.
The scene shall be composed of two objects, a sphere and a cube. Additionally it
shall have a camera as well as a point light.

The camera shall be placed 5 units in height and 10 units in front of the center
of the scene. The cube shall be placed in the middle of the scene, the sphere
shall have an offset of 5 units to the right and 2 units in depth. The point
light shall be placed 10 units above the center.

Both objects shall have different materials: the cube shall have a dull surface
of any color whereas the sphere shall have a glossy surface of any color.

There shall be an animation of ten seconds duration. During this animation the
sphere shall move towards the cube and they shall merge into a blob-like object.
The camera shall move 5 units towards the two objects during this time.

\newthought{To achieve this overall goal}, while providing an user-friendly
experience, several components are needed. These are the following, being
defined in~\citetitle[pp. 29
ff.]{osterwalder-qde-2016}~\cite{osterwalder-qde-2016}

\begin{description}
  \item[A scene graph] allowing the creation and deletion of scenes. The scene
    graph has at least a root scene.
  \item[A node-based graph] structure allowing the composition of scenes using
    nodes and connections between the nodes. There exists at least a root node
    at the root scene of the scene graph.
  \item[A parameter window] showing parameters of the currently selected graph
    node.
  \item[A rendering window] rendering the currently selected node or scene.
  \item[A sequencer] allowing a time-based scheduling of defined scenes.
\end{description}

However, the above list is not complete. It is somehow intuitively clear, that
there needs to be some~\emph{main component}, which holds all the mentioned
components and allows a proper handling of the application (like managing
resources, shutting down properly and so on).

\newthought{The main component} is composed of a view and a controller, as the
whole architecture uses layers and the MVVMC principle, see
section~\enquote{\nameref{soarch}}. A model is (at least at this point) not
necessary. The view component shall be called~\emph{main window} and its
controller shall be called~\emph{main application}.

\newthought{To preserve clarity} all components are described in discrete
chapters. Although the implementation of the components is very specific, in
terms of the programming language, their logic may be reused later on when
developing the player component.

\newthought{Before implementing} any of these components however, the editor
application needs an entry point, that is a point where the application starts
when being called.

\section{Main entry point}
\label{appendix:sec:editor:main}

\newthought{An entry point} is a point where an application starts when being
called. Python does this by evaluating a special variable within a module,
called~\verb=__name__=. Its value is set to~\verb='__main__'= if the module
is~\enquote{read from standard input, a script, or from an interactive
prompt.}~\footnote{\url{https://docs.python.org/3/library/__main__.html}}

\newthought{All that the entry point needs to do}, in case of the editor
application, is spawning the editor application, execute it and exit again, as
can be seen below.

\begin{figure}[!htpb]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap11}\raggedright\small
\NWtarget{nuweb87a}{} $\langle\,${\itshape Main entry point}\nobreak\ {\footnotesize {87a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
if __name__ == "__main__":
    app = application.Application(sys.argv)
    status = app.exec()
    sys.exit(status)
  |\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb190}{190}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Main entry point of the editor application.\newline{}\newline{}Editor
    $\rightarrow$ Main entry point}
% \label{editor:lst:main}
\end{figure}

\newthought{But where to place the main entry point?} A very direct approach
would be to implement that main entry point within the main application
controller. But when running the editor application by calling it from the
command line, calling a controller directly may rather be confusing. Instead it
is more intuitive to have only a minimal entry point which is clearly visible as
such. Therefore the main entry point will be put in a file
called~\verb=editor.py= which is at the top level of the~\verb=src= directory.

\section{Main application}
\label{appendix:sec:editor:app}

\newthought{The editor application cannot be started yet}, although a main entry
point is defined by now. This is due the fact that there is no such thing as an
editor application yet. Therefore a main application needs to implemented.

\newthought{Qt version 5 is used} through the PyQt5 wrapper, as stated in the
section~\enquote{\nameref{appendix:sec:requirements}}. Therefore all
functionality of Qt 5 may be used. Qt already offers a main application class,
which can be used as a controller. The class is called~\verb=QApplication=.

\newthought{But what does such a main application class actually do?} What is
its functionality? Very roughly sketched, such a type of application initializes
resources, enters a main loop, where it stays until told to shut down, and at
the end it frees the allocated resources again.

Due to the usage of~\verb=QApplication= as super class it is not necessary to
implement a main (event-) loop, as such is provided by Qt
itself~\footnote{\url{http://doc.qt.io/Qt-5/qapplication.html\#exec}}.

As the main application initializes resources, it act as central node between the
various layers of the architecture, initializing them and connecting them using
signals.\cite[pp. 37 --- 38]{osterwalder-qde-2016}

\begin{figure}[!htpb]
  \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap12}\raggedright\small
\NWtarget{nuweb87b}{} $\langle\,${\itshape Main application declarations}\nobreak\ {\footnotesize {87b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class Application(QtWidgets.QApplication):
    """Main application for QDE."""

    |\hbox{$\langle\,${\itshape Main application constructor}\nobreak\ {\footnotesize \NWlink{nuweb88a}{88a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Main application methods}\nobreak\ {\footnotesize \NWlink{nuweb117a}{117a}}$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb191a}{191a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Main application class of the editor
    application.\newline{}\newline{}Editor $\rightarrow$ Application}
% \label{editor:lst:app}
\end{figure}

Therefore it needs to do at least three things:
\begin{enumerate*}
  \item initialize itself,
  \item set up components and
  \item connect components.
  \end{enumerate*}
This all happens when the main application is being initialized through its
constructor.

\begin{figure}[!htpb]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap13}\raggedright\small
\NWtarget{nuweb88a}{} $\langle\,${\itshape Main application constructor}\nobreak\ {\footnotesize {88a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, arguments):
    """Constructor.

    :param arguments: a (variable) list of arguments, that are
                      passed when calling this class.
    :type  argv:      list
    """

    |\hbox{$\langle\,${\itshape Set up internals for main application}\nobreak\ {\footnotesize \NWlink{nuweb88b}{88b}, \ldots\ }$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Set up components for main application}\nobreak\ {\footnotesize \NWlink{nuweb90b}{90b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Add root node for main application}\nobreak\ {\footnotesize \NWlink{nuweb97b}{97b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Set model for scene graph view}\nobreak\ {\footnotesize \NWlink{nuweb106b}{106b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Load nodes}\nobreak\ {\footnotesize \NWlink{nuweb181b}{181b}}$\,\rangle$}|
    self.main_window.show()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb87b}{87b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the editor application
    class.\newline{}\newline{}Editor $\rightarrow$ Application $\rightarrow$
    Constructor}
% \label{editor:lst:app:constructor}
\end{figure}

\newthought{Setting up the internals} is straight forward: Passing any given
arguments directly to~\verb=QApplication=, setting an application icon, a name
as well as a display name.

\begin{figure}[!htpb]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap14}\raggedright\small
\NWtarget{nuweb88b}{} $\langle\,${\itshape Set up internals for main application}\nobreak\ {\footnotesize {88b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
super(Application, self).__init__(arguments)
self.setWindowIcon(QtGui.QIcon("assets/icons/im.png"))
self.setApplicationName("QDE")
self.setApplicationDisplayName("QDE")|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb88b}{88b}\NWlink{nuweb117b}{, 117b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb88a}{88a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Setting up the internals for the main application class.
  \newline{}\newline{}Editor $\rightarrow$ Application $\rightarrow$
  Constructor}
% \label{editor:lst:app:constructor:internals}
\end{figure}

The other two steps, setting up the components and connecting them can however
not be done at this point, as there simply are no components available. A
component to start with is the view component of the main application, the main
window.

\section{Main window}
\label{appendix:sec:editor:main-window}

\newthought{Having a very basic implementation} of the main application, its
view component, the main window, can now be implemented and then be set up by
the main application.

\newthought{The main functionality} of the main window is to set up the actual
user interface, containing all the views of the components. Qt offers the class
\verb=QMainWindow= from which~\verb=MainWindow= may inherit.

\begin{figure}[!htpb]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap15}\raggedright\small
\NWtarget{nuweb89a}{} $\langle\,${\itshape Main window declarations}\nobreak\ {\footnotesize {89a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class MainWindow(QtWidgets.QMainWindow):
    """The main window class.
    Acts as main view for the QDE editor application.
    """

    |\hbox{$\langle\,${\itshape Main window signals}\nobreak\ {\footnotesize \NWlink{nuweb89b}{89b}}$\,\rangle$}|

    |\hbox{$\langle\,${\itshape Main window methods}\nobreak\ {\footnotesize \NWlink{nuweb90a}{90a}, \ldots\ }$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb192a}{192a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Main window class of the editor application.
  \newline{}\newline{}Editor $\rightarrow$ Main window}
% \label{editor:lst:main-window}
\end{figure}

\newthought{For being able to shut down} the main application and therefore the
main window, they need to react to a request for shutting down, either by a
keyboard shortcut or a menu command. However, the main window is not able to
force the main application to quit by itself. It would be possible to pass the
main window a reference to the application, but that would lead to tight
coupling and is therefore not considered as an option. Signals and slots allow
exactly such cross-layer communication without coupling components tightly.

\newthought{To avoid tight coupling} a signal within the main window is
introduced, which tells the main application to shut down. A fitting name for
the signal might be~\verb=do_close=.

\begin{figure}[!htpb]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap16}\raggedright\small
\NWtarget{nuweb89b}{} $\langle\,${\itshape Main window signals}\nobreak\ {\footnotesize {89b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_close = QtCore.pyqtSignal()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb89a}{89a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the~\texttt{do\_close} signal of the main window class.
  \newline{}\newline{}Editor $\rightarrow$ Main window $\rightarrow$ Signals}
% \label{editor:lst:main-window:signals}
\end{figure}

Now, that the signal for closing the window and the application is defined, two
additional things need to be considered: The emission of the signal by
the main window itself as well as the consumption of the signal by a slot of
other classes.

The signal shall be emitted when the escape key on the keyboard is pressed or
when the corresponding menu item was selected. As there is no menu at the
moment, only the key pressed event is implemented by now.

\begin{figure}[!htpb]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap17}\raggedright\small
\NWtarget{nuweb90a}{} $\langle\,${\itshape Main window methods}\nobreak\ {\footnotesize {90a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, parent=None):
    """Constructor."""

    super(MainWindow, self).__init__(parent)
    self.setup_ui()

def keyPressEvent(self, event):
    """Gets triggered when a key press event is raised.

    :param event: holds the triggered event.
    :type  event: QKeyEvent
    """

    if event.key() == QtCore.Qt.Key_Escape:
        self.do_close.emit()
    else:
        super(MainWindow, self).keyPressEvent(event)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb90a}{90a}\NWlink{nuweb92}{, 92}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb89a}{89a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of methods for the main window class.
  \newline{}\newline{}Editor $\rightarrow$ Main window $\rightarrow$ Methods}
% \label{editor:lst:main-window:methods}
\end{figure}

% For emitting the signal when selecting a menu entry, an action needs to be
% defined which is then attached to the menu entry. The action emits a signal as
% soon as the menu entry was clicked. It is however not possible to trigger the
% defined~\verb=do_close= signal using the actions signal. There a slot needs to
% be defined which then in its turn triggers~\verb=do_close=.

\newthought{The main window can now be set up} by the main application
controller, which also listens to the~\verb=do_close= signal through the
inherited~\verb=quit= slot.

\begin{figure}[!htpb]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap18}\raggedright\small
\NWtarget{nuweb90b}{} $\langle\,${\itshape Set up components for main application}\nobreak\ {\footnotesize {90b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\hbox{$\langle\,${\itshape Set up controllers for main application}\nobreak\ {\footnotesize \NWlink{nuweb105b}{105b}, \ldots\ }$\,\rangle$}|
|\hbox{$\langle\,${\itshape Connect controllers for main application}\nobreak\ {\footnotesize \NWlink{nuweb136b}{136b}, \ldots\ }$\,\rangle$}|
|\hbox{$\langle\,${\itshape Set up main window for main application}\nobreak\ {\footnotesize \NWlink{nuweb90c}{90c}}$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb88a}{88a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Setting up of components for the main application class.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:methods}
\end{figure}

\begin{figure}[!htpb]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap19}\raggedright\small
\NWtarget{nuweb90c}{} $\langle\,${\itshape Set up main window for main application}\nobreak\ {\footnotesize {90c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.main_window = qde_main_window.MainWindow()
self.main_window.move(100, 100)
self.main_window.do_close.connect(self.quit)
|\hbox{$\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize \NWlink{nuweb114b}{114b}, \ldots\ }$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb90b}{90b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Set up of the editor main window and its signals from within the main
  application. \newline{}\newline{}Editor $\rightarrow$ Main application
  $\rightarrow$ Constructor}
% \label{editor:lst:main-application:constructor:main-window}
\end{figure}

The used view component for the main window,~\verb=QMainWindow=, needs at least
a central widget with a layout for being
rendered.~\footnote{\url{http://doc.qt.io/qt-5/qmainwindow.html\#creating-main-window-components}}

\newthought{As the main window will set up and hold} the whole layout for the
application through multiple view components, a method~\verb=setup_ui= is
introduced, which sets up the whole layout. The method creates a central widget
containing a grid layout.

\newthought{Targeting a look} as proposed in~\citetitle[p.
9]{osterwalder-qde-2016}, a simple grid layout does however not provide enough
possibilities. Instead a horizontal box layout in combination with splitters is
used.

Recalling the components, the following layout is approached, which can be seen in~\cref{fig:appendix:editor-components}:

\begin{itemize}
\item{%
    A scene graph, on the left of the window, covering the whole height.}
\item{%
    A node graph on the right of the scene graph, covering as much height as
    possible.}
\item{%
    A view for showing the properties (and therefore parameters) of the selected
    node on the right of the node graph, covering as much height as possible.}
\item{%
    A display for rendering the selected node, on the right of the properties
    view, covering as much height as possible}
\item{%
    A sequencer at the right of the scene graph and below the other components
    at the bottom of the window, covering as much width as possible}
\end{itemize}

\begin{figure}[ht]
  \caption{%
    A mock up of the editor application showing its components.\newline{}
    1: Scene tree.\newline{}
    2: Node graph.\newline{}
    3: Parameter view.\newline{}
    4: Rendering view.\newline{}
    5: Time line.
  }
\label{fig:appendix:editor-components}
  \includegraphics[width=0.95\linewidth]{images/editor-components}
\end{figure}

\begin{figure*}[!htpb]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap20}\raggedright\small
\NWtarget{nuweb92}{} $\langle\,${\itshape Main window methods}\nobreak\ {\footnotesize {92}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def setup_ui(self):
    """Sets up the user interface specific components."""

    self.setObjectName('MainWindow')
    self.setWindowTitle('QDE')
    self.resize(1024, 768)
    # Ensure that the window is not hidden behind other windows
    self.activateWindow()

    central_widget = QtWidgets.QWidget(self)
    central_widget.setObjectName('central_widget')
    grid_layout = QtWidgets.QGridLayout(central_widget)
    central_widget.setLayout(grid_layout)
    self.setCentralWidget(central_widget)
    self.statusBar().showMessage('Ready.')

    horizontal_layout_widget = QtWidgets.QWidget(central_widget)
    horizontal_layout_widget.setObjectName('horizontal_layout_widget')
    horizontal_layout_widget.setGeometry(QtCore.QRect(12, 12, 781, 541))
    horizontal_layout_widget.setSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding,
    QtWidgets.QSizePolicy.MinimumExpanding)
    grid_layout.addWidget(horizontal_layout_widget, 0, 0)

    horizontal_layout = QtWidgets.QHBoxLayout(horizontal_layout_widget)
    horizontal_layout.setObjectName('horizontal_layout')
    horizontal_layout.setContentsMargins(0, 0, 0, 0)

    self.scene_graph_view = gui_scene.SceneGraphView(self)
    self.scene_graph_view.setObjectName('scene_graph_view')
    self.scene_graph_view.setMaximumWidth(300)
    horizontal_layout.addWidget(self.scene_graph_view)

    |\hbox{$\langle\,${\itshape Set up scene view in main window}\nobreak\ {\footnotesize \NWlink{nuweb135}{135}}$\,\rangle$}|
    # Set up parameter view in main window
    |\hbox{$\langle\,${\itshape Set up render view in main window}\nobreak\ {\footnotesize \NWlink{nuweb192b}{192b}}$\,\rangle$}|

    horizontal_splitter = QtWidgets.QSplitter()
    |\hbox{$\langle\,${\itshape Add render view to horizontal splitter in main window}\nobreak\ {\footnotesize \NWlink{nuweb192c}{192c}}$\,\rangle$}|
    # Add parameter view to horizontal splitter in main window

    vertical_splitter = QtWidgets.QSplitter()
    vertical_splitter.setOrientation(QtCore.Qt.Vertical)
    vertical_splitter.addWidget(horizontal_splitter)
    |\hbox{$\langle\,${\itshape Add scene view to vertical splitter in main window}\nobreak\ {\footnotesize \NWlink{nuweb136a}{136a}}$\,\rangle$}|

    horizontal_layout.addWidget(vertical_splitter)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb90a}{90a}\NWlink{nuweb92}{, 92}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb89a}{89a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Set up of the user interface of the editor's  main window.
  \newline{}\newline{}Editor $\rightarrow$ Main window
  $\rightarrow$ Methods}
% \label{editor:lst:main-window:methods:setup-ui}
\end{figure*}

All the above taken actions to lay out the main window change nothing in the
window's yet plain appearance. This is quite obvious, as none of the actual
components are implemented yet.

\newthought{A good starting point} for the implementation of the remaining
components might be the scene graph, as it might be the most straight-forward
component to implement.

% -*- mode: latex; coding: utf-8 -*-

\chapter{Scene graph}
\label{appendix:chap:scene-graph}

\newthought{The scene graph component} has two aspects to consider, as mentioned
in chapter~\enquote{\nameref{appendix:chap:editor}}:
\begin{enumerate*}
  \item a graphical aspect as well as
  \item its data structure.
\end{enumerate*}

As described in subsection~\enquote{\nameref{results:subsec:software-design}},
two kinds of models are used. A domain model, containing the actual data and a
view model, which holds a reference to its corresponding domain model.

As the domain model builds the basis for the whole (data-) structure, it is
implemented first.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap21}\raggedright\small
\NWtarget{nuweb93}{} $\langle\,${\itshape Scene model declarations}\nobreak\ {\footnotesize {93}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class SceneModel(object):
    """The scene model.
    It is used as a base class for scene instances within the
    whole system.
    """

    # Signals

    |\hbox{$\langle\,${\itshape Scene model methods}\nobreak\ {\footnotesize \NWlink{nuweb94a}{94a}}$\,\rangle$}|

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb193a}{193a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the scene model class, which acts as a base class for
scene instances within the whole application.
  \newline{}\newline{}Editor $\rightarrow$ Scene model}
% \label{editor:lst:scene-model}
\end{figure}

\newthought{The only known fact} at this point is, that a scene is a composition
of nodes and therefore holds its nodes as a list. Additionally it holds a
reference to its parent.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap22}\raggedright\small
\NWtarget{nuweb94a}{} $\langle\,${\itshape Scene model methods}\nobreak\ {\footnotesize {94a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, parent=None):
    """Constructor.

    :param parent: the parent scene of this scene. The parent is
                   None if the current scene is the root scene.
    :type parent:  SceneModel
    """

    self.id_ = uuid.uuid4()
    self.nodes = []
    self.parent = parent|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The constructor of the scene model.
  \newline{}\newline{}Editor $\rightarrow$ Scene model $\rightarrow$ Constructor}
% \label{editor:lst:scene-model:constructor}
\end{figure}

\newthought{The counter part of the domain model} is the view model. View models
are used to visually represent something within the graphical user interface and
they provide an interface to the~\verb=domain= layer. To this point, a simple
reference in terms of an attribute is used as interface, which may be changed
later on.

Concerning the user interface, a view model must fulfill the requirements posed
by the user interface's corresponding component. In this case this are actually
two components: the scene graph view as well as the scene view.

It would therefore make sense the use one view model for both components, but
this is not possible as the view model of the scene view,~\verb=QGraphicsScene=,
uses its own data model.

Therefore~\verb=QObject= will be used for the scene graph view model
and~\verb=QGraphicsScene= will be used for the scene view model.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap23}\raggedright\small
\NWtarget{nuweb94b}{} $\langle\,${\itshape Scene graph view model declarations}\nobreak\ {\footnotesize {94b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class SceneGraphViewModel(Qt.QObject):
    """View model representing scene graph items.

    The SceneGraphViewModel corresponds to an entry within the
    scene graph. It is used by the QAbstractItemModel class and
    must therefore at least provide a name and a row.
    """

    # Signals

    |\hbox{$\langle\,${\itshape Scene graph view model constructor}\nobreak\ {\footnotesize \NWlink{nuweb95}{95}, \ldots\ }$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene graph view model methods}\nobreak\ {\footnotesize \NWlink{nuweb105a}{105a}, \ldots\ }$\,\rangle$}|

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb193b}{193b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the scene graph view model class, which corresponds to an
  entry within the scene graph.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view model}
% \label{editor:lst:scene-graph-view-model}
\end{figure}

In terms of the scene graph, the view model must provide at least a name and a
row. In addition, as written above, it holds a reference to the domain model.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap24}\raggedright\small
\NWtarget{nuweb95}{} $\langle\,${\itshape Scene graph view model constructor}\nobreak\ {\footnotesize {95}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(
        self,
        row,
        domain_object,
        name=QtCore.QCoreApplication.translate(
            'SceneGraphViewModel', 'New scene'
        ),
        parent=None
):
    """Constructor.

    :param row:           The row the view model is in.
    :type  row:           int
    :param domain_object: Reference to a scene model.
    :type  domain_object: qde.editor.domain.scene.SceneModel
    :param name:          The name of the view model, which will
                          be displayed in the scene graph.
    :type  name:          str
    :param parent:        The parent of the current view model
                          within the scene graph.
    :type parent:         qde.editor.gui_domain.scene.
                          SceneGraphViewModel
    """

    super(SceneGraphViewModel, self).__init__(parent)

    self.id_ = domain_object.id_
    self.row  = row
    self.domain_object = domain_object
    self.name = name
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb95}{95}\NWlink{nuweb104b}{, 104b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb94b}{94b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The constructor of the scene graph view model.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view model $\rightarrow$
  Constructor}
% \label{editor:lst:scene-graph-view-model:constructor}
\end{figure}

\newthought{Scenes may now be instantiated,} it is although necessary to manage
scenes in a controlled manner. Therefore the class~\verb=SceneGraphController=
will now be implemented, for being able to manage scenes.

As the scene graph shall be built as a tree structure, an appropriate data
structure is needed. Qt provides the~\verb=QTreeWidget= class, but that
class is in this case not suitable, as it does not separate the data from its
representation, as stated by Qt:~\enquote{Developers who do not need the flexibility of
the Model/View framework can use this class to create simple hierarchical lists
very easily. A more flexible approach involves combining a QTreeView with a
standard item model. This allows the storage of data to be separated from its
representation.}\footnote{\url{http://doc.qt.io/qt-5/qtreewidget.html\#details}}

\newthought{Such a standard item model}
is~\verb=QAbstractItemModel=\footnote{\label{footnote:qabstractitemmodel}
http://doc.qt.io/qt-5/qabstractitemmodel.html}, which is used as a base class
for the scene graph controller.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap25}\raggedright\small
\NWtarget{nuweb96a}{} $\langle\,${\itshape Scene graph controller declarations}\nobreak\ {\footnotesize {96a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class SceneGraphController(QtCore.QAbstractItemModel):
    """The scene graph controller.
    A controller for managing the scene graph by adding,
    editing and removing scenes.
    """

    |\hbox{$\langle\,${\itshape Scene graph controller signals}\nobreak\ {\footnotesize \NWlink{nuweb115}{115}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene graph controller constructor}\nobreak\ {\footnotesize \NWlink{nuweb96b}{96b}, \ldots\ }$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize \NWlink{nuweb99}{99}, \ldots\ }$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene graph controller slots}\nobreak\ {\footnotesize \NWlink{nuweb112}{112}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb194b}{194b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene graph controller, inheriting from~\texttt{QAbstractItemModel}.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller}
% \label{editor:lst:scene-graph-controller}
\end{figure}

\newthought{As at this point the functionality} of the scene graph controller is
not fully known, the constructor simply initializes its parent class and an
empty list of scenes.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap26}\raggedright\small
\NWtarget{nuweb96b}{} $\langle\,${\itshape Scene graph controller constructor}\nobreak\ {\footnotesize {96b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, parent=None):
    """Constructor.

    :param parent: The parent of the current view model within
                    the scene graph.
    :type parent:  qde.editor.application.SceneGraphController
    """

    super(SceneGraphController, self).__init__(parent)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb96b}{96b}\NWlink{nuweb98}{, 98}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the scene graph controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Constructor}
% \label{editor:lst:scene-graph-controller:constructor}
\end{figure}

\newthought{The scene graph controller holds and manages scene data.} Therefore
it needs to have at least a root node. As the controller manages both, domain
models and the view models, it needs to create both models.

Due to the dependencies of other components this cannot be done within the
constructor, as components depending on the scene graph controller may not be
listening to its signals at this point. Therefore this is done in a separate
method called~\verb=add_root_node=.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap27}\raggedright\small
\NWtarget{nuweb97a}{} $\langle\,${\itshape Scene graph controller add root node}\nobreak\ {\footnotesize {97a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def add_root_node(self):
    """Add a root node to the data structure.
    """

    if self.root_node is None:
        root_node = scene_domain.SceneModel()
        self.view_root_node = scene_gui_domain.SceneGraphViewModel(
            row=0,
            domain_object=root_node,
            name=QtCore.QCoreApplication.translate(
                __class__.__name__, 'Root scene'
            )
        )
        self.do_add_scene.emit(root_node)
        self.layoutChanged.emit()
        self.logger.debug("Added root node")
    else:
        self.logger.warn((
            "Not (re-) adding root node, already"
            "present!"
        ))
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb198b}{198b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A method to add the root node from within the scene graph controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Methods}
% \label{editor:lst:scene-graph-controller:methods:add-root-node}
\end{figure}

The root scene can now be added by the main application, as all necessary
components are set up.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap28}\raggedright\small
\NWtarget{nuweb97b}{} $\langle\,${\itshape Add root node for main application}\nobreak\ {\footnotesize {97b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.scene_graph_controller.add_root_node()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb88a}{88a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The root node of the scene graph being added by the main application.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:add-root-node}
\end{figure}

\newthought{The scene graph controller must also provide the header data,} which
is used to display the header within the view (due to the usage of the Qt view
model~\cite{qt-mvp-2017}). As header data the name of the
scenes as well as the number of nodes a scene contains shall be displayed.

\begin{figure}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap29}\raggedright\small
\NWtarget{nuweb98}{} $\langle\,${\itshape Scene graph controller constructor}\nobreak\ {\footnotesize {98}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.header_data = [
        QtCore.QCoreApplication.translate(
            __class__.__name__, 'Name'
        ),
        QtCore.QCoreApplication.translate(
            __class__.__name__, '# Nodes'
        )
    ]
    self.root_node = None
    self.view_root_node = None|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb96b}{96b}\NWlink{nuweb98}{, 98}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Initialization of the header data and the root node of the scene graph.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Constructor}
% \label{editor:lst:scene-graph-controller:constructor:header-data}
\end{figure}

\newthought{As QAbstractItemModel is used as a basis} for the scene graph
controller, some methods must be implemented at very least:~\enquote{When
sub classing QAbstractItemModel, at the very least you must implement index(),
parent(), rowCount(), columnCount(), and data(). These functions are used in all
read-only models, and form the basis of editable
models.}\footref{footnote:qabstractitemmodel}

\newthought{The method index} returns the position of an item in the (data-)
model for a given row and column below a parent item.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap30}\raggedright\small
\NWtarget{nuweb99}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {99}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def index(self, row, column, parent=QtCore.QModelIndex()):
    """Return the index of the item in the model specified by the
    given row, column and parent index.

    :param row: The row for which the index shall be returned.
    :type  row: int
    :param column: The column for which the index shall be
                   returned.
    :type column:  int
    :param parent: The parent index of the item in the model. An
                   invalid model index is given as the default
                   parameter.
    :type parent: QtQore.QModelIndex

    :return: the model index based on the given row, column and
             the parent index.
    :rtype: QtCore.QModelIndex
    """

    if not parent.isValid():
        return self.createIndex(row, column, self.view_root_node)

    parent_node = parent.internalPointer()
    child_nodes = parent_node.children()

    # It may happen, that the index is called at the same time as
    # a node is being deleted respectively was deleted. In this
    # case an invalid index is returned.
    try:
        child_node  = child_nodes[row]
        return self.createIndex(row, column, child_node)

    except IndexError:
        return QtCore.QModelIndex()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of QAbstractItemModel's index method for the scene graph
  controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Methods}
% \label{editor:lst:scene-graph-controller:methods:index}
\end{figure}

\newthought{The method parent} returns the parent item of an item identified by
a provided index. If that index is invalid, an invalid index is returned as
well.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap31}\raggedright\small
\NWtarget{nuweb100}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {100}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def parent(self, model_index):
    """Return the parent of the model item with the given index.
    If the item has no parent, an invalid QModelIndex is returned.

    :param model_index: The model index which the parent model
                        index shall be derived for.
    :type model_index:  int

    :return: the model index of the parent model item for the
             given model index.
    :rtype:  QtCore.QModelIndex
    """

    # self.logger.debug("Getting parent")

    if not model_index.isValid():
        # self.logger.debug("No valid index for parent")
        return QtCore.QModelIndex()

    # The internal pointer of the the model index returns a
    # scene graph view model.
    node = model_index.internalPointer()
    if node and node.parent() is not None:
        # self.logger.debug("Index for parent")
        return self.createIndex(
            node.parent().row, 0, node.parent()
        )
    else:
        # self.logger.debug("Index for root")
        return QtCore.QModelIndex()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of QAbstractItemModel's parent method for the scene graph
  controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Methods}
% \label{editor:lst:scene-graph-controller:methods:parent}
\end{figure}

\newthought{Implementing the columnCount and rowCount methods} is straight
forward. The former returns simply the number of columns, in this case the
number of headers, therefore 2.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap32}\raggedright\small
\NWtarget{nuweb101}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {101}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def columnCount(self, parent):
    """Return the number of columns for the children of the given
    parent.

    :param parent: The index of the item in the scene graph, which
                   the column count shall be returned for.
    :type  parent: QtCore.QModelIndex

    :return: the number of columns for the children of the given
             parent.
    :rtype:  int
    """

    column_count = len(self.header_data) - 1

    return column_count
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of QAbstractItemModel's columnCount method for the scene
  graph controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Methods}
% \label{editor:lst:scene-graph-controller:methods:column-count}
\end{figure}

The method~\verb=rowCount= returns the number of nodes for a given parent
item (identified by its index within the data model).

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap33}\raggedright\small
\NWtarget{nuweb102}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {102}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def rowCount(self, parent):
    """Return the number of rows for the children of the given
    parent.

    :param parent: The index of the item in the scene graph, which
                   the row count shall be returned for.
    :type  parent: QtCore.QModelIndex

    :return: the number of rows for the children of the given
             parent.
    :rtype:  int
    """

    if not parent.isValid():
        row_count = 1
    else:
        # Get the actual object stored by the parent. In this case
        # it is a SceneGraphViewModel.
        node = parent.internalPointer()

        if node is None:
            self.logger.debug("Parent (node) is not valid")
            row_count = 1
        else:
            row_count = len(node.children())

    return row_count
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of QAbstractItemModel's rowCount method for the scene
  graph controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Methods}
% \label{editor:lst:scene-graph-controller:methods:row-count}
\end{figure}

\newthought{The last method} that has to be implemented due to the usage
of~\verb=QAbstractItemModel=, is the~\verb=data= method. It returns the data for
an item identified by the given index for the given role.

A role indicates what type of data is provided. Currently the only role
considered is the display of models (further information may be found
at~\url{http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum}).

Depending on the column of the model index, the method returns either the name
of the scene graph node or the number of nodes a scene contains.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap34}\raggedright\small
\NWtarget{nuweb103}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {103}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def data(self, model_index, role=QtCore.Qt.DisplayRole):
    """Return the data stored under the given role for the item
    referred by the index.

    :param model_index: The (data-) model index of the item.
    :type model_index: int
    :param role: The role which shall be used for representing
                 the data. The default (and currently only
                 supported) is displaying the data.
    :type role:  QtCore.Qt.DisplayRole

    :return: the data stored under the given role for the item
             referred by the given index.
    :rtype:  str
    """

    if not model_index.isValid():
        self.logger.debug("Model index is not valid")
        return None

    # The internal pointer of the model index returns a scene
    # graph view model.
    node = model_index.internalPointer()

    if node is None:
        self.logger.debug("Node is not valid")
        return None

    if role == QtCore.Qt.DisplayRole:
        # Return either the name of the scene or its number of
        # nodes.
        column = model_index.column()

        if column == 0:
            return node.name
        elif column == 1:
            return node.node_count
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of QAbstractItemModel's data method for the scene
  graph controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Methods}
% \label{editor:lst:scene-graph-controller:methods:data}
\end{figure}

\newthought{In addition to the above mentioned methods,}
the~\verb=QAbstractItemModel= offers the method~\verb=headerData=,
which~\enquote{returns the data for the given role and section in the header
with the specified
orientation.}\footnote{\url{http://doc.qt.io/qt-5/qabstractitemmodel.html\#headerData}}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap35}\raggedright\small
\NWtarget{nuweb104a}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {104a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def headerData(self, section, orientation=QtCore.Qt.Horizontal,
               role=QtCore.Qt.DisplayRole):
    """Return the data for the given role and section in the
    header with the specified orientation.

    Currently vertical is the only supported orientation. The
    only supported role is DisplayRole. As the sections correspond
    to the header, there are only two supported sections: 0 and 1.
    If one of those parameters is not within the described values,
    None is returned.

    :param section: the section in the header. Currently only 0
                    and 1 are supported.
    :type  section: int
    :param orientation: the orientation of the display. Currently
                        only Horizontal is supported.
    :type orientation:  QtCore.Qt.Orientation
    :param role: The role which shall be used for representing
                 the data. The default (and currently only
                supported) is displaying the data.
    :type role:  QtCore.Qt.DisplayRole

    :return: the header data for the given section using the
             given role and orientation.
    :rtype:  str
    """

    if (
            orientation == QtCore.Qt.Horizontal  and
            role        == QtCore.Qt.DisplayRole and
            section     in [0, 1]
    ):
        return self.header_data[section]
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of QAbstractItemModel's headerData method for the scene
  graph controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller $\rightarrow$
  Methods}
% \label{editor:lst:scene-graph-controller:methods:header-data}
\end{figure}

One thing, that may stand out, is, that the above defined~\verb=data= method
returns the number of graph nodes within a scene by accessing
the~\verb=node_count= property of the~\emph{scene graph view model}.

The~\emph{scene graph view model} does therefore need to keep track of the nodes it
contains, in form of a list, analogous to the domain model.

It does not make sense however to use the list of nodes from the domain model,
as the view model will hold references to graphical objects where as the domain
model holds only pure data objects. Therefore it is necessary, that the scene
view model keeps track of its nodes separately.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap36}\raggedright\small
\NWtarget{nuweb104b}{} $\langle\,${\itshape Scene graph view model constructor}\nobreak\ {\footnotesize {104b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.nodes = []
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb95}{95}\NWlink{nuweb104b}{, 104b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb94b}{94b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Scene graph view models hold references to the nodes they contain.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view model $\rightarrow$
  Constructor}
% \label{editor:lst:scene-graph-view-model:constructor:nodes}
\end{figure}

\newthought{The method node\_count} then simply returns the length of the node
list.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap37}\raggedright\small
\NWtarget{nuweb105a}{} $\langle\,${\itshape Scene graph view model methods}\nobreak\ {\footnotesize {105a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|property
def node_count(self):
    """Return the number of nodes that this scene contains."""

    return len(self.nodes)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb105a}{105a}\NWlink{nuweb193c}{, 193c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb94b}{94b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The number of (graphical) nodes which a scene graph view model contains
  implemented as a property.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view model $\rightarrow$
  Methods}
% \label{editor:lst:scene-graph-view-model:methods:node-count}
\end{figure}

The scene graph controller can now be set up by the main application controller.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap38}\raggedright\small
\NWtarget{nuweb105b}{} $\langle\,${\itshape Set up controllers for main application}\nobreak\ {\footnotesize {105b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.scene_graph_controller = scene.SceneGraphController(self)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb105b}{105b}\NWlink{nuweb137b}{, 137b}\NWlink{nuweb181a}{, 181a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90b}{90b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene graph controller gets initialized within the main application.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:scene-graph-controller}
\end{figure}

At this point data structures in terms of a (data-) model and a view model
concerning the scene graph are implemented. Further a controller for handling
the flow of the data for both models is implemented.

\newthought{What is still missing,} is the actual representation of the scene
graph in terms of a view. Qt offers a plethora of widgets for implementing
views. One such widget is~\verb=QTreeView=, which~\enquote{implements a tree
representation of items from a model. This class is used to provide standard
hierarchical lists that were previously provided by the QListView class, but
using the more flexible approach provided by Qt's model/view
architecture.}~\footnote{fn:f377826acb87691:http://doc.qt.io/qt-5/qtreeview.html\#details}
Therefore~\verb=QTreeView= is used as basis for the scene graph view.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap39}\raggedright\small
\NWtarget{nuweb105c}{} $\langle\,${\itshape Scene graph view declarations}\nobreak\ {\footnotesize {105c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\hbox{$\langle\,${\itshape Scene graph view decorators}\nobreak\ {\footnotesize \NWlink{nuweb195b}{195b}}$\,\rangle$}|
class SceneGraphView(QtWidgets.QTreeView):
    """The scene graph view widget.
    A widget for displaying and managing the scene graph.
    """

    |\hbox{$\langle\,${\itshape Scene graph view signals}\nobreak\ {\footnotesize \NWlink{nuweb108b}{108b}, \ldots\ }$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene graph view constructor}\nobreak\ {\footnotesize \NWlink{nuweb106a}{106a}, \ldots\ }$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene graph view methods}\nobreak\ {\footnotesize \NWlink{nuweb108a}{108a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene graph view slots}\nobreak\ {\footnotesize \NWlink{nuweb107}{107}, \ldots\ }$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb195a}{195a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Scene graph view, based on Qt's QTreeView.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view}
% \label{editor:lst:scene-graph-view}
\end{figure}

\newthought{The constructor} simply initializes its parent class, as at this
point the functionality of the scene graph view is not fully known.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap40}\raggedright\small
\NWtarget{nuweb106a}{} $\langle\,${\itshape Scene graph view constructor}\nobreak\ {\footnotesize {106a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, parent=None):
    """Constructor.

    :param parent: The parent of the current view widget.
    :type parent:  QtCore.QObject
    """

    super(SceneGraphView, self).__init__(parent)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb106a}{106a}\NWlink{nuweb109b}{, 109b}\NWlink{nuweb110}{, 110}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the scene graph view.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Constructor}
% \label{editor:lst:scene-graph-view:constructor}
\end{figure}

\newthought{For being able to display something,} the scene graph view needs a
controller to work with. In terms of Qt, the controller is called a model, as
due its model/view architecture. This model may although not be set too early,
as otherwise problems arise. It may only then be added, when the depending
components are properly initialized, e.g.\ when the root node has been added.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap41}\raggedright\small
\NWtarget{nuweb106b}{} $\langle\,${\itshape Set model for scene graph view}\nobreak\ {\footnotesize {106b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.main_window.scene_graph_view.setModel(
    self.scene_graph_controller
)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb88a}{88a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene graph controller is being set as the scene graph view's
  model.
  \newline{}\newline{}Editor $\rightarrow$ Main application
  $\rightarrow$ Constructor}
% \label{editor:lst:main-application:constructor:set-model}
\end{figure}

\newthought{But scenes shall not only be displayed,} instead it shall be
possible to work with them. What shall be achieved, are three things:
\begin{enumerate*}
  \item Adding and removing scenes,
  \item renaming scenes and
  \item switching between scenes.
\end{enumerate*}

\newthought{To switch between scenes} it is necessary to emit what scene was
selected. This is needed to tell the other components, such as the node graph
for example, that the scene has changed.

Through the~\verb=selectionChanged= signal the scene graph view already provides
a possibility to detect if another scene was selected. This signal emits an item
selection in terms of model indices although.

As this is very view- and model-specific, it would be easier for other
components if the selected scene is emitted directly. To emit the selected index
of the currently selected scene directly, the slot~\verb=on_tree_item_selected=
is introduced.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap42}\raggedright\small
\NWtarget{nuweb107}{} $\langle\,${\itshape Scene graph view slots}\nobreak\ {\footnotesize {107}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(QtCore.QItemSelection, QtCore.QItemSelection)
def on_tree_item_selected(self, selected, deselected):
    """Slot which is called when the selection within the scene
    graph view is changed.

    The previous selection (which may be empty) is specified by
    the deselected parameter, the new selection by the selected
    parameter.

    This method emits the selected scene graph item as scene
    graph view model.

    :param selected: The new selection of scenes.
    :type  selected: QtCore.QModelIndex
    :param deselected: The previous selected scenes.
    :type  deselected: QtCore.QModelIndex
    """

    selected_item = selected.first()
    selected_index = selected_item.indexes()[0]
    self.do_select_item.emit(selected_index)
    self.logger.debug(
        "Tree item was selected: %s" % selected_index
    )|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb107}{107}\NWlink{nuweb111}{, 111}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Slot which is called when the selection within the scene graph view is
  changed.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Slots}
% \label{editor:lst:scene-graph-view:slots:on-tree-item-selected}
\end{figure}

The~\verb=on_tree_item_selected= slot needs to be triggered as soon as the
selection is changed. This is done by connecting the slot with the
\verb=selectionChanged= signal. The~\verb=selectionChanged= signal is however
not directly accessible, it is only accessible through the selection model of
the scene graph view (which is given by the usage of~\verb=QTreeView=). The
selection model can although only be accessed when setting the data model of the
view, which needs therefore to be expanded.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap43}\raggedright\small
\NWtarget{nuweb108a}{} $\langle\,${\itshape Scene graph view methods}\nobreak\ {\footnotesize {108a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def setModel(self, model):
    """Set the model for the view to present.

    This method is only used for being able to use the selection
    model's selectionChanged method and setting the current
    selection to the root node.

    :param model: The item model which the view shall present.
    :type  model: QtCore.QAbstractItemModel
    """

    super(SceneGraphView, self).setModel(model)

    # Use a slot to emit the selected scene graph view model upon
    # the selection of a tree item
    selection_model = self.selectionModel()
    selection_model.selectionChanged.connect(
        self.on_tree_item_selected
    )

    # Set the index to the first node of the model
    self.setCurrentIndex(model.index(0, 0))
    self.logger.debug("Root node selected")|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The setModel method, provided by QTreeView's interface, which is begin
  overwritten for being able to trigger the on\_tree\_item\_selected slot
  whenever the selection in the scene graph view has changed.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Methods}
% \label{editor:lst:scene-graph-view:methods:set-model}
\end{figure}

As stated in the above code fragment,~\verb=on_tree_item_selected= emits another
signal containing a reference to the currently selected scene, which needs to be
implemented as well.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap44}\raggedright\small
\NWtarget{nuweb108b}{} $\langle\,${\itshape Scene graph view signals}\nobreak\ {\footnotesize {108b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_select_item = QtCore.pyqtSignal(QtCore.QModelIndex)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb108b}{108b}\NWlink{nuweb109a}{, 109a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The signal that is being emitted when a scene within the scene graph
view was selected. Note that the signal includes the model index of the selected
item.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Signals}
% \label{editor:lst:scene-graph-view:signals:do-select-item}
\end{figure}

\newthought{Adding and removing of a scene} are implemented in a similar manner
as the selection of an item was implemented. However, the tree widget does not
provide direct signals for those cases as it is the case when selecting a tree
item, instead own signals, slots and actions have to be used.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap45}\raggedright\small
\NWtarget{nuweb109a}{} $\langle\,${\itshape Scene graph view signals}\nobreak\ {\footnotesize {109a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_add_item = QtCore.pyqtSignal(QtCore.QModelIndex)
do_remove_item = QtCore.pyqtSignal(QtCore.QModelIndex)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb108b}{108b}\NWlink{nuweb109a}{, 109a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Signals that get emitted whenever a scene is added or removed.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Signals}
% \label{editor:lst:scene-graph-view:signals:do-add-remove-item}
\end{figure}

An action gets triggered, typically by hovering over some item (in terms of a
context menu for example) or by pressing a defined keyboard shortcut. For the
adding and the removal, a keyboard shortcut will be used.

\newthought{Adding of a scene item} shall happen when pressing the~\verb=a= key
on the keyboard.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap46}\raggedright\small
\NWtarget{nuweb109b}{} $\langle\,${\itshape Scene graph view constructor}\nobreak\ {\footnotesize {109b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    new_action_label = QtCore.QCoreApplication.translate(
        __class__.__name__, 'New scene'
    )
    new_action = QtWidgets.QAction(new_action_label, self)
    new_action.setShortcut(Qt.QKeySequence('a'))
    new_action.setShortcutContext(QtCore.Qt.WidgetShortcut)
    new_action.triggered.connect(self.on_new_tree_item)
    self.addAction(new_action)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb106a}{106a}\NWlink{nuweb109b}{, 109b}\NWlink{nuweb110}{, 110}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Introduction of an action for adding a new scene, which reacts upon
  the~\enquote{A} key being pressed on the keyboard.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Constructor}
% \label{editor:lst:scene-graph-view:constructor:new-action}
\end{figure}

\newthought{The removal of a selected node} shall be triggered upon the press of
the~\verb=delete= and the~\verb=backspace= key on the keyboard.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap47}\raggedright\small
\NWtarget{nuweb110}{} $\langle\,${\itshape Scene graph view constructor}\nobreak\ {\footnotesize {110}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    remove_action_label = QtCore.QCoreApplication.translate(
        __class__.__name__, 'Remove selected scene(s)'
    )
    remove_action = QtWidgets.QAction(remove_action_label, self)
    remove_action.setShortcut(Qt.QKeySequence('Delete'))
    remove_action.setShortcut(Qt.QKeySequence('Backspace'))
    remove_action.setShortcutContext(QtCore.Qt.WidgetShortcut)
    remove_action.triggered.connect(self.on_tree_item_removed)
    self.addAction(remove_action)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb106a}{106a}\NWlink{nuweb109b}{, 109b}\NWlink{nuweb110}{, 110}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Introduction of an action for removing a new scene, which reacts upon
  the~\enquote{delete} key being pressed on the keyboard.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Constructor}
% \label{editor:lst:scene-graph-view:constructor:remove-action}
\end{figure}

As can be seen in the two above listings, the~\verb=triggered= signals are
connected with a corresponding slot. All these slots do is emitting another
signal, but this time it contains a scene graph view model, which may be used by
other components, instead of a model index.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap48}\raggedright\small
\NWtarget{nuweb111}{} $\langle\,${\itshape Scene graph view slots}\nobreak\ {\footnotesize {111}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot()
def on_new_tree_item(self):
    """Slot which is called when a new tree item was added by the
    scene graph view.

    This method emits the selected scene graph item as new tree
    item in form of a scene graph view model.
    """

    selected_indexes = self.selectedIndexes()

    # Sanity check: is actually an item selected?
    if len(selected_indexes) > 0:
        selected_item = selected_indexes[0]
        self.do_add_item.emit(selected_item)
        |\hbox{$\langle\,${\itshape Scene graph view log tree item added}\nobreak\ {\footnotesize \NWlink{nuweb119b}{119b}}$\,\rangle$}|

|\normalfont{}\fontfamily{}|QtCore.pyqtSlot()
def on_tree_item_removed(self):
    """Slot which is called when a one or multiple tree items
    were removed by the scene graph view.

    This method emits the removed scene graph item in form of
    scene graph view models.
    """

    selected_indexes = self.selectedIndexes()

    # Sanity check: is actually an item selected? And has that
    # item a parent?
    # We only allow removal of items with a valid parent, as we
    # do not want to have the root item removed.
    if len(selected_indexes) > 0:
        selected_item = selected_indexes[0]
        if selected_item.parent().isValid():
            self.do_remove_item.emit(selected_item)
            |\hbox{$\langle\,${\itshape Scene graph view log tree item removed}\nobreak\ {\footnotesize \NWlink{nuweb119c}{119c}}$\,\rangle$}|
        else:
            self.logger.warn("Root scene cannot be deleted")
    else:
        self.logger.warn('No item selected for removal')
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb107}{107}\NWlink{nuweb111}{, 111}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Slots which emit themselves a signal whenever a scene is added from the
  scene graph or removed respectively.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Slots}
% \label{editor:lst:scene-graph-view:slots:on-tree-item-added-removed}
\end{figure}

\newthought{One of the mentioned other components} is the
scene graph controller. He needs to be informed whenever a scene was added,
removed or selected, so that he is able to manage his data model
correspondingly.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap49}\raggedright\small
\NWtarget{nuweb112}{} $\langle\,${\itshape Scene graph controller slots}\nobreak\ {\footnotesize {112}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(QtCore.QModelIndex)
def on_tree_item_added(self, selected_item):
    # TODO: Document method.

    self.insertRows(0, 1, selected_item)
    self.logger.debug("Added new scene")

|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(QtCore.QModelIndex)
def on_tree_item_removed(self, selected_item):
    # TODO: Document method.

    if not selected_item.isValid():
        self.logger.warn(
            "Selected scene is not valid, not removing"
        )
        return False

    row = selected_item.row()
    parent = selected_item.parent()
    self.removeRows(row, 1, parent)

|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(QtCore.QModelIndex)
def on_tree_item_selected(self, selected_item):
    # TODO: Document method.

    if not selected_item.isValid():
        self.logger.warn("Selected scene is not valid")
        return False

    selected_scene_view_model = selected_item.internalPointer()
    selected_scene_domain_model  = selected_scene_view_model.\
        domain_object
    self.do_select_scene.emit(selected_scene_domain_model)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Slots to handle adding, removing and selecting of tree items within the
  scene graph. The slots take a model index as argument (coming from
  QAbstractItemModel). This is analogous to the scene graph view.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller
  $\rightarrow$ Slots}
% \label{editor:lst:scene-graph-controller:slots:on-tree-item-added-removed-selected}
\end{figure}

\newthought{Despite having the slots for adding, removing and selecting} scene
graph items implemented, the actual methods for adding and removing
scenes,~\verb=on_tree_item_added= and~\verb=on_tree_item_removed=, are still
missing.

When inserting a new scene graph item, actually a row must be inserted, as the
data model (Qt's) is using rows to represent the data. At the same time the
controller has to keep track of the domain model.

As can be seen in the implementation below, it is not necessary to add the
created model instances to a list of nodes, the usage
of~\verb=QAbstractItemModel= keeps already track of this.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap50}\raggedright\small
\NWtarget{nuweb113}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {113}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def insertRows(self, row, count, parent=QtCore.QModelIndex()):
    # TODO: Document method.

    if not parent.isValid():
        return False

    parent_node = parent.internalPointer()
    self.beginInsertRows(parent, row, row + count - 1)
    domain_model  = scene_domain.SceneModel(
        parent_node.domain_object
    )
    view_model = scene_gui_domain.SceneGraphViewModel(
        row=row,
        domain_object=domain_model,
        parent=parent_node
    )
    self.endInsertRows()

    self.layoutChanged.emit()
    self.do_add_scene.emit(domain_model)

    return True
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Method for adding new scenes in terms of a domain model as well as a
  scene graph view model.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller
  $\rightarrow$ Methods}
% \label{editor:lst:scene-graph-controller:methods:insert-rows}
\end{figure}

The same logic applies when removing a scene.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap51}\raggedright\small
\NWtarget{nuweb114a}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {114a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def removeRows(self, row, count, parent=QtCore.QModelIndex()):
    # TODO: Document method.

    if not parent.isValid():
        self.logger.warn("Cannot remove rows, parent is invalid")
        return False

    self.beginRemoveRows(parent, row, row + count - 1)
    parent_node = parent.internalPointer()
    node_index = parent.child(row, parent.column())
    node       = node_index.internalPointer()
    node.setParent(None)
    # TODO: parent_node.child_nodes.remove(node)
    self.endRemoveRows()
    self.logger.debug((
        "Removed {0} rows starting from {1}"
        "for parent {2}. Children: {3}"
    ).format(
        count,row, parent_node,
        len(parent_node.children())
    ))

    self.layoutChanged.emit()
    self.do_remove_scene.emit(node.domain_object)

    return True
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Method for removing scenes. Note that this is mainly done by getting
  the object related to the given model index and setting the parent of that
  object to a nil object.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller
  $\rightarrow$ Methods}
% \label{editor:lst:scene-graph-controller:methods:remove-rows}
\end{figure}

\newthought{As before, the main application needs connect the components,} in
this case the scene graph view with the scene graph controller.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap52}\raggedright\small
\NWtarget{nuweb114b}{} $\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize {114b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.main_window.scene_graph_view.do_add_item.connect(
    self.scene_graph_controller.on_tree_item_added
)
self.main_window.scene_graph_view.do_remove_item.connect(
    self.scene_graph_controller.on_tree_item_removed
)
self.main_window.scene_graph_view.do_select_item.connect(
    self.scene_graph_controller.on_tree_item_selected
)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb114b}{114b}\NWlink{nuweb143c}{, 143c}\NWlink{nuweb189b}{, 189b}\NWlink{nuweb191b}{, 191b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90c}{90c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene graph view's signals for adding, removing and selecting a
  scene are connected to the corresponding slots from the scene graph
  controller. Or, in other words, the controller/data reacts to actions invoked
  by the user interface.
  \newline{}\newline{}Editor $\rightarrow$ Main application
  $\rightarrow$ Constructor}
% \label{editor:lst:main-application:constructor:connect-scene-graph-view}
\end{figure}

\newthought{To inform other components about the new models}, such as the node
graph for example, the scene graph controller emits signals when a scene is
being added, removed or selected respectively.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap53}\raggedright\small
\NWtarget{nuweb115}{} $\langle\,${\itshape Scene graph controller signals}\nobreak\ {\footnotesize {115}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_add_scene    = QtCore.pyqtSignal(scene_domain.SceneModel)
do_remove_scene = QtCore.pyqtSignal(scene_domain.SceneModel)
do_select_scene = QtCore.pyqtSignal(scene_domain.SceneModel)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Signals emitted by the scene graph controller, in terms of domain
  models, whenever a scene is added, removed or selected.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph controller
  $\rightarrow$ Signals}
% \label{editor:lst:scene-graph-controller:signals}
\end{figure}

% TODO: EDIT MODELS
% For being able edit the nodes of the scene graph and to have a custom header
% displayed, further methods have to be implemented: ``To enable editing in your
% model, you must also implement setData(), and reimplement flags() to ensure that
% ItemIsEditable is returned. You can also reimplement headerData() and
% setHeaderData() to control the way the headers for your model are presented.''

\newthought{At this point it is possible to manage scenes} in terms of adding
and removing them. The scenes are added to (or removed from respectively) the
graphical user interface as well as the data structure.

So far the application (or rather the scene graph) seems to be working as
intended. But how does one ensure, that it really does? Without a doubt, unit
and integration tests are one of the best instruments to ensure functionality of
code.

As stated before,
in~\autoref{sec:literate-programming}~\enquote{\nameref{sec:literate-programming}},
it was an intention of this project to develop the application test driven. Due
to the required amount of work when developing test driven, it was abstained
from this intention.

But nevertheless, it would be very handy to have at least some idea what the
code is doing at certain places and at certain times.

One of the simplest approaches to achieve this, is a verbose output at various
places of the application, which may be as simple as using Python's~\verb=print=
function. Using the~\verb=print= function may allow printing something
immediately, but it lacks of flexibility and demands each time a bit of effort
to format the output accordingly (e.g.\ adding the class and the function name
and so on).

Python's logging facility provides much more functionality while being able to
keep things simple as well --- if needed. The usage of the logging facility to
log messages throughout the application may later even be used to implement a
widget which outputs those messages. So logging using Python's logging facility
will be implemented and applied for being able to have feedback when needed.
% -*- mode: latex; coding: utf-8 -*-

\chapter{Logging}
\label{appendix:chap:logging}

\newthought{It is always very useful} to have a facility which allows tracing of
errors or even just the flow of an application. Logging does allow such aspects
by outputting text messages to a defined output, such as STDERR, STDOUT, streams
or files.

\newthought{Logging shall be provided on a class-basis}, meaning that each class
(which wants to log something) needs to instantiate a logger and use a
corresponding handler.

\newthought{Logging is a very central aspect of the application.} It is the task
of the main application to set up the logging facility which may then be used by
other classes through a decorator.

\newthought{The main application shall therefore set up} the logging facility as
follows:
\begin{itemize}
  \item Use either an external logging configuration or the default logging
        configuration.
  \item When using an external logging configuration
    \begin{itemize}
      \item The location of the external logging configuration may be set by the
            environment variable~\verb=QDE_LOG_CFG=.
      \item Is no such environment variable set, the configuration file is
            assumed to be named~\verb=logging.json= and to reside in the
            application's main directory.
    \end{itemize}
  \item When using no external logging configuration, the default logging
        configuration defined by~\verb=basicConfig= is used.
  \item Always set a level when using no external logging configuration, the
        default being~\verb=INFO=.
\end{itemize}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap54}\raggedright\small
\NWtarget{nuweb117a}{} $\langle\,${\itshape Main application methods}\nobreak\ {\footnotesize {117a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def setup_logging(self,
                  default_path='logging.json',
                  default_level=logging.INFO):
    """Setup logging configuration"""

    env_key  = 'QDE_LOG_CFG'
    env_path = os.getenv(env_key, None)
    path     = env_path or default_path

    if os.path.exists(path):
        with open(path, 'rt') as f:
            config = json.load(f)
            logging.config.dictConfig(config)
    else:
        logging.basicConfig(level=default_level)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb87b}{87b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A method for setting up the logging, provided by the main application.
  If there exists an external configuration file for logging, this file is used
  for configuring the logging facility. Otherwise the standard configuration is
  used.
  \newline{}\newline{}Editor $\rightarrow$ Main application
  $\rightarrow$ Methods}
% \label{logging:lst:main-application:methods:setup-logging}
\end{figure}

\newthought{For not having only basic logging available}, a logging
configuration is defined. The logging configuration provides three handlers: a
console handler, which logs debug messages to STDOUT, a info file handler, which
logs informational messages to a file named~\verb=info.log=, and a error file
handler, which logs errors to a file named~\verb=error.log=. The default level
is set to debug and all handlers are used. This configuration allows to get an
arbitrarily named logger which uses that configuration.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap55}\raggedright\small
\NWtarget{nuweb117b}{} $\langle\,${\itshape Set up internals for main application}\nobreak\ {\footnotesize {117b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}

self.setup_logging()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb88b}{88b}\NWlink{nuweb117b}{, 117b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb88a}{88a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Set up of the logging from within the main application class.
  \newline{}\newline{}Editor $\rightarrow$ Main application
  $\rightarrow$ Constructor}
% \label{logging:lst:main-application:constructor:setup-logging}
\end{figure}

\newthought{The consequence of providing} logging on a class basis, as stated
before, is, that each class has to instantiate a logging instance. To prevent
the repetition of the same code fragment over and over, Python's decorator
pattern is used~\footnote{\url{https://www.python.org/dev/peps/pep-0318/}}.

\newthought{The decorator} will be available as a method
named~\verb=with_logger=. The method has the following functionality.

\begin{itemize}
  \item Provide a name based on the current module and class.
    \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap56}\raggedright\small
\NWtarget{nuweb118a}{} $\langle\,${\itshape Set logger name}\nobreak\ {\footnotesize {118a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
logger_name = "{module_name}.{class_name}".format(
    module_name=cls.__module__,
    class_name=cls.__name__
)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb200a}{200a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\item Provide an easy to use interface for logging.
    \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap57}\raggedright\small
\NWtarget{nuweb118b}{} $\langle\,${\itshape Logger interface}\nobreak\ {\footnotesize {118b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
cls.logger = logging.getLogger(logger_name)

return cls|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb200a}{200a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\end{itemize}

\newthought{The usage of the decorator}~\verb=with_logger= is shown in the
example in the following listing.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap58}\raggedright\small
\NWtarget{nuweb119a}{} $\langle\,${\itshape With logger example}\nobreak\ {\footnotesize {119a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
from qde.editor.foundation import common

|\normalfont{}\fontfamily{}|common.with_logger
def SomeClass(object):
    """This class provides literally nothing and is used only to
    demonstrate the usage of the logging decorator."""

    def some_method():
        """This method does literally nothing and is used only to
        demonstrate the usage of the logging decorator."""

        self.logger.debug(("I am some logging entry used for"
                           "demonstration purposes only."))

|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{An example of how to use the logging decorator in a class.}
% \label{logging:lst:logging-example}
\end{figure}

\newthought{The logging facility may now be used} wherever it is useful to log
something. Such a place is for example the adding and removal of scenes in the
scene graph view.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap59}\raggedright\small
\NWtarget{nuweb119b}{} $\langle\,${\itshape Scene graph view log tree item added}\nobreak\ {\footnotesize {119b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.logger.debug("A new scene graph item was added.")
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb111}{111}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene graph view logs a corresponding message whenever an item is
  added from the scene graph. Note, that this logging only happens
  in~\emph{debug} mode.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Methods}
% \label{logging:lst:scene-graph-view:methods:log-adding}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap60}\raggedright\small
\NWtarget{nuweb119c}{} $\langle\,${\itshape Scene graph view log tree item removed}\nobreak\ {\footnotesize {119c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.logger.debug((
    "The scene graph item at row {row} "
    "and column {column} was removed."
).format(
    row=selected_item.row(),
    column=selected_item.column()
))
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb111}{111}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene graph view logs a corresponding message whenever an item is
  removed from the scene graph. Note, that this logging only happens
  in~\emph{debug} mode.
  \newline{}\newline{}Editor $\rightarrow$ Scene graph view
  $\rightarrow$ Methods}
% \label{logging:lst:scene-graph-view:methods:log-removal}
\end{figure}

Whenever the \textit{a} or the \textit{delete} key is being pressed now, when
the scene graph view is focused, the corresponding log messages appear in the
standard output, hence the console.

Now, having the scene graph component as well as an interface to log messages
throughout the application implemented, the next component may be approached.

\newthought{Scenes build the basis} for the scene graph and the node graph as
well. This is a good point to begin with the implementation of the node graph.

% -*- mode: latex; coding: utf-8 -*-

\chapter{Node graph}
\label{appendix:chap:node-graph}

\newthought{The functionality of the node graph} is, as its name states, to
represent a data structure composed of nodes and edges. Each scene from the
scene graph is represented within the node graph as such a data structure.

\newthought{The nodes are the building blocks} of a real time animation. They
represent different aspects, such as scenes themselves, time line clips, models,
cameras, lights, materials, generic operators and effects. These aspects are
only examples (coming from~\citetitle[p. 30 and 31]{osterwalder-qde-2016}) as
the node structure will be expandable for allowing the addition of new nodes.

The implementation of the scene graph component was relatively straightforward
partly due to its structure and partly due to the used data model and
representation. The node graph component however, seems to be a bit more complex.

\newthought{To get a first overview and to manage its complexity}, it might be
good to identify its sub components first before implementing them. When
thinking about the implementation of the node graph, one may identify the
following sub components:

\begin{description}
\item[Nodes] Building blocks of a real time animation.
  \begin{description}
    \item[Domain model] Holds data of a node, like its definition, its inputs
                        and so on.
    \item[Definitions]  Represents a domain model as JSON data structure.
    \item[Controller]   Handles the loading of node definitions as well as the
                        creation of node instances.
    \item[View model]   Represents a node within the graphical user interface.
  \end{description}
\end{description}

\begin{description}
\item[Scenes] A composition of nodes, connected by edges.
  \begin{description}
    \item[Domain model] Holds the data of a scene, e.g.\ its nodes.
    \item[Controller]   Handles scene related actions, like when a node is added
                        to a scene, when the scene was changed or when a node
                        within a scene was selected.
    \item[View model]   Defines the graphical representation of scene which can
                        be represented by the corresponding view. Basically the
                        scene view model is a canvas consisting of nodes.
    \item[View]         Represents scenes in terms of scene view models within the
                        graphical user interface.
  \end{description}
\end{description}

\section{Nodes}
\label{appendix:sec:node-grahp:nodes}

\newthought{What are nodes and node definitions?} As mentioned before, they are
the building blocks of a real time animation. But what are those definitions
actually? What do they actually define? There is not only one answer to this
question, it is simply a matter of how the implementation is being done and
therefore a set of decisions.

\newthought{The whole (rendering) system} shall not be bound to only one
representation of nodes, e.g.\ triangle based meshes. Instead it shall let the
user decide, what representation is the most fitting for the goal he wants to
achieve.

\newthought{Multiple kinds of node representations} shall be supported by the
system: images, triangle based meshes and solid modeling through function
modeling (using signed distance functions for modeling implicit surfaces).
Whereas triangle based meshes may either be loaded from externally defined files
(e.g.\ in the Filmbox (FBX), the Alembic (ABC) or the Object file format (OBJ))
or directly be generated using procedural mesh generation.

\newthought{Nodes are always part of a graph}, hence the name node graph, and
are therefore typically connected by edges. This means that the graph gets
evaluated recursively by its nodes, starting with the root node within the root
scene. However, the goal is to have OpenGL shading language (GLSL) code at the
end, independent of the node types.

\newthought{From this point of view} it would make sense to let the user define
shader code directly within a node (definition) and to simply evaluate this
code, which adds a lot of (creative) freedom. The problem with this approach is
though, that image and triangle based mesh nodes are not fully implementable by
using shader code only. Instead they have specific requirements, which are only
perform-able on the CPU (e.g.\ allocating buffer objects).

\newthought{When thinking of nodes used for solid modeling} however, it may
appear, that they may be evaluated directly, without the need for
pre-processing, as they are fully implementable using shader code only. This is
kind of misleading however, as each node has its own definition which has to be
added to shader and this definition is then used in a mapping function to
compose the scene. This would mean to add a definition of a node over and over
again, when spawning multiple instances of the same node type, which results in
overhead bloating the shader. It is therefore necessary to pre-process solid
modeling nodes too, exactly as triangle mesh based and image nodes, for being
able to use multiple instances of the same node type within a scene while having
the definition added only once.

\newthought{All of these thoughts sum up} in one central question for the
implementation: Shall objects be predefined within the code (and therefore only
nodes accepted whose type and sub type match those of predefined nodes) or shall
all objects be defined externally using files?

This is a question which is not that easy to answer. Both methods have their
advantages and disadvantages. Pre-defining nodes within the code minimizes
unexpected behavior of the application. Only known and well-defined nodes are
processed.

But what if someone would like to have a new node type which is not yet defined?
The node type has to be implemented first. As Python is used for the editor
application, this is not really a problem as the code is interpreted each time
and is therefore not being compiled. Nevertheless such changes follow a certain
process, such as making the actual changes within the code, reviewing and
checking-in the code and so on, which the user normally does not want to be
bothered with. Furthermore, when thinking about the player application, the
problem of the necessity to recompile the code is definitively given. The player
will be implemented in C, as there is the need for performance, which Python may
not fulfill satisfactorily.

\newthought{The external definition of nodes is chosen} considering these
aspects. This may result in nodes which cannot be evaluated or which have
unwanted effects. As it is (most likely) in the users best interest to create
(for his taste) appealing real time animations, it can be assumed, that the user
will try avoiding to create such nodes or quickly correct faulty nodes or simply
does not use such nodes.

Now, having chosen how to implement nodes, it is important to define what a node
actually is. As a node may be referenced by other nodes, it must be uniquely
identifiable and must therefore have a globally unique identifier. Concerning
the visual representation, a node shall have a name as well as a description.

\newthought{Each node can have multiple inputs and at least one output.} The
inputs may be either be atomic types (which have to be defined) or references to
other nodes. The same applies to the outputs.

\newthought{A node consists also of a definition.} In terms of implicit surfaces
this section contains the actual definition of a node in terms of the implicit
function. In terms of triangle based meshes this is the part where the mesh and
all its prerequisites as vertex array buffers and vertex array objects are set
up or used from a given context.

In addition to a definition, a node contains an invocation part, which is the
call of its defining function (coming from the definition mentioned just
before) while respecting the parameters.

\newthought{A node shall be able to have one or more parts.} A part typically
contains the \enquote{body} of the node in terms of code and represents
therefore the code-wise implementation of the node. A part can be processed when
evaluating the node. This part of the node is mainly about evaluating inputs and
passing them on to a shader.

Furthermore a node may contain children (child-nodes) which are actually
references to other nodes combined with properties such as a name, states and so
on.

\newthought{Each node can have multiple connections.} A connection is composed
of an input and an output plus a reference to a part. The input respectively the
output may be zero, what means that the part of the input or output is internal.

Or, a bit more formal:

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap61}\raggedright\small
\NWtarget{nuweb123}{} $\langle\,${\itshape Connections between nodes in EBNF notation}\nobreak\ {\footnotesize {123}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
input = internal input | external input
internal input = zero reference, part reference
external input = node reference, part reference
zero reference = "0"
node reference = "uuid4"
part reference = "uuid4"
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Connections between nodes in EBNF notation.}
% \label{node-graph:lst:node-connections-ebnf}
\end{figure}

% Reference to a node X + Reference to /output/ A of node X.
% or
% No reference to another node + Reference to an /input/ of the current node.
%
% Output:
% Reference to a node Y + Reference to /input/ B of node Y.
% or
% No reference to another node + Reference to an /output/ or to /part/ of the
% current node.

\newthought{Recapitulating the above made thoughts} a node is essentially
composed by the following elements:

\begin{table*}\centering
  \ra{1.3}
  \begin{tabularx}{\textwidth}{@{}lX@{}}
    \toprule
    \textbf{Component} & \textbf{Description}\\
    \hline
    \textit{ID} & A global unique identifier (UUID\protect\footnotemark[1]{})\\
    \textit{Name} & The name of the node, e.g. "Cube".\\
    \textit{Description} & A description of the node's purpose.\\
    \textit{Inputs} & A list of the node's inputs. The inputs may either be
    parameters (which are atomic types such as float values or text input) or
    references to other nodes.\\
    \textit{Outputs} & A list of the node's outputs. The outputs may also either
    be parameters or references to other nodes.\\
    \textit{Definitions} & A list of the node's definitions. This may be an
    actual definition by a (shader-) function in terms of an implicit surface or
    prerequisites as vertex array buffers in terms of a triangle based mesh.\\
    \textit{Invocation} & A list of the node's invocations or calls
    respectively.\\
    \textit{Parts} & Defines parts that may be processed when evaluating the
    node. Contains code which can be interpreted directly.\\
    \textit{Nodes} & The children a node has (child nodes). These entries are
    references to other nodes only.\\
    \textit{Connections} & A list of connections of the node's inputs and
    outputs.

    Each connection is composed by two parts: A reference to another node
    and a reference to an input or an output of that node. Is the reference not set,
    that is, its value is zero, this means that the connection is internal.\\
    \bottomrule
  \end{tabularx}
  \caption{Components a node is composed of.}
\end{table*}
\footnotetext[1]{https://docs.python.org/3/library/uuid.html}

\newthought{The inputs and outputs may be parameters of an atomic type}, as
stated above. This seems like a good point to define the atomic types the system
will have:

\begin{itemize}
  \item{Generic}
  \item{Float}
  \item{Text}
  \item{Scene}
  \item{Image}
  \item{Dynamic}
  \item{Mesh}
  \item{Implicit}
\end{itemize}

As these atomic types are the foundation of all other nodes, the system must
ensure, that they are initialized before all other nodes. Before being able to
create instances of atomic types, there must be classes defining them.

\newthought{For identification of the atomic types}, an enumerator is used.
Python provides the~\verb=enum= module, which provides a convenient interface
for using enumerations\footnote{\url{https://docs.python.org/3/library/enum.html}}.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap62}\raggedright\small
\NWtarget{nuweb124}{} $\langle\,${\itshape Node type declarations}\nobreak\ {\footnotesize {124}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeType(enum.Enum):
    """Atomic types which a parameter may be made of."""

    GENERIC  = 0
    FLOAT    = 1
    TEXT     = 2
    SCENE    = 3
    IMAGE    = 4
    DYNAMIC  = 5
    MESH     = 6
    IMPLICIT = 7
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb201}{201}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Types of a node wrapped in a class, implemented as an enumerator.
  \newline{}\newline{}Editor $\rightarrow$ Types $\rightarrow$ Node type}
% \label{editor:lst:types:node-type}
\end{figure}

Now, having identifiers for the atomic types available, the atomic types
themselves can be implemented. The atomic types will be used for defining
various properties of a node and are therefore its parameters.

\newthought{Each node may contain one or more parameters} as inputs and at least
one parameter as output. Each parameter will lead back to its atomic type by
referencing the unique identifier of the atomic type. For being able to
distinguish multiple parameters using the same atomic type, it is necessary that
each instance of an atomic type has its own identifier in form of an instance
identifier (instance ID).

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap63}\raggedright\small
\NWtarget{nuweb125}{} $\langle\,${\itshape Parameter declarations}\nobreak\ {\footnotesize {125}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class AtomicType(object):
    """Represents an atomic type and is the basis for each
    node."""

    def __init__(self, id_, type_):
        """Constructor.

        :param id_: the globally unique identifier of the
                    atomic type.
        :type  id_: uuid.uuid4
        :param type_: the type of the atomic type, e.g. "float".
        :type  type_: types.NodeType
        """

        self.id_   = id_
        self.type_ = type_
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb125}{125}\NWlink{nuweb126}{, 126}\NWlink{nuweb203}{, 203}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The atomic type class which builds the basis for node parameters. Note
  that the type of an atomic type is defined by the before implemented node
  type.
  \newline{}\newline{}Editor $\rightarrow$ Parameters $\rightarrow$ Atomic type}
% \label{editor:lst:parameters:atomic-type}
\end{figure}

As the word atomic indicates, these types are atomic, meaning there only exists
one explicit instance per type, which is therefore static. As can be seen in the
code fragment below, the atomic types are parts of node definitions themselves.
Only the creation of the generic atomic type is shown, the rest is omitted and
can be found
at~\autoref{chap:code-fragments}~\enquote{\nameref{chap:code-fragments}}.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap64}\raggedright\small
\NWtarget{nuweb126}{} $\langle\,${\itshape Parameter declarations}\nobreak\ {\footnotesize {126}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
class AtomicTypes(object):
    """Creates and holds all atomic types of the system."""

    |\normalfont{}\fontfamily{}|staticmethod
    def create_node_definition_part(id_, type_):
        """Creates a node definition part based on the given
        identifier and type.

        :param id_: the identifier to use for the part.
        :type  id_: uuid.uuid4
        :param type_: the type of the part.
        :type type_: qde.editor.domain.parameter.AtomicType

        :return: a node definition part.
        :rtype: qde.editor.domain.node.NodeDefinitionPart
        """

        def create_func(id_, default_function, name, type_):
            node_part = node.NodePart(id_, default_function)
            node_part.type_ = type_
            node_part.name = name
            return node_part

        node_definition_part = node.NodeDefinitionPart(id_)
        node_definition_part.type_ = type_
        node_definition_part.creator_function = create_func

        return node_definition_part

    Generic = create_node_definition_part.__func__(
        id_="54b20acc-5867-4535-861e-f461bdbf3bf3",
        type_=types.NodeType.GENERIC
    )
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb125}{125}\NWlink{nuweb126}{, 126}\NWlink{nuweb203}{, 203}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A class which creates and holds all atomic types of the editor. Note
  that at this point only an atomic type for generic nodes is being created.
  \newline{}\newline{}Editor $\rightarrow$ Parameters $\rightarrow$ Atomic types}
% \label{editor:lst:parameters:atomic-types}
\end{figure}

\newthought{Having the atomic types defined}, nodes may now be defined.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap65}\raggedright\small
\NWtarget{nuweb127a}{} $\langle\,${\itshape Node domain model declarations}\nobreak\ {\footnotesize {127a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeModel(object):
    """Represents a node."""

    # Signals

    |\hbox{$\langle\,${\itshape Node domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb127b}{127b}, \ldots\ }$\,\rangle$}|

    |\hbox{$\langle\,${\itshape Node domain model methods}\nobreak\ {\footnotesize \NWlink{nuweb130a}{130a}}$\,\rangle$}|

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the node (domain) model.
  \newline{}\newline{}Editor $\rightarrow$ Node model}
% \label{editor:lst:node-domain-model}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap66}\raggedright\small
\NWtarget{nuweb127b}{} $\langle\,${\itshape Node domain model constructor}\nobreak\ {\footnotesize {127b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, id_, name="New node"):
    """Constructor.

    :param id_: the globally unique identifier of the node.
    :type  id_: uuid.uuid4
    :param name: the name of the node.
    :type  name: str
    """

    self.id_   = id_
    self.name = name

    self.definition = None
    self.description = ""
    self.parent = None
    self.inputs = []
    self.outputs = []
    self.parts = []
    self.nodes = []
    self.connections = []
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb127b}{127b}\NWlink{nuweb131c}{, 131c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb127a}{127a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the node (domain) model.
  \newline{}\newline{}Editor $\rightarrow$ Node model $\rightarrow$ Constructor}
% \label{editor:lst:node-domain-model:constructor}
\end{figure}

\newthought{While the details of a node are rather unclear} at the moment, it is
clear that a node needs to have a view model, which renders a node within a
scene of the node graph.

\newthought{Qt does not offer a graph view by default}, therefore it is
necessary to implement such a graph view.

The most obvious choice for this implementation is the ~\verb=QGraphicsView=
component, which displays the contents of a ~\verb=QGraphicsScene=,
whereas~\verb=QGraphicsScene= manages~\verb=QGraphicsObject= components.

It is therefore obvious to use the~\verb=QGraphicsObject= component
for representing graph nodes through a view model.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap67}\raggedright\small
\NWtarget{nuweb128a}{} $\langle\,${\itshape Node view model declarations}\nobreak\ {\footnotesize {128a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeViewModel(Qt.QGraphicsObject):
    """Class representing a single node within GUI."""

    # Constants
    WIDTH = 120
    HEIGHT = 40

    # Signals
    |\hbox{$\langle\,${\itshape Node view model signals}\nobreak\ {\footnotesize \NWlink{nuweb214c}{214c}}$\,\rangle$}|

    |\hbox{$\langle\,${\itshape Node view model constructor}\nobreak\ {\footnotesize \NWlink{nuweb128b}{128b}, \ldots\ }$\,\rangle$}|

    |\hbox{$\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize \NWlink{nuweb129a}{129a}, \ldots\ }$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb208a}{208a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the node view model.
  \newline{}\newline{}Editor $\rightarrow$ Node view model}
% \label{editor:lst:node-view-model}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap68}\raggedright\small
\NWtarget{nuweb128b}{} $\langle\,${\itshape Node view model constructor}\nobreak\ {\footnotesize {128b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, id_, domain_object, parent=None):
    """Constructor.

    :param id_: the globally unique identifier of the atomic type.
    :type  id_: uuid.uuid4
    :param domain_object: Reference to a scene model.
    :type  domain_object: qde.editor.domain.scene.SceneModel
    :param parent: The parent of the current view widget.
    :type parent:  QtCore.QObject
    """

    super(NodeViewModel, self).__init__(parent)
    self.id_ = id_
    self.domain_object = domain_object

    self.position = QtCore.QPoint(0, 0)

    self.width  = NodeViewModel.WIDTH
    self.height = NodeViewModel.HEIGHT
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb128b}{128b}\NWlink{nuweb131a}{, 131a}\NWlink{nuweb208b}{, 208b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the node view model.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Constructor}
% \label{editor:lst:node-view-model:constructor}
\end{figure}

\newthought{To distinguish nodes}, the name and the type of a node is used. It
makes sense to access both attributes directly via the domain model instead of
duplicating them.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap69}\raggedright\small
\NWtarget{nuweb129a}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {129a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|property
def type_(self):
    """Return the type of the node, determined by its domain model.

    :return: the type of the node.
    :rtype: types.NodeType
    """

    return self.domain_object.type_
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb129a}{129a}\NWlink{nuweb129b}{b}\NWlink{nuweb130b}{, 130b}\NWlink{nuweb131b}{, 131b}\NWlink{nuweb132a}{, 132a}\NWlink{nuweb209}{, 209}\NWlink{nuweb215}{, 215}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The type attribute of the node view model as property.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Methods}
% \label{editor:lst:node-view-model:methods:type}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap70}\raggedright\small
\NWtarget{nuweb129b}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {129b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|property
def name(self):
    """Return the name of the node, determined by its domain model.

    :return: the name of the node.
    :rtype: str
    """

    return self.domain_object.name
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb129a}{129a}\NWlink{nuweb129b}{b}\NWlink{nuweb130b}{, 130b}\NWlink{nuweb131b}{, 131b}\NWlink{nuweb132a}{, 132a}\NWlink{nuweb209}{, 209}\NWlink{nuweb215}{, 215}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The name attribute of the node view model as property.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Methods}
% \label{editor:lst:node-view-model:methods:name}
\end{figure}

\newthought{The domain model does not provide access} to its type at the moment
however. The type is directly derived from the primary output of a node. If a
node has no outputs at all, its type is assumed to be generic.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap71}\raggedright\small
\NWtarget{nuweb130a}{} $\langle\,${\itshape Node domain model methods}\nobreak\ {\footnotesize {130a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|property
def type_(self):
    """Return the type of the node, determined by its primary
    output. If no primary output is given, it is assumed that
    the node is of generic type."""

    type_ = types.NodeType.GENERIC

    if len(self.outputs) > 0:
        type_ = self.outputs[0].type_

    return type_|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb127a}{127a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The type attributes of the node domain model as property.
  \newline{}\newline{}Editor $\rightarrow$ Node (domain) model $\rightarrow$
  Methods}
% \label{editor:lst:node-domain-model:methods:type}
\end{figure}

\newthought{Concerning the drawing of nodes} (or painting, as Qt calls it) ,
each node type may be used multiple times. But instead of re-creating the same
image representation over and over again, it makes sense to create it only once
per node type. Qt provides~\verb=QPixmap= and~\verb=QPixmapCache= for this use
case.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap72}\raggedright\small
\NWtarget{nuweb130b}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {130b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def paint(self, painter, option, widget):
    """Paint the node.

    First a pixmap is loaded from cache if available, otherwise
    a new pixmap gets created. If the current node is selected a
    rectangle gets additionally drawn on it. Finally the name,
    the type as well as the sub type gets written on the node.
    """

    |\hbox{$\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize \NWlink{nuweb132b}{132b}, \ldots\ }$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb129a}{129a}\NWlink{nuweb129b}{b}\NWlink{nuweb130b}{, 130b}\NWlink{nuweb131b}{, 131b}\NWlink{nuweb132a}{, 132a}\NWlink{nuweb209}{, 209}\NWlink{nuweb215}{, 215}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The paint method of the node view model. When a pixmap is being
  created, it gets cached immediately, based on its type, status and its
  selection status. If a pixmap already existing for a given tripe, type, status
  and selection, that pixmap is used.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Methods}
% \label{editor:lst:node-view-model:methods:paint}
\end{figure}

\newthought{Each node has a cache key assigned}, which is used to identify that
node.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap73}\raggedright\small
\NWtarget{nuweb131a}{} $\langle\,${\itshape Node view model constructor}\nobreak\ {\footnotesize {131a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.cache_key = None
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb128b}{128b}\NWlink{nuweb131a}{, 131a}\NWlink{nuweb208b}{, 208b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The cache key is being initialized within a node's constructor.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Constructor}
% \label{editor:lst:node-view-model:constructor:cache-key}
\end{figure}

The cache key is composed of the type of the node, its status and whether it is
selected or not.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap74}\raggedright\small
\NWtarget{nuweb131b}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {131b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_cache_key(self):
    """Create an attribute based cache key for finding and
    creating pixmaps."""

    return "{type_name}{status}{selected}".format(
        type_name=self.type_,
        status=self.status,
        selected=self.isSelected(),
    )
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb129a}{129a}\NWlink{nuweb129b}{b}\NWlink{nuweb130b}{, 130b}\NWlink{nuweb131b}{, 131b}\NWlink{nuweb132a}{, 132a}\NWlink{nuweb209}{, 209}\NWlink{nuweb215}{, 215}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A method which creates a cache key based on the type, the status and
  the state of selection of a node.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Methods}
% \label{editor:lst:node-view-model:methods:create-cache-key}
\end{figure}

As can be seen in the above code fragment, the status property of the node is
used to create a cache key, but currently nodes do not have a status.

It may make sense although to provide a status for each node, which allows to
output eventual problems like not having required connections and so on.

\newthought{This status is added} to the constructor of the domain model of a node.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap75}\raggedright\small
\NWtarget{nuweb131c}{} $\langle\,${\itshape Node domain model constructor}\nobreak\ {\footnotesize {131c}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.status = flag.NodeStatus.OK
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb127b}{127b}\NWlink{nuweb131c}{, 131c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb127a}{127a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The status of the node is being initialized within the node's constructor.
  \newline{}\newline{}Editor $\rightarrow$ Node domain model $\rightarrow$
  Constructor}
% \label{editor:lst:node-domain-model:constructor:status}
\end{figure}

\newthought{Concerning the view model}, again the status of the domain model is
used as otherwise different states between user interface and domain model would
be possible in the worst case.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap76}\raggedright\small
\NWtarget{nuweb132a}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {132a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|property
def status(self):
    """Return the current status of the node.

    :return: the current status of the node.
    :rtype: flag.NodeStatus
    """

    return self.domain_object.status
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb129a}{129a}\NWlink{nuweb129b}{b}\NWlink{nuweb130b}{, 130b}\NWlink{nuweb131b}{, 131b}\NWlink{nuweb132a}{, 132a}\NWlink{nuweb209}{, 209}\NWlink{nuweb215}{, 215}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The status of a node view model is obtained by accessing the domain
  model's status.
  \newline{}\newline{}Editor $\rightarrow$ Node domain model $\rightarrow$
  Methods}
% \label{editor:lst:node-view-model:methods:status}
\end{figure}

Therefore it can now be checked, whether a node has a cache key or not. If it
has no cache key, a new cache key is created.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap77}\raggedright\small
\NWtarget{nuweb132b}{} $\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize {132b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
if self.cache_key is None:
    self.cache_key = self.create_cache_key()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb132b}{132b}\NWlink{nuweb132c}{c}\NWlink{nuweb133}{, 133}\NWlink{nuweb214a}{, 214a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb130b}{130b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A cache key is being created when no cache key for the given attributes
  is found.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Methods $\rightarrow$ Paint}
% \label{editor:lst:node-view-model:methods:paint:create-cache-key}
\end{figure}

The cache key itself is then used to find a corresponding pixmap.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap78}\raggedright\small
\NWtarget{nuweb132c}{} $\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize {132c}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
pixmap = QtGui.QPixmapCache.find(self.cache_key)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb132b}{132b}\NWlink{nuweb132c}{c}\NWlink{nuweb133}{, 133}\NWlink{nuweb214a}{, 214a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb130b}{130b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Based on the created or retrieved cache key a pixmap is being searched
  for.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Methods $\rightarrow$ Paint}
% \label{editor:lst:node-view-model:methods:paint:find-pixmap}
\end{figure}

If no pixmap with the given cache key exists, a new pixmap is being created and
added to the cache using the cache key created before.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap79}\raggedright\small
\NWtarget{nuweb133}{} $\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize {133}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
if pixmap is None:
    pixmap = self.create_pixmap()
    QtGui.QPixmapCache.insert(self.cache_key, pixmap)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb132b}{132b}\NWlink{nuweb132c}{c}\NWlink{nuweb133}{, 133}\NWlink{nuweb214a}{, 214a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb130b}{130b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{If no pixmap is found, a new pixmap is being created for the provided
  key and stored.
  \newline{}\newline{}Editor $\rightarrow$ Node view model $\rightarrow$
  Methods $\rightarrow$ Paint}
% \label{editor:lst:node-view-model:methods:paint:create-pixmap}
\end{figure}

\newthought{For actually displaying the nodes}, another component is necessary:
the scene view which is a graph consisting the nodes and edges.
% -*- mode: latex; coding: utf-8 -*-

\chapter{Scene view}
\label{appendix:chap:scene-view}

\newthought{For implementing the scene view} the~\verb=QGraphicsView= component
is used as basis, as before with the node graph component. The graphics view
displays the contents of scene, therefore a~\verb=QGraphicsScene=,
whereas~\verb=QGraphicsScene= manages nodes in form of~\verb=QGraphicsObject=
components.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap80}\raggedright\small
\NWtarget{nuweb134a}{} $\langle\,${\itshape Scene view declarations}\nobreak\ {\footnotesize {134a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class SceneView(Qt.QGraphicsView):
    """Scene view widget.
    A widget for displaying and managing scenes including their
    nodes and connections between nodes."""

    # Signals
    |\hbox{$\langle\,${\itshape Scene view signals}\nobreak\ {\footnotesize \NWlink{nuweb195c}{195c}}$\,\rangle$}|

    |\hbox{$\langle\,${\itshape Scene view constructor}\nobreak\ {\footnotesize \NWlink{nuweb134b}{134b}, \ldots\ }$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene view methods}\nobreak\ {\footnotesize \NWlink{nuweb184a}{184a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene view slots}\nobreak\ {\footnotesize \NWlink{nuweb143b}{143b}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb195a}{195a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the scene view component, derived from the QGraphicsView
  component.
  \newline{}\newline{}Editor $\rightarrow$ Scene view}
% \label{editor:lst:scene-view}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap81}\raggedright\small
\NWtarget{nuweb134b}{} $\langle\,${\itshape Scene view constructor}\nobreak\ {\footnotesize {134b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, parent=None):
    """Constructor.

    :param parent: the parent of this scene view.
    :type parent: Qt.QObject
    """

    super(SceneView, self).__init__(parent)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb134b}{134b}\NWlink{nuweb183b}{, 183b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb134a}{134a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the scene view component.
  \newline{}\newline{}Editor $\rightarrow$ Scene view $\rightarrow$ Constructor}
% \label{editor:lst:scene-view:constructor}
\end{figure}

\newthought{The scene view can now be set up} by the main window and is then added to its
vertical splitter.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap82}\raggedright\small
\NWtarget{nuweb135}{} $\langle\,${\itshape Set up scene view in main window}\nobreak\ {\footnotesize {135}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.scene_view = gui_scene.SceneView(self)
self.scene_view.setObjectName('scene_view')
size_policy = QtWidgets.QSizePolicy(
    QtWidgets.QSizePolicy.Expanding,
    QtWidgets.QSizePolicy.Expanding
)
size_policy.setHorizontalStretch(2)
size_policy.setVerticalStretch(0)
size_policy.setHeightForWidth(
    self.scene_view.sizePolicy().hasHeightForWidth()
)
self.scene_view.setSizePolicy(size_policy)
self.scene_view.setMinimumSize(Qt.QSize(0, 0))
self.scene_view.setAutoFillBackground(False)
self.scene_view.setFrameShape(QtWidgets.QFrame.StyledPanel)
self.scene_view.setFrameShadow(QtWidgets.QFrame.Sunken)
self.scene_view.setLineWidth(1)
self.scene_view.setVerticalScrollBarPolicy(
    QtCore.Qt.ScrollBarAsNeeded
)
self.scene_view.setHorizontalScrollBarPolicy(
    QtCore.Qt.ScrollBarAsNeeded
)
brush = QtGui.QBrush(Qt.QColor(0, 0, 0, 255))
brush.setStyle(QtCore.Qt.NoBrush)
self.scene_view.setBackgroundBrush(brush)
self.scene_view.setAlignment(
    QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop
)
self.scene_view.setDragMode(
    QtWidgets.QGraphicsView.RubberBandDrag
)
self.scene_view.setTransformationAnchor(
    QtWidgets.QGraphicsView.AnchorUnderMouse
)
self.scene_view.setOptimizationFlags(
    QtWidgets.QGraphicsView.DontAdjustForAntialiasing
)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb92}{92}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene view component is being set up by the main window.
  \newline{}\newline{}Editor $\rightarrow$ Main window $\rightarrow$
  Methods $\rightarrow$ Setup UI}
% \label{editor:lst:main-window:methods:setup-ui:setup-scene-view}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap83}\raggedright\small
\NWtarget{nuweb136a}{} $\langle\,${\itshape Add scene view to vertical splitter in main window}\nobreak\ {\footnotesize {136a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
vertical_splitter.addWidget(self.scene_view)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb92}{92}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene view component is being added to the main window's vertical
  splitter.
  \newline{}\newline{}Editor $\rightarrow$ Main window $\rightarrow$
  Methods $\rightarrow$ Setup UI}
% \label{editor:lst:main-window:methods:setup-ui:add-scene-view-to-splitter}
\end{figure}

\newthought{At this point the scene view does not react} whenever the scene is
changed by the scene graph view. As before, the main application needs connect
the components.

\newthought{Connecting the view models} of the scene graph view and the scene
view directly would not make much sense, as they both use different view models.
Instead it makes sense to connect the~\verb=do_select_scene= signal of the scene
graph controller with the ~\verb=on_scene_changed= slot of the scene controller
as they both use the domain model of the scene.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap84}\raggedright\small
\NWtarget{nuweb136b}{} $\langle\,${\itshape Connect controllers for main application}\nobreak\ {\footnotesize {136b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.scene_graph_controller.do_select_scene.connect(
    self.scene_controller.on_scene_changed
)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb136b}{136b}\NWlink{nuweb136c}{c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90b}{90b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Whenever a scene is selected in the scene graph, the scene graph
  controller informs the scene controller about that selection.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:connect-scene-controllers-select}
\end{figure}

The scene controller does not manage scene models directly, as the scene graph
controller does. Instead it reacts on signals sent by the latter and manages
its own scene view models.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap85}\raggedright\small
\NWtarget{nuweb136c}{} $\langle\,${\itshape Connect controllers for main application}\nobreak\ {\footnotesize {136c}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.scene_graph_controller.do_add_scene.connect(
    self.scene_controller.on_scene_added
)
self.scene_graph_controller.do_remove_scene.connect(
    self.scene_controller.on_scene_removed
)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb136b}{136b}\NWlink{nuweb136c}{c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90b}{90b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Whenever a scene is added to or removed from the scene graph, the scene graph
  controller informs the scene controller about those actions.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:connect-scene-controllers-add-remove}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap86}\raggedright\small
\NWtarget{nuweb137a}{} $\langle\,${\itshape Scene controller declarations}\nobreak\ {\footnotesize {137a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class SceneController(Qt.QObject):
    """The scene controller.

    A controller for switching scenes and managing the nodes of
    a scene by adding, editing and removing nodes to / from a
    scene.
    """

    # Signals
    |\hbox{$\langle\,${\itshape Scene controller signals}\nobreak\ {\footnotesize \NWlink{nuweb143a}{143a}, \ldots\ }$\,\rangle$}|

    |\hbox{$\langle\,${\itshape Scene controller constructor}\nobreak\ {\footnotesize \NWlink{nuweb140}{140}}$\,\rangle$}|

    # Methods

    # Slots
    |\hbox{$\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize \NWlink{nuweb141}{141}, \ldots\ }$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb194b}{194b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the scene controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene controller}
% \label{editor:lst:scene-controller}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap87}\raggedright\small
\NWtarget{nuweb137b}{} $\langle\,${\itshape Set up controllers for main application}\nobreak\ {\footnotesize {137b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.scene_controller = scene.SceneController(self)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb105b}{105b}\NWlink{nuweb137b}{, 137b}\NWlink{nuweb181a}{, 181a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90b}{90b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The scene controller being set up by the main application.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:setup-scene-controller}
\end{figure}

\newthought{The scene view models represent a certain scene} of the scene graph
and hold the nodes of a specific scene. A scene view model is of
type~\verb=QGraphicsScene=.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap88}\raggedright\small
\NWtarget{nuweb138a}{} $\langle\,${\itshape Scene view model declarations}\nobreak\ {\footnotesize {138a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class SceneViewModel(Qt.QGraphicsScene):
    """Scene view model.
    Represents a certain scene from the scene graph and is used
    to manage the nodes of that scene."""

    # Constants
    WIDTH = 15
    HEIGHT = 15

    # Signals

    |\hbox{$\langle\,${\itshape Scene view model constructor}\nobreak\ {\footnotesize \NWlink{nuweb138b}{138b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Scene view model methods}\nobreak\ {\footnotesize \NWlink{nuweb139}{139}, \ldots\ }$\,\rangle$}|

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb193b}{193b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the scene view model.
  \newline{}\newline{}Editor $\rightarrow$ Scene view model}
% \label{editor:lst:scene-view-model}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap89}\raggedright\small
\NWtarget{nuweb138b}{} $\langle\,${\itshape Scene view model constructor}\nobreak\ {\footnotesize {138b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, domain_object, parent=None):
   """Constructor.

   :param domain_object: Reference to a scene model.
   :type  domain_object: qde.editor.domain.scene.SceneModel
   :param parent:        The parent of the current view model.
   :type parent:         qde.editor.gui_domain.scene.SceneViewModel
   """

   super(SceneViewModel, self).__init__(parent)

   self.id_              = domain_object.id_
   self.nodes            = []
   self.insert_at        = QtCore.QPoint(0, 0)
   self.insert_at_colour = Qt.QColor(
      self.palette().highlight().color()
   )

   self.width            = SceneViewModel.WIDTH * 20
   self.height           = SceneViewModel.HEIGHT * 17

   self.setSceneRect(0, 0, self.width, self.height)
   self.setItemIndexMethod(self.NoIndex)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb138a}{138a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the scene view model component.
  \newline{}\newline{}Editor $\rightarrow$ Scene view model $\rightarrow$
  Constructor}
% \label{editor:lst:scene-view-model:constructor}
\end{figure}

\newthought{For being able to distinguish different scenes}, their identifier
will be drawn at the top left position.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap90}\raggedright\small
\NWtarget{nuweb139}{} $\langle\,${\itshape Scene view model methods}\nobreak\ {\footnotesize {139}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def drawBackground(self, painter, rect):
    super(SceneViewModel, self).drawBackground(painter, rect)

    scene_rect = self.sceneRect()

    # Draw scene identifier
    text_rect = QtCore.QRectF(scene_rect.left()   + 4,
                              scene_rect.top()    + 4,
                              scene_rect.width()  - 4,
                              scene_rect.height() - 4)
    message = str(self)
    painter.save()
    font = painter.font()
    font.setBold(True)
    font.setPointSize(14)
    painter.setFont(font)
    painter.setPen(QtCore.Qt.lightGray)
    painter.drawText(text_rect.translated(2, 2), message)
    painter.setPen(QtCore.Qt.black)
    painter.drawText(text_rect, message)
    painter.restore()

    # Draw insert at marker
    width    = node_gui_domain.NodeViewModel.WIDTH
    height   = node_gui_domain.NodeViewModel.HEIGHT
    gradient = Qt.QLinearGradient(0, 0, width, 0)
    color    = self.palette().highlight().color()
    color.setAlpha(127)
    gradient.setColorAt(0, color)
    color.setAlpha(0)
    gradient.setColorAt(1, color)
    brush = QtGui.QBrush(gradient)
    painter.save()
    painter.translate(QtCore.QPoint(
        self.insert_at.x() * node_gui_domain.NodeViewModel.WIDTH,
        self.insert_at.y() * node_gui_domain.NodeViewModel.HEIGHT
    ))
    QtWidgets.qDrawPlainRect(
        painter, 0, 0, width + 1, height + 1, color, 0, brush
    )
    gradient.setColorAt(0, color)
    painter.setPen(QtGui.QPen(QtGui.QBrush(gradient), 0))
    painter.drawLine(0, 0, 0, height)
    painter.drawLine(0, 0, width, 0)
    painter.drawLine(0, height, width, height)
    painter.restore()

|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb139}{139}\NWlink{nuweb194a}{, 194a}\NWlink{nuweb198a}{, 198a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb138a}{138a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The method to draw the background of a scene. It is used to draw the
  identifier of a scene at the top left position of it.
  \newline{}\newline{}Editor $\rightarrow$ Scene view model $\rightarrow$
  Methods}
% \label{editor:lst:scene-view-model:methods:draw-background}
\end{figure}

\newthought{The scene controller does not directly manage scenes.} It has to
react upon the signals sent by the scene graph controller. Additionally it needs
to keep track of the currently selected scene, by holding a reference to that.
The common identifier is the identifier of the domain model.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap91}\raggedright\small
\NWtarget{nuweb140}{} $\langle\,${\itshape Scene controller constructor}\nobreak\ {\footnotesize {140}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, parent):
    """Constructor.

    :param parent: the parent of this scene controller.
    :type parent: Qt.QObject
    """

    super(SceneController, self).__init__(parent)

    self.scenes = {}
    self.current_scene = None
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb137a}{137a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the scene controller. As can be seen, the scene
  controller holds all scenes (as a dictionary) and keeps track of the currently
  active scene.
  \newline{}\newline{}Editor $\rightarrow$ Scene controller $\rightarrow$
  Constructor}
% \label{editor:lst:scene-controller:constructor}
\end{figure}

\newthought{Whenever a new scene is created}, the scene controller needs to
create a scene of type~\verb=QGraphicsScene= and needs to keep track of that
scene.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap92}\raggedright\small
\NWtarget{nuweb141}{} $\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize {141}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(scene_domain.SceneModel)
def on_scene_added(self, scene_domain_model):
    """React when a scene was added.

    :param scene_domain_model: the scene that was added.
    :type scene_domain_model:  qde.domain.scene.SceneModel
    """

    if scene_domain_model.id_ not in self.scenes:
        scene_view_model = scene_gui_domain.SceneViewModel(
            domain_object=scene_domain_model
        )
        self.scenes[scene_domain_model.id_] = scene_view_model
        self.logger.debug(
            "Scene '%s' was added",
            scene_view_model
        )
    else:
        self.logger.debug(
            "Scene '%s' already known",
            scene
        )
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb141}{141}\NWlink{nuweb142a}{, 142a}\NWlink{nuweb142b}{b}\NWlink{nuweb197}{, 197}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb137a}{137a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The slot which gets triggered whenever a new scene is added via the
  scene graph.
  \newline{}\newline{}Editor $\rightarrow$ Scene controller $\rightarrow$
  Slots}
% \label{editor:lst:scene-controller:slots:on-scene-added}
\end{figure}

\newthought{Whenever a scene is deleted}, it needs to delete the scene from its
known scenes as well.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap93}\raggedright\small
\NWtarget{nuweb142a}{} $\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize {142a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(scene_domain.SceneModel)
def on_scene_removed(self, scene_domain_model):
    """React when a scene was removed/deleted.

    :param scene_domain_model: the scene that was removed.
    :type scene_domain_model:  qde.domain.scene.SceneModel
    """

    if scene_domain_model.id_ in self.scenes:
        del(self.scenes[scene_domain_model.id_])
        self.logger.debug(
            "Scene '%s' was removed",
            scene_domain_model
        )
    else:
        self.logger.warn((
            "Scene '%s' should be removed, "
            "but is not known"
        ) % scene_domain_model)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb141}{141}\NWlink{nuweb142a}{, 142a}\NWlink{nuweb142b}{b}\NWlink{nuweb197}{, 197}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb137a}{137a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The slot which gets triggered whenever a scene is removed via the
  scene graph.
  \newline{}\newline{}Editor $\rightarrow$ Scene controller $\rightarrow$
  Slots}
% \label{editor:lst:scene-controller:slots:on-scene-removed}
\end{figure}

\newthought{To actually change the scene}, the scene controller needs to react
whenever the scene was changed. It does that by reacting on
the~\verb=do_select_scene= signal sent by the scene graph controller.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap94}\raggedright\small
\NWtarget{nuweb142b}{} $\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize {142b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(scene_domain.SceneModel)
def on_scene_changed(self, scene_domain_model):
    """Gets triggered when the scene was changed by the view.

    :param scene_domain_model: The currently selected scene.
    :type  scene_domain_model: qde.editor.domain.scene.SceneModel
    """

    if scene_domain_model.id_ in self.scenes:
        self.current_scene = self.scenes[scene_domain_model.id_]
        self.do_change_scene.emit(self.current_scene)
        self.logger.debug("Scene changed: %s", self.current_scene)
    else:
        self.logger.warn((
            "Should change to scene '%s', "
            "but that scene is not known"
        ) % scene_domain_model)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb141}{141}\NWlink{nuweb142a}{, 142a}\NWlink{nuweb142b}{b}\NWlink{nuweb197}{, 197}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb137a}{137a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{
  \newline{}\newline{}Editor $\rightarrow$ Scene controller $\rightarrow$
  Slots}
% \label{editor:lst:scene-controller:signals:do-change-scene}
\end{figure}

As can be seen in~\cref{scrap94},
the scene controller emits a signal that the scene was changed, containing the
view model of the new scene.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap95}\raggedright\small
\NWtarget{nuweb143a}{} $\langle\,${\itshape Scene controller signals}\nobreak\ {\footnotesize {143a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_change_scene = QtCore.pyqtSignal(scene_gui_domain.SceneViewModel)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb143a}{143a}\NWlink{nuweb196}{, 196}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb137a}{137a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The signal which is emitted when the scene has been changed by the
  scene graph controller and that scene is known to the scene controller.
  \newline{}\newline{}Editor $\rightarrow$ Scene controller $\rightarrow$
  Signals}
% \label{editor:lst:scene-controller:signals:do-change-scene}
\end{figure}

The emitted signal,~\verb=do_change_scene=, is in turn consumed by
the~\verb=on_scene_changed= slot of the scene view for actually changing the
displayed scene.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap96}\raggedright\small
\NWtarget{nuweb143b}{} $\langle\,${\itshape Scene view slots}\nobreak\ {\footnotesize {143b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(scene.SceneViewModel)
def on_scene_changed(self, scene_view_model):
    # TODO: Document method

    self.setScene(scene_view_model)
    # TODO: self.scrollTo(scene_view_model.view_position)
    self.scene().invalidate()
    self.logger.debug("Scene has changed: %s", scene_view_model)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb134a}{134a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The slot of the scene view, which gets triggered whenever the scene
  changes. The scene interface, provided by QGraphicsView, is then invalidated
  to trigger the rendering of the scene view.
  \newline{}\newline{}Editor $\rightarrow$ Scene view $\rightarrow$
  Slots}
% \label{editor:lst:scene-view:slots:on-scene-changed}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap97}\raggedright\small
\NWtarget{nuweb143c}{} $\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize {143c}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.scene_controller.do_change_scene.connect(
    self.main_window.scene_view.on_scene_changed
)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb114b}{114b}\NWlink{nuweb143c}{, 143c}\NWlink{nuweb189b}{, 189b}\NWlink{nuweb191b}{, 191b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90c}{90c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The main application connects the scene view's signal that the scene
  was changed with the corresponding slot of the scene controller.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:connect-change-scene}
\end{figure}

\newthought{At this point scenes can be managed and displayed} but they still
cannot be rendered as nodes cannot be added yet. First of all as there are no
nodes yet and second as there exists no possibility to add nodes.
%-*- mode: latex; coding: utf-8 -*-

\chapter{Nodes}
\label{appendix:chap:nodes}

\newthought{Thinking of the definition of what shall be achieved}, as defined
at~\autoref{appendix:chap:editor}, a node defining a sphere is implemented.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap98}\raggedright\small
\NWtarget{nuweb144}{} $\langle\,${\itshape Implicit sphere node}\nobreak\ {\footnotesize {144}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
{
    "name": "Implicit sphere",
    "id_": "16d90b34-a728-4caa-b07d-a3244ecc87e3",
    "description": "Definition of a sphere by using implicit surfaces",
    "inputs": [
        |\hbox{$\langle\,${\itshape Implicit sphere node inputs}\nobreak\ {\footnotesize \NWlink{nuweb145a}{145a}}$\,\rangle$}|
    ],
    "outputs": [
        |\hbox{$\langle\,${\itshape Implicit sphere node outputs}\nobreak\ {\footnotesize \NWlink{nuweb145b}{145b}}$\,\rangle$}|
    ],
    "definitions": [
        |\hbox{$\langle\,${\itshape Implicit sphere node definitions}\nobreak\ {\footnotesize \NWlink{nuweb146a}{146a}}$\,\rangle$}|
    ],
    "invocations": [
        |\hbox{$\langle\,${\itshape Implicit sphere node invocations}\nobreak\ {\footnotesize \NWlink{nuweb146b}{146b}}$\,\rangle$}|
    ],
    "parts": [
        |\hbox{$\langle\,${\itshape Implicit sphere node parts}\nobreak\ {\footnotesize \NWlink{nuweb147}{147}}$\,\rangle$}|
    ],
    "nodes": [
    ],
    "connections": [
        |\hbox{$\langle\,${\itshape Implicit sphere node connections}\nobreak\ {\footnotesize \NWlink{nuweb148}{148}}$\,\rangle$}|
    ]
}|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb210a}{210a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of a node for an implicitly defined sphere.
  \newline{}\newline{}Implicit sphere node}
% \label{editor:lst:nodes:sphere-node}
\end{figure*}

At the current point the sphere node will only have one input: the radius of
the sphere. The position of the sphere will be at the center (meaning the
X-, the Y- and the Z-position are all 0).

\newthought{For being able to change the position}, another node will be
introduced.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap99}\raggedright\small
\NWtarget{nuweb145a}{} $\langle\,${\itshape Implicit sphere node inputs}\nobreak\ {\footnotesize {145a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
{
    "name": "radius",
    "atomic_id": "468aea9e-0a03-4e63-b6b4-8a7a76775a1a",
    "default_value": {
        "type_": "float",
        "value": "1"
    },
    "id_": "f5c6a538-1dbc-4add-a15d-ddc4a5e553da",
    "description": "The radius of the sphere",
    "min_value": "-1000",
    "max_value": "1000"
}|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb144}{144}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Radius of the implicit sphere node as input.
  \newline{}\newline{}Implicit sphere node $\rightarrow$ Inputs}
% \label{editor:lst:nodes:sphere-node:inputs:radius}
\end{figure}

\newthought{The output of the sphere node} is of type implicit as the node
represents an implicit surface.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap100}\raggedright\small
\NWtarget{nuweb145b}{} $\langle\,${\itshape Implicit sphere node outputs}\nobreak\ {\footnotesize {145b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
{
    "name": "output",
    "id_": "a3ac68e5-5afe-4779-9e9f-5b619e041ae6",
    "atomic_id": "c019271c-35b6-425c-9ff2-a1d893111adb"
}|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb144}{144}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The output of the implicit sphere node, which is of the atomic type
  implicit.
  \newline{}\newline{}Implicit sphere node $\rightarrow$ Outputs}
% \label{editor:lst:nodes:sphere-node:outputs:implicit}
\end{figure}

\newthought{The definition of the node is the actual implementation} of a sphere
as a implicit surface.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap101}\raggedright\small
\NWtarget{nuweb146a}{} $\langle\,${\itshape Implicit sphere node definitions}\nobreak\ {\footnotesize {146a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
{
    "id_": "99d20a26-f233-4310-adb2-5e540726d079",
    "script": [
        "// Returns the signed distance to a sphere with given",
        "// radius for the given position.",
        "float sphere(vec3 position, float radius)",
        "{",
        "    return length(position) - radius;",
        "}"
    ]
}|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb144}{144}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of the sphere in the OpenGL Shading Language (GLSL).
  \newline{}\newline{}Implicit sphere node $\rightarrow$ Definitions}
% \label{editor:lst:nodes:sphere-node:definition}
\end{figure}

\newthought{The invocation of the node} is simply calling the above definition
using the parameters of the node, which is in this case the radius.

\newthought{The parameters are in case of implicit surfaces} uniform variables
of the type of the parameter, as implicit surfaces are rendered by the fragment
shader. The uniform variables are defined by a type and an identifier, whereas
in the case of parameters their identifier is used.

The position of the node is an indirect parameter, which is not defined by the
node's inputs. It will be setup by the node's parts.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap102}\raggedright\small
\NWtarget{nuweb146b}{} $\langle\,${\itshape Implicit sphere node invocations}\nobreak\ {\footnotesize {146b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
{
    "id_": "4cd369d2-c245-49d8-9388-6b9387af8376",
    "type": "implicit",
    "script": [
        "float s = sphere(",
        "    16d90b34-a728-4caa-b07d-a3244ecc87e3-position,",
        "    5c6a538-1dbc-4add-a15d-ddc4a5e553da",
        ");"
    ]
}|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb144}{144}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The position of the implicit sphere node as invocation.
  \newline{}\newline{}Implicit sphere node $\rightarrow$ Invocations}
% \label{editor:lst:nodes:sphere-node:invocations:position}
\end{figure}

\newthought{The parts of the node}, in this case it is only one part, contain
the body of the node. The body is about evaluating the inputs and passing them
on to a shader.

% TODO: Change this to C and use CFFI.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap103}\raggedright\small
\NWtarget{nuweb147}{} $\langle\,${\itshape Implicit sphere node parts}\nobreak\ {\footnotesize {147}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
{
    "id_": "74b73ce7-8c9d-4202-a533-c77aba9035a6",
    "name": "Implicit sphere node function",
    "type_": "implicit",
    "script": [
        "# -*- coding: utf-8 -*-",
        "",
        "from PyQt5 import QtGui",
        "",
        "",
        "class Class_ImplicitSphere(object):",
        "    def __init__(self):",
        "        self.position = QtGui.QVector3D()",
        "",
        "    def process(self, context, inputs):",
        "        shader = context.current_shader.program",
        "        ",
        "        radius = inputs[0].process(context).value",
        "        shader_radius_location = shader.uniformLocation(",
        "            \"f5c6a538-1dbc-4add-a15d-ddc4a5e553da\"",
        "        )",
        "        shader.setUniformValue(",
        "            shader_radius_location, radius",
        "        )",
        "        ",
        "        position = self.position",
        "        shader_position_location = shader.uniformLocation(",
        "            \"16d90b34-a728-4caa-b07d-a3244ecc87e3-position\"",
        "        )",
        "        shader.setUniformValue(",
        "            shader_position_location, position",
        "        )",
        "        ",
        "        return context"
    ]
}|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb144}{144}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The~\enquote{body} of the implicit sphere node as node part.
  \newline{}\newline{}Implicit sphere node $\rightarrow$ Parts}
% \label{editor:lst:nodes:sphere-node:parts:body}
\end{figure*}

\newthought{Connections are composed of an input and an output} plus a reference
to a part, as stated
in~\autoref{results:subsec:program:node-graph}~\enquote{\nameref{results:subsec:program:node-graph}}.
In this case there is exactly one input, the radius, and one output, an object
defined by implicit functions.

The radius is being defined by an input, which is therefore being referenced as
source. There is although no external node being referenced, as the radius is
of the atomic type float. Therefore the source node is 0, meaning it is an
internal reference. The input itself is used as part for the input.

The very same applies for the output of that connection. The radius is being
consumed by the first part of the node's part (which has only this part). As
this definition is within the same node, the target node is also 0. The part is
then being referenced by its identifier.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap104}\raggedright\small
\NWtarget{nuweb148}{} $\langle\,${\itshape Implicit sphere node connections}\nobreak\ {\footnotesize {148}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
{
    "source_node": "00000000-0000-0000-0000-000000000000",
    "source_part": "f5c6a538-1dbc-4add-a15d-ddc4a5e553da",
    "target_node": "00000000-0000-0000-0000-000000000000",
    "target_part": "74b73ce7-8c9d-4202-a533-c77aba9035a6"
}|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb144}{144}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Mapping of the connections of the implicit sphere node. Note that the
  inputs and outputs are internal, therefore the node references are 0.
  \newline{}\newline{}Implicit sphere node $\rightarrow$ Connections}
% \label{editor:lst:nodes:sphere-node:connections}
\end{figure}

\newthought{Now a very basic node is available}, but the node does not get
recognized by the application yet. As nodes are defined by external files, they
need to be searched, loaded and registered to make them available to the
application.

\newthought{Therefore the node controller is introduced}, which will manage the
node definitions.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap105}\raggedright\small
\NWtarget{nuweb149a}{} $\langle\,${\itshape Node controller declarations}\nobreak\ {\footnotesize {149a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class NodeController(QtCore.QObject):
    """The node controller.

    A controller managing nodes.
    """

    # Constants
    NODES_PATH = "nodes"
    NODES_EXTENSION = "node"
    ROOT_NODE_ID = uuid.UUID(
        "026c04d0-36d2-49d5-ad15-f4fb87fe8eeb"
    )
    ROOT_NODE_OUTPUT_ID = uuid.UUID(
        "a8fadcfc-4e19-4862-90cf-a262eef2219b"
    )

    # Signals
    |\hbox{$\langle\,${\itshape Node controller signals}\nobreak\ {\footnotesize \NWlink{nuweb184b}{184b}, \ldots\ }$\,\rangle$}|

    |\hbox{$\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize \NWlink{nuweb149b}{149b}, \ldots\ }$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize \NWlink{nuweb150a}{150a}, \ldots\ }$\,\rangle$}|

    |\hbox{$\langle\,${\itshape Node controller slots}\nobreak\ {\footnotesize \NWlink{nuweb213}{213}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb210b}{210b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the node controller.
  \newline{}\newline{}Editor $\rightarrow$ Node controller}
% \label{editor:lst:node-controller}
\end{figure}

\newthought{The node controller assumes}, that all node definitions are placed
within the~\verb=nodes= sub directory of the application's working directory.
Further it assumes, that node definition files use the~\verb=node= extension.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap106}\raggedright\small
\NWtarget{nuweb149b}{} $\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize {149b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, parent=None):
    """ Constructor. 

    :param parent: the parent of this node controller.
    :type  parent: QtCore.QObject
    """

    super(NodeController, self).__init__(parent)

    self.nodes_path = "{current_dir}{sep}{nodes_path}".format(
        current_dir=os.getcwd(),
        sep=os.sep,
        nodes_path=NodeController.NODES_PATH
    )
    self.nodes_extension = NodeController.NODES_EXTENSION|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb149b}{149b}\NWlink{nuweb151b}{, 151b}\NWlink{nuweb158b}{, 158b}\NWlink{nuweb177}{, 177}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the node controller.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Constructor}
% \label{editor:lst:node-controller:constructor}
\end{figure}

\newthought{The node controller will then scan} that directory containing the
node definitions and load each one.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap107}\raggedright\small
\NWtarget{nuweb150a}{} $\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize {150a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def load_nodes(self):
    """Loads all files with the ending
    NodeController.NODES_EXTENSION
    within the NodeController.NODES_PATH directory, relative to
    the current working directory.
    """

    |\hbox{$\langle\,${\itshape Node controller load nodes method}\nobreak\ {\footnotesize \NWlink{nuweb157a}{157a}, \ldots\ }$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb150a}{150a}\NWlink{nuweb161}{, 161}\NWlink{nuweb167}{, 167}\NWlink{nuweb176}{, 176}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A method that loads node definitions from external files from within
  the node controller.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Methods}
% \label{editor:lst:node-controller:methods:load-nodes}
\end{figure}

\newthought{Node definitions will contain parts.} The parts within a node
definition are used to create corresponding parts within instances of
themselves. The parts are able to create values based on the atomic types
through functions.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap108}\raggedright\small
\NWtarget{nuweb150b}{} $\langle\,${\itshape Node definition part domain model declarations}\nobreak\ {\footnotesize {150b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeDefinitionPart(object):
    """Represents a part of the definition of a node."""

    # Signals

    |\hbox{$\langle\,${\itshape Node definition part domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb151a}{151a}}$\,\rangle$}|

    # Methods

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of a part of a node definition.
  \newline{}\newline{}Editor $\rightarrow$ Node definition part}
% \label{editor:lst:node-definition-part}
\end{figure}

\newthought{The part of a node definition} holds an identifier as well as an
expression to create a function for creating and handling values which will be
used when evaluating a node. Further it provides a function which allows to
instantiate itself as part of a node (instance).

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap109}\raggedright\small
\NWtarget{nuweb151a}{} $\langle\,${\itshape Node definition part domain model constructor}\nobreak\ {\footnotesize {151a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, id_):
    """Constructor.

    :param id_: the globally unique identifier of the part of
                the node definition.
    :type  id_: uuid.uuid4
    """

    self.id_    = id_
    self.type_  = None
    self.name   = None
    self.script = None
    self.parent = None

    # This property is used when evaluating node instances using
    # this node definition
    self.function_creator = lambda: create_value_function(
        parameter.FloatValue(0)
    )

    # This property will be used to create/instantiate a part of
    # a node instance
    self.creator_function = None
    |\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb150b}{150b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the node definition part.
  \newline{}\newline{}Editor $\rightarrow$ Node definition part}
% \label{editor:lst:node-definition-part:constructor}
\end{figure}

\newthought{The node controller needs to keep track} of node definition parts, as
they are a central aspect and may be reused.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap110}\raggedright\small
\NWtarget{nuweb151b}{} $\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize {151b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.node_definition_parts = {}
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb149b}{149b}\NWlink{nuweb151b}{, 151b}\NWlink{nuweb158b}{, 158b}\NWlink{nuweb177}{, 177}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The node controller keeps track of node definition parts.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Constructor}
% \label{editor:lst:node-controller:constructor:node-definition-parts}
\end{figure}

The code snippet defining the constructor of a node definition
part,~\cref{scrap109}, uses a function
called~\verb=create_value_function= of the~\verb=functions= module.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap111}\raggedright\small
\NWtarget{nuweb152}{} $\langle\,${\itshape Node domain module methods}\nobreak\ {\footnotesize {152}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_value_function(value):
    """Creates a new value function using the provided value.

    :param value: the value which the function shall have.
    :type  value: qde.editor.domain.parameter.Value
    """

    value_function = NodePart.ValueFunction()
    value_function.value = value.clone()

    return value_function
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb152}{152}\NWlink{nuweb172}{, 172}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Helper function which creates a value function from the given value.
  \newline{}\newline{}Editor $\rightarrow$ Node domain model $\rightarrow$
  Module methods}
% \label{editor:lst:node-domain-model:module-methods:create-value-function}
\end{figure}

\newthought{That brings up the concept of value functions.} Value functions are
one of the building blocks of a node. They are used to evaluate a node
value-wise through its inputs.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap112}\raggedright\small
\NWtarget{nuweb153}{} $\langle\,${\itshape Node part domain model value function declarations}\nobreak\ {\footnotesize {153}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class ValueFunction(Function):
    """Class representing a value function for nodes."""

    def __init__(self):
        """Constructor."""

        super(NodePart.ValueFunction, self).__init__()
        self.value = None

    def clone(self):
        """Clones the currently set value function.

        :return: a clone of the currently set value function.
        :rtype: qde.editor.domain.node.NodePart.Function
        """

        new_function = create_value_function(self.value)
        new_function.node_part = self.node_part

        return new_function

    def process(self, context, inputs, output_index):
        """Processes the value function for the given context,
        the given inputs and the given index of the output.

        :param context: the context of the processing
        :type  context: qde.editor.domain.node.NodePartContext
        :param inputs: a list of inputs to process
        :type inputs: list
        :param output_index: the index of the output which shall
                             be used
        :type output_index: int

        :return: the context
        :rtype:  qde.editor.domain.node.NodePartContext
        """

        if not self.value.is_cachable or self.has_changed:
            if len(inputs) > 0:
                inputs[0].process(context, self.processing_index)
                value.set_value_from_context(context)
            else:
                self.value.set_value_in_context(context)

            self.has_changed = False
        else:
            self.value.set_value_in_context(context)

        # TODO: Handle events

        return context|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb155a}{155a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the value function class which is used within nodes.
  \newline{}\newline{}Editor $\rightarrow$ Value function}
% \label{editor:lst:value-function}
\end{figure}

\newthought{The value function of a node} may not be clear during the
initialization of the node or it may be simply be subject to change.
Therefore it makes sense to provide a default value function which gets used by
default.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap113}\raggedright\small
\NWtarget{nuweb154}{} $\langle\,${\itshape Node part domain model default value function declarations}\nobreak\ {\footnotesize {154}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class DefaultValueFunction(ValueFunction):
    """The default value function of a node part."""

    def __init__(self):
        """Constructor."""

        super(NodePart.DefaultValueFunction, self).__init__()

    def clone(self):
        """Returns itself as a default value function may not
        be cloned.

        :return: a self-reference.
        :rtype: DefaultValueFunction
        """

        return self

    def process(self, context, inputs, output_index):
        """Processes the default value function for the given
        context, the given inputs and the given index of the
        output.

        :param context: the context of the processing
        :type  context: qde.editor.domain.node.NodePartContext
        :param inputs: a list of inputs to process
        :type inputs: list
        :param output_index: the index of the output which shall
                             be used
        :type output_index: int

        :return: the context
        :rtype:  qde.editor.domain.node.NodePartContext
        """

        self.value.set_value_in_context(context)
        self.has_changed = False

        return context|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb155a}{155a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the default value function class, which is derived from
  the value function class.
  \newline{}\newline{}Editor $\rightarrow$ Default value function}
% \label{editor:lst:default-value-function}
\end{figure}

\newthought{The value function relies strongly on the concept of node parts},
which is not defined yet. A part of a node is actually an instance of an atomic
type (which is usually an input) within an instance of a node definition.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap114}\raggedright\small
\NWtarget{nuweb155a}{} $\langle\,${\itshape Node part domain model declarations}\nobreak\ {\footnotesize {155a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodePart(object):
    """Represents a part of a node."""

    |\hbox{$\langle\,${\itshape Node part domain model function declarations}\nobreak\ {\footnotesize \NWlink{nuweb156a}{156a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Node part domain model value function declarations}\nobreak\ {\footnotesize \NWlink{nuweb153}{153}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Node part domain model default value function declarations}\nobreak\ {\footnotesize \NWlink{nuweb154}{154}}$\,\rangle$}|

    # Signals

    |\hbox{$\langle\,${\itshape Node part domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb155b}{155b}}$\,\rangle$}|

    # Methods

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The node part class.
  \newline{}\newline{}Editor $\rightarrow$ Node part}
% \label{editor:lst:node-part}
\end{figure*}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap115}\raggedright\small
\NWtarget{nuweb155b}{} $\langle\,${\itshape Node part domain model constructor}\nobreak\ {\footnotesize {155b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
  def __init__(self, id_, default_function,
               type_=types.NodeType.GENERIC, script=None):
    """constructor.

    :param id_: the identifier of the node part.
    :type  id_: uuid.uuid4
    :param default_function: the default function of the part.
    :type default_function: function
    :param type_: the type of the node part.
    :type type_: qde.editor.foundation.types.NodeType
    :param script: the script of the part.
    :type script: str
    """

    self.id_              = id_
    self.function_        = default_function
    self.default_function = default_function
    self.script           = script
    self.type_            = type_|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb155a}{155a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the node part class.
  \newline{}\newline{}Editor $\rightarrow$ Node part}
% \label{editor:lst:node-part:constructor}
\end{figure}

\newthought{A part of a node has a function}, which gets called whenever a part
of a node is being processed.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap116}\raggedright\small
\NWtarget{nuweb156a}{} $\langle\,${\itshape Node part domain model function declarations}\nobreak\ {\footnotesize {156a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class Function(object):
    """Represents the function of a part of a node."""

    def __init__(self):
        """Constructor."""

        self.has_changed = True
        self.evaluation_index = 0
        self.changed_state = \
            types.StateChange.VALUE.value | \
            types.StateChange.SUBTREE.value

    def clone(self):
        """Clones the currently set function."""

        message = QtCore.QCoreApplication.translate(
            __class__.__name__,
            "This method must be implemented in a child class"
        )
        raise NotImplementedError(message)

    def process(self, context, inputs, output_index):
        """Processes the value function for the given context,
        the given inputs."""

        message = QtCore.QCoreApplication.translate(
            __class__.__name__,
            "This method must be implemented in a child class"
        )
        raise NotImplementedError(message)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb155a}{155a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the function class which is used in parts of nodes.
  \newline{}\newline{}Editor $\rightarrow$ Function}
% \label{editor:lst:function}
\end{figure}

\newthought{When a part of a node is being processed}, also its inputs are
processed. Whenever an input (value) changes, the node part needs to handle the
changes. There are three possible types of changes: nothing has changed, the
value (of the function) has changed or the sub tree (inputs) has changed.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap117}\raggedright\small
\NWtarget{nuweb156b}{} $\langle\,${\itshape Node part state changed declarations}\nobreak\ {\footnotesize {156b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class StateChange(enum.Enum):
    """Possible changes of state."""

    NOTHING  = 0
    VALUE    = 1
    SUBTREE  = 2|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb201}{201}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A class which holds the possible values of a state change of a node
  part.
  \newline{}\newline{}Editor $\rightarrow$ State change}
% \label{editor:lst:state-change}
\end{figure}

\newthought{Finally all nodes will be composed of atomic types.} When building
the node definition from the JSON input, the (atomic) part of the node
definition is fetched from the node controller. Therefore it is necessary to
provide parts for the atomic types before loading all the node definitions.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap118}\raggedright\small
\NWtarget{nuweb157a}{} $\langle\,${\itshape Node controller load nodes method}\nobreak\ {\footnotesize {157a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
for atomic_type in parameter.AtomicTypes.atomic_types:
    if atomic_type.id_ not in self.node_definition_parts:
        self.node_definition_parts[atomic_type.id_] = atomic_type
        self.logger.info(
            "Added atomic type %s: %s",
            atomic_type.type_, atomic_type.id_
        )
    else:
        self.logger.warn((
            "Already knowing node part for atomic type %s."
            "This should not happen"
        ), atomic_type.type_)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb157a}{157a}\NWlink{nuweb159}{, 159}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb150a}{150a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The node controller provides the atomic types which build the basis of
  the part of a node.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$ Methods
  $\rightarrow$ Load nodes}
% \label{editor:lst:node-controller:methods:load-nodes:atomic-types}
\end{figure}

\newthought{Having the atomic types available as parts}, the node definitions
themselves may be loaded. There is only one problem to that: there is nothing to
hold the node definitions. Therefore the node definition domain model is
introduced.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap119}\raggedright\small
\NWtarget{nuweb157b}{} $\langle\,${\itshape Node definition domain model declarations}\nobreak\ {\footnotesize {157b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeDefinition(object):
    """Represents the definition of a node."""

    # Signals

    |\hbox{$\langle\,${\itshape Node definition domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb158a}{158a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Node definition domain model methods}\nobreak\ {\footnotesize \NWlink{nuweb178}{178}, \ldots\ }$\,\rangle$}|

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of the node definition class, which represents the definition
  of a node.
  \newline{}\newline{}Editor $\rightarrow$ Node definition}
% \label{editor:lst:node-definition}
\end{figure}

\newthought{The definition of a node} is quite similar to a node itself. As the
definition of a node may be changed, the flag~\verb=was_changed= is added.
Further a node definition holds all instances of itself, meaning nodes.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap120}\raggedright\small
\NWtarget{nuweb158a}{} $\langle\,${\itshape Node definition domain model constructor}\nobreak\ {\footnotesize {158a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, id_):
    """Constructor.

    :param id_: the globally unique identifier of the node.
    :type  id_: uuid.uuid4
    """

    self.id_         = id_

    self.name        = ""
    self.description = ""
    self.parent      = None
    self.inputs      = []
    self.outputs     = []
    self.definitions = []
    self.invocations = []
    self.parts       = []
    self.nodes       = []
    self.connections = []
    self.instances   = []
    self.was_changed = False|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb157b}{157b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the node definition class.
  \newline{}\newline{}Editor $\rightarrow$ Node definition $\rightarrow$
  Constructor}
% \label{editor:lst:node-definition:constructor}
\end{figure}

\newthought{The node controller is now able} to instantiate nodes definitions
and keep them in a list. The controller manages both, the domain and the view
models. As they both share the same ID, as the view model is being created from
the data of the domain model, only one entry is necessary. The entry in the
dictionary will therefore hold a tuple, containing the domain and the view
model, identified by their common identifier.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap121}\raggedright\small
\NWtarget{nuweb158b}{} $\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize {158b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.node_definitions = {}
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb149b}{149b}\NWlink{nuweb151b}{, 151b}\NWlink{nuweb158b}{, 158b}\NWlink{nuweb177}{, 177}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The node controller holds a dictionary containing node definitions.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Constructor}
% \label{editor:lst:node-controller:constructor:node-definitions}
\end{figure}

\newthought{The node controller scans} the~\verb=node= sub directory, containing
the node definitions, for files ending in~\verb=node=.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap122}\raggedright\small
\NWtarget{nuweb159}{} $\langle\,${\itshape Node controller load nodes method}\nobreak\ {\footnotesize {159}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}

if os.path.exists(self.nodes_path):
    node_definition_files = glob.glob("{path}{sep}*.{ext}".format(
        path=self.nodes_path,
        sep=os.sep,
        ext=self.nodes_extension
    ))
    num_node_definitions = len(node_definition_files)
    if num_node_definitions > 0:
        self.logger.info(
            "Found %d node definition(s), loading.",
            num_node_definitions
        )
        t0 = time.perf_counter()
        for file_name in node_definition_files:
            self.logger.debug(
                "Found node definition %s, trying to load",
                file_name
            )
            node_definition = self.\
                load_node_definition_from_file_name(file_name)
            if node_definition is not None:
                node_definition_view_model =\
                node_gui_domain.NodeViewModel(
                    id_=node_definition.id_,
                    domain_object=node_definition
                )
                self.node_definitions[node_definition.id_] = (
                    node_definition,
                    node_definition_view_model
                )
                |\hbox{$\langle\,${\itshape Node controller load node definition emit}\nobreak\ {\footnotesize \NWlink{nuweb162}{162}}$\,\rangle$}|

        t1 = time.perf_counter()
        self.logger.info(
            "Loading node definitions took %.10f seconds",
            (t1 - t0)
        )
    else:
        message = QtCore.QCoreApplication.translate(
            __class__.__name__, "No node definitions found."
        )
        self.logger.warn(message)
else:
    message = QtCore.QCoreApplication.translate(
        __class__.__name__, "No node definitions found."
    )
    self.logger.warn(message)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb157a}{157a}\NWlink{nuweb159}{, 159}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb150a}{150a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The node controller loads and parses node definition files from the
  file system.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Methods $\rightarrow$ Load nodes}
% \label{editor:lst:node-controller:methods:load-nodes:laod}
\end{figure}

\newthought{If a file containing a node definition is found}, its identifier is
extracted from the file name. If the node definition is not known yet, it gets
loaded and added to the list of known node definitions.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap123}\raggedright\small
\NWtarget{nuweb161}{} $\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize {161}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def load_node_definition_from_file_name(self, file_name):
    """Loads a node definition from the given file name.
    If no such file exists, None is returned.

    :param file_name: the file name to load.
    :type  file_name: str

    :return: the loaded node definition and its identifier or
             None
    :rtype:  qde.editor.domain.node.NodeDefinition or None
    """

    if not os.path.exists(file_name):
        self.logger.warn((
            "Tried to load node definition from file %s, "
            "but the file does not exist"
        ), file_name)
        return None

    # Extract the definition identifier from the file name,
    # which is "uuid4.node".
    definition_id = os.path.splitext(
        os.path.basename(file_name)
    )[0]

    if definition_id in self.node_definitions:
        self.logger.warn(
            ("Should load node definition from file %s,"
            "but is already loaded"),
            file_name
        )
        return self.node_definitions[definition_id]

    try:
        with open(file_name) as definition_fh:
            node_definition = json.Json.load_node_definition(
                self, definition_fh
            )
            self.logger.debug(
                "Loaded node definition %s from file %s",
                definition_id, file_name
            )
            # TODO: Trigger (loading) callback
            return node_definition
    except json.json.decoder.JSONDecodeError as exc:
        self.logger.warn(
            ("There was an error loading the node"
             "definition %s: %s"),
            definition_id, exc
        )
        return None|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb150a}{150a}\NWlink{nuweb161}{, 161}\NWlink{nuweb167}{, 167}\NWlink{nuweb176}{, 176}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A method which tries to load a node definition from the
  file system using the provided file name.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Methods $\rightarrow$ Load node definition from file name}
% \label{editor:lst:node-controller:methods:load-node-definition-from-file-name}
\end{figure}

\newthought{Whenever a new node definition gets loaded}, other components need
to be informed about the fact, that a new node definition is available. However,
as the signal emits a view model, the loaded node definition cannot be emitted
directly. Instead a view model needs to be created, which will then be emitted.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap124}\raggedright\small
\NWtarget{nuweb162}{} $\langle\,${\itshape Node controller load node definition emit}\nobreak\ {\footnotesize {162}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.do_add_node_view_definition.emit(node_definition_view_model)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb53}{53}\NWlink{nuweb159}{, 159}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Whenever a new node definition gets loaded, the node controller emits a
  corresponding signal containing the node view model for the loaded node definition.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Methods $\rightarrow$ Load node definitions}
% \label{editor:lst:node-controller:methods:load-node-definitions:do-add-node-view-definition}
\end{figure}

\newthought{The loading of the node definition itself} is simply about parsing the various
sections and handling them correspondingly. To prevent the node controller from
being bloated, the parsing is done in a separate module responsible for JSON
specific tasks.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap125}\raggedright\small
\NWtarget{nuweb163}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {163}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def load_node_definition(cls, node_controller, json_file_handle):
    """Loads a node definition from given JSON input.

    :param node_controller: reference to the node controller
    :type node_controller: qde.editor.application.node.\
                           NodeController
    :param json_file_handle: an open file handle containing
                             JSON data
    :type json_file_handle: file

    :return: a node definition
    :rtype: qde.editor.domain.node.NodeDefinition
    """

    o = json.load(json_file_handle)

    name        = str(o['name'])
    id_         = uuid.UUID(o['id_'])
    description = str(o['description'])

    |\hbox{$\langle\,${\itshape Parse node definition inputs}\nobreak\ {\footnotesize \NWlink{nuweb164a}{164a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Parse node definition outputs}\nobreak\ {\footnotesize \NWlink{nuweb164b}{164b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Parse node definition children}\nobreak\ {\footnotesize \NWlink{nuweb164c}{164c}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Parse node definition connections}\nobreak\ {\footnotesize \NWlink{nuweb164d}{164d}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Parse node definition definitions}\nobreak\ {\footnotesize \NWlink{nuweb165a}{165a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Parse node definition invocations}\nobreak\ {\footnotesize \NWlink{nuweb165b}{165b}}$\,\rangle$}|

    node_definition             = node.NodeDefinition(id_)
    node_definition.name        = name
    node_definition.description = description
    node_definition.inputs      = inputs
    node_definition.outputs     = outputs
    node_definition.nodes       = node_definitions
    node_definition.connections = connections
    node_definition.definitions = definitions
    node_definition.invocations = invocations

    # TODO: Check if this part can be above the def. instance
    |\hbox{$\langle\,${\itshape Parse node definition parts}\nobreak\ {\footnotesize \NWlink{nuweb165c}{165c}}$\,\rangle$}|
    node_definition.parts = parts

    # TODO: Do a consistency check
    node_definition.was_changed = False

    return node_definition|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb163}{163}\NWlink{nuweb166}{, 166}\NWlink{nuweb173}{, 173}\NWlink{nuweb175}{, 175}\NWlink{nuweb180}{, 180}\NWlink{nuweb219}{, 219}\NWlink{nuweb220}{, 220}\NWlink{nuweb221}{, 221}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb218b}{218b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A class method of the JSON module, which loads a node definition from a
  file handle (pointing to a JSON file containing a node definition).
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Load node definition}
% \label{editor:lst:json:methods:load-node-definition}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap126}\raggedright\small
\NWtarget{nuweb164a}{} $\langle\,${\itshape Parse node definition inputs}\nobreak\ {\footnotesize {164a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
inputs = []
for input in o['inputs']:
    node_definition_input = cls.build_node_definition_input(
        node_controller, input
    )
    inputs.append(node_definition_input)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb163}{163}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The inputs of a node definition are parsed and then added to
the list of known inputs.
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Load node definition}
% \label{editor:lst:json:methods:load-node-definition:parse-inputs}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap127}\raggedright\small
\NWtarget{nuweb164b}{} $\langle\,${\itshape Parse node definition outputs}\nobreak\ {\footnotesize {164b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
outputs = []
for output in o['outputs']:
    node_definition_output = cls.build_node_definition_output(
        node_controller, output
    )
    outputs.append(node_definition_output)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb163}{163}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The outputs of a node definition are parsed and then added to
the list of known outputs.
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Load node definition}
% \label{editor:lst:json:methods:load-node-definition:parse-outputs}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap128}\raggedright\small
\NWtarget{nuweb164c}{} $\langle\,${\itshape Parse node definition children}\nobreak\ {\footnotesize {164c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
node_definitions = {}
for node_def in o['nodes']:
    definition_id, node_definition = cls.build_node_definition(
        node_def
    )
    node_definitions[definition_id] = node_definition|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb163}{163}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The child nodes of a node definition are parsed and then added to
the list of known child nodes.
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Load node definition}
% \label{editor:lst:json:methods:load-node-definition:parse-children}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap129}\raggedright\small
\NWtarget{nuweb164d}{} $\langle\,${\itshape Parse node definition connections}\nobreak\ {\footnotesize {164d}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
connections = []
for conn in o['connections']:
    connection = cls.build_node_definition_connection(conn)
    connections.append(connection)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb163}{163}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The connections of a node definition are parsed and then added to
the list of known connections.
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Load node definition}
% \label{editor:lst:json:methods:load-node-definition:parse-connections}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap130}\raggedright\small
\NWtarget{nuweb165a}{} $\langle\,${\itshape Parse node definition definitions}\nobreak\ {\footnotesize {165a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
definitions = []
for d in o['definitions']:
    definition = cls.build_node_definition_definition(d)
    definitions.append(definition)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb163}{163}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The definitions of a node definition are parsed and then added to
the list of known definitions.
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Load node definition}
% \label{editor:lst:json:methods:load-node-definition:parse-definitions}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap131}\raggedright\small
\NWtarget{nuweb165b}{} $\langle\,${\itshape Parse node definition invocations}\nobreak\ {\footnotesize {165b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
invocations = []
for i in o['invocations']:
    invocation = cls.build_node_definition_invocation(i)
    invocations.append(invocation)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb163}{163}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The invocations of a node definition are parsed and then added to
the list of known invocations.
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Load node definition}
% \label{editor:lst:json:methods:load-node-definition:parse-invocations}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap132}\raggedright\small
\NWtarget{nuweb165c}{} $\langle\,${\itshape Parse node definition parts}\nobreak\ {\footnotesize {165c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
parts = []
for p in o['parts']:
    part = cls.build_node_definition_part(
        node_controller, node_definition, p
    )
    parts.append(part)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb163}{163}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The parts of a node definition are parsed and then added to
the list of known parts.
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Load node definition}
% \label{editor:lst:json:methods:load-node-definition:parse-parts}
\end{figure}

\newthought{Not all parts of node definitions are defined yet}: inputs, outputs,
other node definitions, connections, definitions, invocations and parts.First
the building of the node definition inputs is defined.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap133}\raggedright\small
\NWtarget{nuweb166}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {166}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def build_node_definition_input(cls, node_controller, json_input):
    """Builds and returns a node definition input from the given
    JSON input data.

    :param node_controller: a reference to the node controller
    :type  node_controller: qde.editor.application.node.NodeController
    :param json_input: the input in JSON format
    :type  json_input: dict

    :return: a node definition input
    :rtype:  qde.editor.domain.node.NodeDefinitionInput
    """

    input_id             = uuid.UUID(json_input['id_'])
    name                 = str(json_input['name'])
    atomic_id            = uuid.UUID(json_input['atomic_id'])
    description          = str(json_input['description'])
    node_definition_part = node_controller.\
        get_node_definition_part(
                atomic_id
    )

    default_value_str = ""
    default_value_entry = json_input['default_value']
    default_value = parameter.create_value(
        default_value_entry['type_'],
        default_value_entry['value']
    )

    min_value = float(json_input['min_value'])
    max_value = float(json_input['max_value'])

    node_definition_input = node.NodeDefinitionInput(
        input_id,
        name,
        node_definition_part,
        default_value
    )
    node_definition_input.description = description
    node_definition_input.min_value = min_value
    node_definition_input.max_value = max_value

    cls.logger.debug(
        "Built node definition input for node definition %s",
        atomic_id
    )
    return node_definition_input
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb163}{163}\NWlink{nuweb166}{, 166}\NWlink{nuweb173}{, 173}\NWlink{nuweb175}{, 175}\NWlink{nuweb180}{, 180}\NWlink{nuweb219}{, 219}\NWlink{nuweb220}{, 220}\NWlink{nuweb221}{, 221}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb218b}{218b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A class method of the JSON module, which builds the input of a node
  definition from a file handle (pointing to a JSON file containing a node
  definition).
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Build node definition input}
% \label{editor:lst:json:methods:build-node-definition-input}
\end{figure}

\newthought{There are a few things missing}, which are used in the above code
fragment: the possibility to create values from given parameters, the actual
node definition input as domain model and getting the node definition part
identified by the given atomic identifier.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap134}\raggedright\small
\NWtarget{nuweb167}{} $\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize {167}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def get_node_definition_part(self, id_):
    """Returns the node definition part identified by the given
    identifier.

    If no such part is available, a generic part with that
    identifier is being created.

    :param id_: the identifier of the part of the node definition
                to get.
    :type  id_: uuid.uuid4

    :return: the node definition part identified by the given
             identifier.
    :rtype: qde.editor.domain.node.NodeDefinitionPart
    """

    if str(id_) not in self.node_definition_parts:
        self.logger.warn((
            "Part %s of the node definition was not found."
            "Creating a generic one."
        ), id_)

        type_ = types.NodeType.GENERIC
        def create_func(id_, default_function, name, type_):
            node_part = node.NodePart(id_, None)
            node_part.type_ = type_
            node_part.name = name
            return node_part
        node_definition_part = node.NodeDefinitionPart(id_)
        node_definition_part.type_ = type_
        node_definition_part.creator_function = create_func
        self.node_definition_parts[id_] = node_definition_part
        return node_definition_part
    else:
        return self.node_definition_parts[str(id_)]
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb150a}{150a}\NWlink{nuweb161}{, 161}\NWlink{nuweb167}{, 167}\NWlink{nuweb176}{, 176}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A method of the node controller, which returns a node definition part
  by a provided identifier. If no node definition part is found for the given
  identifier, a new node definition part is created.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Methods $\rightarrow$ Get node definition part}
% \label{editor:lst:node-controller:methods:get-node-definition-part}
\end{figure}

\newthought{The creation of values from given parameters} is done within the
parameter module, as this is something very parameter specific. Therefore a
static method is defined, which returns an instance of an atomic type, e.g.\ a
float value or a scene.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap135}\raggedright\small
\NWtarget{nuweb168}{} $\langle\,${\itshape Parameter domain module methods}\nobreak\ {\footnotesize {168}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_value(type_, value_string):
    """Creates an object of the given type with the given value.

    :param type_: the type of the value to create.
    :type  type_: str
    :param value_string: the value that the value shall have.
    "type  value_string: str

    :return: a value-type of the given type with the given value.
    :rtype: qde.editor.domain.parameter.Value
    """

    if type_.lower() == "float":
        float_value = float(value_string)
        return FloatValue(float_value)
    elif type_.lower() == "text":
        return TextValue(value_string)
    elif type_.lower() == "image":
        return ImageValue()
    elif type_.lower() == "scene":
        return SceneValue()
    elif type_.lower() == "generic":
        return GenericValue()
    elif type_.lower() == "dynamic":
        return DynamicValue()
    elif type_.lower() == "mesh":
        return MeshValue()
    elif type_.lower() == "implicit":
        return ImplicitValue()
    else:
        message = QtCore.QCoreApplication.translate(
            __module__.__name__, "Unknown type for value provided"
        )
        raise Exception(message)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Method of the parameter module, which creates an object of a specific
  value instance based on the provided type of the value.
  \newline{}\newline{}Editor $\rightarrow$ Parameter $\rightarrow$
  Create value}
% \label{editor:lst:parameter:create-value}
\end{figure}

\newthought{For the specific value instances} a generic value interface is
defined. This interface holds a reference to the atomic type of the value and
defines what type the function of a value is.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap136}\raggedright\small
\NWtarget{nuweb169a}{} $\langle\,${\itshape Parameter domain model value generic interface}\nobreak\ {\footnotesize {169a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class ValueInterface(object):
    """Generic value interface."""

    def __init__(self):
        """Constructor."""

        self.function_type = None

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        message = QtCore.QCoreApplication.translate(
            __module__.__name__,
            "This method must be implemented in a child class"
        )
        raise NotImplementedError(message)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Interface as basis for the value specific instances.
  \newline{}\newline{}Editor $\rightarrow$ Parameter $\rightarrow$
  Value interface}
% \label{editor:lst:parameter:value-interface}
\end{figure}

Then an interface for setting and getting values is defined.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap137}\raggedright\small
\NWtarget{nuweb169b}{} $\langle\,${\itshape Parameter domain model value interface}\nobreak\ {\footnotesize {169b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class Value(ValueInterface):
    """Value interface for setting and getting values."""

    def __init__(self, value):
        """Constructor.

        :param value: the value that shall be held
        :type  value: object
        """

        super(Value, self).__init__()
        self.value = value|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Class which provides an interface to the value of the value specific
  instances.
  \newline{}\newline{}Editor $\rightarrow$ Parameter $\rightarrow$
  Value}
% \label{editor:lst:parameter:value}
\end{figure}

\newthought{Now the specific value types are implemented}, based either on the
generic or the concrete value interface, depending on the type. Here just two
implementations are given as an example. The other implementations can be found
at~\autoref{chap:code-fragments}~\enquote{\nameref{chap:code-fragments}}.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap138}\raggedright\small
\NWtarget{nuweb170a}{} $\langle\,${\itshape Parameter domain model float value}\nobreak\ {\footnotesize {170a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class FloatValue(Value):
    """A class holding float values."""

    def __init__(self, float_value):
        """Constructor.

        :param float_value: the float value that shall be held
        :type  float_value: float
        """

        super(FloatValue, self).__init__(float_value)
        self.function_type = types.NodeType.FLOAT

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return FloatValue(self.value)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of the float value type.
  \newline{}\newline{}Editor $\rightarrow$ Parameter $\rightarrow$
  FloatValue}
% \label{editor:lst:parameter:float-value}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap139}\raggedright\small
\NWtarget{nuweb170b}{} $\langle\,${\itshape Parameter domain model scene value}\nobreak\ {\footnotesize {170b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class SceneValue(ValueInterface):
    """A class holding scene values."""

    def __init__(self):
        """Constructor."""

        super(SceneValue, self).__init__()
        self.function_type = types.NodeType.SCENE

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return SceneValue()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of the scene value type.
  \newline{}\newline{}Editor $\rightarrow$ Parameter $\rightarrow$
  SceneValue}
% \label{editor:lst:parameter:scene-value}
\end{figure}

\newthought{The definition of the input of a node definition} is still missing
however.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap140}\raggedright\small
\NWtarget{nuweb171a}{} $\langle\,${\itshape Node definition input domain model declarations}\nobreak\ {\footnotesize {171a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeDefinitionInput(object):
    """Represents an input of a definition of a node."""

    # Signals

    |\hbox{$\langle\,${\itshape Node definition input domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb171b}{171b}}$\,\rangle$}|

    # Methods

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of the input of the definition of a node.
  \newline{}\newline{}Editor $\rightarrow$ Node definition input}
% \label{editor:lst:node-definition-input}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap141}\raggedright\small
\NWtarget{nuweb171b}{} $\langle\,${\itshape Node definition input domain model constructor}\nobreak\ {\footnotesize {171b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, id_, name, node_definition_part, default_value):
    """Constructor.

    :param id_: the identifier of the definition
    :type  id_: uuid.uuid4
    :param name: the name of the definition
    :type  name: str
    :param node_definition_part: the atomic part of the
                                 node definition
    :type node_definition_part: TODO
    :param default_value: the default value of the input
    :type default_value: qde.editor.domain.parameter.Value
    """

    self.id_                  = id_
    self.name                 = name
    self.node_definition_part = node_definition_part
    self.description          = ""
    self.min_value            = -100000
    self.max_value            = 100000

    self.default_function = create_default_value_function(
        default_value
    )|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb171a}{171a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the input of the definition of a node.
  \newline{}\newline{}Editor $\rightarrow$ Node definition input $\rightarrow$
  Constructor}
% \label{editor:lst:node-definition-input:constructor}
\end{figure}

\newthought{The code snippet defining the constructor of a node definition
input} uses a function called~\verb=create_default_value_function= of
the~\verb=functions= module. This function creates a default value function
based on the given default value.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap142}\raggedright\small
\NWtarget{nuweb172}{} $\langle\,${\itshape Node domain module methods}\nobreak\ {\footnotesize {172}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_default_value_function(value):
    """Creates a new default value function using the provided
    value.

    :param value: the value which the function shall have.
    :type  value: qde.editor.domain.parameter.Value
    """

    value_function = NodePart.DefaultValueFunction()
    value_function.value = value.clone()

    return value_function|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb152}{152}\NWlink{nuweb172}{, 172}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Function that creates a default value function based on a provided
  value.
  \newline{}\newline{}Editor $\rightarrow$ Node $\rightarrow$
  Methods $\rightarrow$ Create default value function}
% \label{editor:lst:node:create-default-value-function}
\end{figure}

\newthought{With this last implementation} all the parts needed for creating and
handling node definition inputs are defined, which leads to the next
implementation. The outputs of a node definition. The outputs are in the same
way implemented as the inputs of a node definition.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap143}\raggedright\small
\NWtarget{nuweb173}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {173}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def build_node_definition_output(cls, node_controller, json_input):
    """Builds and returns a node definition output from the given
    JSON input data.

    :param node_controller: a reference to the node controller
    :type  node_controller: qde.editor.application.node.NodeController
    :param json_input: the input in JSON format
    :type  json_input: dict

    :return: a node definition output
    :rtype:  qde.editor.domain.node.NodeDefinitionOutput
    """

    output_id             = uuid.UUID(json_input['id_'])
    name                 = str(json_input['name'])
    atomic_id            = uuid.UUID(json_input['atomic_id'])
    node_definition_part = node_controller.get_node_definition_part(
        atomic_id
    )

    node_definition_output = node.NodeDefinitionOutput(
        output_id,
        name,
        node_definition_part
    )

    cls.logger.debug(
        "Built node definition output for node definition %s",
        atomic_id
    )
    return node_definition_output
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb163}{163}\NWlink{nuweb166}{, 166}\NWlink{nuweb173}{, 173}\NWlink{nuweb175}{, 175}\NWlink{nuweb180}{, 180}\NWlink{nuweb219}{, 219}\NWlink{nuweb220}{, 220}\NWlink{nuweb221}{, 221}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb218b}{218b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A class method of the JSON module, which builds the output of a node
  definition from a file handle (pointing to a JSON file containing a node
  definition).
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Build node definition output}
% \label{editor:lst:json:methods:build-node-definition-output}
\end{figure}

\newthought{The domain model of the node definition output} is very similar to
the input, has less attributes although.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap144}\raggedright\small
\NWtarget{nuweb174a}{} $\langle\,${\itshape Node definition output domain model declarations}\nobreak\ {\footnotesize {174a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeDefinitionOutput(object):
    """Represents an output of a definition of a node."""

    # Signals

    |\hbox{$\langle\,${\itshape Node definition output domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb174b}{174b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Node definition output domain model methods}\nobreak\ {\footnotesize \NWlink{nuweb214b}{214b}}$\,\rangle$}|

    # Slots
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Implementation of the output of the definition of a node.
  \newline{}\newline{}Editor $\rightarrow$ Node definition output}
% \label{editor:lst:node-definition-output}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap145}\raggedright\small
\NWtarget{nuweb174b}{} $\langle\,${\itshape Node definition output domain model constructor}\nobreak\ {\footnotesize {174b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, id_, name, node_definition_part):
    """Constructor.

    :param id_: the identifier of the definition
    :type  id_: uuid.uuid4
    :param name: the name of the definition
    :type  name: str
    :param node_definition_part: the atomic part of the node
                                 definition
    :type node_definition_part: qde.editor.domain.node.\
                                NodeDefinitionPart
    """

    self.id_                  = id_
    self.name                 = name
    self.node_definition_part = node_definition_part|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb174a}{174a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Constructor of the output of the definition of a node.
  \newline{}\newline{}Editor $\rightarrow$ Node definition input $\rightarrow$
  Constructor}
% \label{editor:lst:node-definition-input:constructor}
\end{figure}

\newthought{A node definition may contain references} to other node definitions,
therefore it is necessary to parse them. The parsing is similar to that of the
inputs and outputs.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap146}\raggedright\small
\NWtarget{nuweb175}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {175}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def build_node_definition(cls, node_controller, json_input):
    """Builds and returns a node definition from the given JSON
    input data.

    :param node_controller: a reference to the node controller
    :type  node_controller: qde.editor.application.node.\
                            NodeController
    :param json_input: the input in JSON format
    :type  json_input: dict

    :return: a dictionary containing the node definition at the
             index of the definition identifier.
    :rtype:  dict
    """

    definition_id   = uuid.UUID(json_input['id_'])
    atomic_id       = uuid.UUID(json_input['atomic_id'])

    node_definition, node_view_model = node_controller.\
        get_node_definition(
                atomic_id
    )

    cls.logger.debug(
        "Built node definition for node definition %s",
        atomic_id
    )
    return (definition_id, node_definition)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb163}{163}\NWlink{nuweb166}{, 166}\NWlink{nuweb173}{, 173}\NWlink{nuweb175}{, 175}\NWlink{nuweb180}{, 180}\NWlink{nuweb219}{, 219}\NWlink{nuweb220}{, 220}\NWlink{nuweb221}{, 221}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb218b}{218b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A class method of the JSON module, which builds the definition of a node
  from a file handle (pointing to a JSON file containing a node
  definition).
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Build node definition}
% \label{editor:lst:json:methods:build-node-definition}
\end{figure}

As can be seen in the above code fragment, the node definition is returned by
the node controller. This is very similar to getting the node definition part
from the node controller.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap147}\raggedright\small
\NWtarget{nuweb176}{} $\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize {176}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def get_node_definition(self, id_):
    """Returns the node definition identified by the given
    identifier.

    If no such definition is available, it will be tried to load
    the definition. If this is not possible as well, None will
    be returned.

    :param id_: the identifier of the node definition to get.
    :type  id_: uuid.uuid4

    :return: the node definition identified by the given
             identifier or None.
    :rtype:  qde.editor.domain.node.NodeDefinition or None
    """

    self.logger.debug(
        "Getting node definition %s",
        id_
    )

    if str(id_) in self.node_definitions:
        return self.node_definitions[str(id_)]
    elif self.root_node is not None and id_ == self.root_node.id_:
        return self.root_node
    else:
        # The node definition was not found, try to load it
        # from node definition files.
        file_name = os.path.join(
            self.nodes_path,
            id_,
            self.nodes_extension
        )
        node_definition = self.\
            load_node_definition_from_file_name(
                    file_name
        )
        if node_definition is not None:
            node_definition_view_model = node_gui_domain.\
                NodeViewModel(
                        id_=node_definition.id_,
                        domain_object=node_definition
            )
            self.node_definitions[node_definition.id_] = (
                node_definition,
                node_view_model
            )
            return (node_definition, node_view_model)
        else:
            return None|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb150a}{150a}\NWlink{nuweb161}{, 161}\NWlink{nuweb167}{, 167}\NWlink{nuweb176}{, 176}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A method of the node controller, which returns a node definition
  by a provided identifier. If no node definition is found for the given
  identifier, a new node definition is created by loading the definition from
  the file system.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Methods $\rightarrow$ Get node definition}
% \label{editor:lst:node-controller:methods:get-node-definition}
\end{figure}

\newthought{The node controller holds a reference to the root node} of the root
scene of the system. This scene acts as an entry point when evaluating the scene
graph.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap148}\raggedright\small
\NWtarget{nuweb177}{} $\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize {177}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    # TODO: Load from configuration?
    self.root_node = node_domain.NodeDefinition(
        NodeController.ROOT_NODE_ID
    )
    self.root_node.name = QtCore.QCoreApplication.translate(
        __class__.__name__,
        'Root'
    )
    root_node_output = node_domain.NodeDefinitionOutput(
        NodeController.ROOT_NODE_OUTPUT_ID,
        QtCore.QCoreApplication.translate(
            __class__.__name__,
            'Output'
        ),
        parameter.AtomicTypes.Generic
    )
    self.root_node.add_output(root_node_output)
    self.logger.debug(
        "Created root node %s",
        NodeController.ROOT_NODE_ID
    )|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb149b}{149b}\NWlink{nuweb151b}{, 151b}\NWlink{nuweb158b}{, 158b}\NWlink{nuweb177}{, 177}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The root node of the system is manually created by the node controller
  and is also a node definition.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$
  Constructor}
% \label{editor:lst:node-controller:constructor:add-root-node}
\end{figure}

\newthought{Currently there is no possibility to add outputs} to a node
definition. Adding an output simply adds that output to the list of outputs the
node definition has. Furthermore that output needs to added for each instance of
that node definition as well.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap149}\raggedright\small
\NWtarget{nuweb178}{} $\langle\,${\itshape Node definition domain model methods}\nobreak\ {\footnotesize {178}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def add_output(self, node_definition_output):
    """Adds the given output to the beginning of the list of
outputs and also to all instances of this node definition.

    :param node_definition_output: the output to add.
    :type  node_definition_output: qde.editor.domain.node.\
                           NodeDefinitionOutput
    """

    self.add_output_at(len(self.outputs), node_definition_output)

def add_output_at(self, index, node_definition_output):
    """Adds the given output to the list of outputs at the given
    index position and also to all instances of this node
    definition.

    :param index: the position in the list of outputs where the
                  new output shall be added at.
    :type  index: int
    :param node_definition_output: the output to add.
    :type  node_definition_output: qde.editor.domain.node.\
                                   NodeDefinitionOutput

    :raise: an index error when the given index is not valid.
    :raises: IndexError
    """

    if index < 0 or index > len(self.outputs):
        raise IndexError()

    self.outputs.insert(index, node_definition_output)

    for instance in self.instances:
        instance.add_output_at(
            index,
            node_definition_output.create_instance()
        )

    # TODO: Insert connection if output is atomic

    self.was_changed = True|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb178}{178}\NWlink{nuweb179}{, 179}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb157b}{157b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Methods which add a given output of a node definition to a node
  definition. The first method adds the output at the end of the list of
  outputs, the second adds the output at the given index.
  \newline{}\newline{}Editor $\rightarrow$ Node definition $\rightarrow$
  Methods}
% \label{editor:lst:node-definition:methods:add-output}
\end{figure}

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap150}\raggedright\small
\NWtarget{nuweb179}{} $\langle\,${\itshape Node definition domain model methods}\nobreak\ {\footnotesize {179}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
# TODO: Describe this properly
|\normalfont{}\fontfamily{}|property
def type_(self):
    """Return the type of the node, determined by its primary
    output. If no primary output is given, it is assumed that
    the node is of generic type."""

    type_ = types.NodeType.GENERIC

    if len(self.outputs) > 0:
        type_ = self.outputs[0].node_definition_part.type_

    return type_|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb178}{178}\NWlink{nuweb179}{, 179}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb157b}{157b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Type property of a node definition. If the node definition uses
  outputs, the type is derived by its primary output. Otherwise a generic type
  is assumed.
  \newline{}\newline{}Editor $\rightarrow$ Node definition $\rightarrow$
  Methods}
% \label{editor:lst:node-definition:methods:type}
\end{figure}

Having the reading and parsing of inputs, outputs and other node definition
implemented, the reading and parsing of connections, definitions, invocations
and parts still remains.

\newthought{The reading and parsing} of connections, definitions and invocation
is very straightforward and very similar to the one of the node definitions.
Therefore it will not be shown in detail. Details are found at~\autoref{chap:code-fragments}~\enquote{\nameref{chap:code-fragments}}.

\newthought{The last part when loading a node definition} is reading and parsing
the code part of the node.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap151}\raggedright\small
\NWtarget{nuweb180}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {180}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def build_node_definition_part(cls, node_controller, parent, json_input):
    """Builds and returns a node definition part from the given JSON
    input data.

    :param node_controller: a reference to the node controller
    :type  node_controller: qde.editor.application.node.NodeController
    :param parent: the parent of the node definition part
    :type  parent: qde.editor.domain.node.NodeDefinition
    :param json_input: the input in JSON format
    :type  json_input: dict

    :return: the built part of the node definition
    :rtype:  qde.editor.domain.node.NodeDefinitionPart
    """

    part_id         = uuid.UUID(json_input['id_'])
    name            = str(json_input['name'])

    script_lines = []
    for script_line in json_input['script']:
        script_lines.append(str(script_line))
    script = "\n".join(script_lines)

    type_string = json_input['type_']
    type_ = types.NodeType[type_string.upper()]

    node_definition_part = node.NodeDefinitionPart(part_id)
    node_definition_part.name = name
    node_definition_part.type_ = type_
    node_definition_part.script = script
    node_definition_part.parent = parent

    node_controller.node_definition_parts[part_id] =\
        node_definition_part

    cls.logger.debug(
        "Built part for node definition %s",
        part_id
    )
    return node_definition_part
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb163}{163}\NWlink{nuweb166}{, 166}\NWlink{nuweb173}{, 173}\NWlink{nuweb175}{, 175}\NWlink{nuweb180}{, 180}\NWlink{nuweb219}{, 219}\NWlink{nuweb220}{, 220}\NWlink{nuweb221}{, 221}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb218b}{218b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A class method of the JSON module, which builds a part of the
  definition of a node from a file handle (pointing to a JSON file containing a
  node definition).
  \newline{}\newline{}Editor $\rightarrow$ JSON $\rightarrow$
  Methods $\rightarrow$ Build node definition part}
% \label{editor:lst:json:methods:build-node-definition-part}
\end{figure*}

\newthought{Finally the node controller needs to be instantiated} by the main
application and the loading of the node definitions needs to be triggered. The
loading may although not be triggered at the same place as the signals for
reacting upon new node definitions need to be in place first.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap152}\raggedright\small
\NWtarget{nuweb181a}{} $\langle\,${\itshape Set up controllers for main application}\nobreak\ {\footnotesize {181a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.node_controller = node.NodeController()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb105b}{105b}\NWlink{nuweb137b}{, 137b}\NWlink{nuweb181a}{, 181a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90b}{90b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Instantiation of the node controller from within the main application.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:setup-node-controller}
\end{figure}

\newthought{Loading of node definitions} is done right before the main window is
shown, as at that point all necessary connections between signals and slots are
in place.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap153}\raggedright\small
\NWtarget{nuweb181b}{} $\langle\,${\itshape Load nodes}\nobreak\ {\footnotesize {181b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.node_controller.load_nodes()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb88a}{88a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Loading of nodes is triggered by the main application right after
  instantiating the node controller.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:load-nodes}
\end{figure}

\newthought{Now node definitions are being loaded and parsed.} Although there is
no possibility to select and instantiate the node definitions yet. To allow the
instantiation of nodes, a (user interface) component is necessary: A dialog for
adding nodes to the currently active scene. It will access all the loaded nodes
and provide an interface for selecting a node definition which then will be
instantiated.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap154}\raggedright\small
\NWtarget{nuweb182}{} $\langle\,${\itshape Add node dialog declarations}\nobreak\ {\footnotesize {182}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class AddNodeDialog(QtWidgets.QDialog):
    """Class for adding nodes to a scene view."""

    # Signals

    |\hbox{$\langle\,${\itshape Add node dialog column declaration}\nobreak\ {\footnotesize \NWlink{nuweb183a}{183a}}$\,\rangle$}|

    def __init__(self, parent=None):
        """Constructor.

        :param parent: the parent of this dialog.
        :type  parent: QtGui.QWidget
        """

        super(AddNodeDialog, self).__init__(parent)

        self.columns                = {}
        self.node_definitions       = {}
        self.chosen_node_definition = None

        self.setFixedSize(parent.width(), parent.height())
        self.setWindowTitle("Add node")

        layout = QtWidgets.QHBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSizeConstraint(Qt.QLayout.SetFixedSize)
        self.setLayout(layout)

    |\hbox{$\langle\,${\itshape Add node dialog methods}\nobreak\ {\footnotesize \NWlink{nuweb186a}{186a}}$\,\rangle$}|

    # Slots
    |\hbox{$\langle\,${\itshape Add node dialog slots}\nobreak\ {\footnotesize \NWlink{nuweb185a}{185a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb212b}{212b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Definition of a dialog to add nodes to the currently active scene. The
  nodes are ordered in columns according to their type.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog}
% \label{editor:lst:add-node-dialog}
\end{figure}

\newthought{The key idea of the add node dialog} is to have multiple columns
where each column defines a specific node type. The node definitions of each
type are then vertically listed per column. As these columns are tightly tied to
the add node dialog, the declaration of the column class is part of the add node
dialog.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap155}\raggedright\small
\NWtarget{nuweb183a}{} $\langle\,${\itshape Add node dialog column declaration}\nobreak\ {\footnotesize {183a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class Column(object):
    """Class representing a column within the add node dialog."""

    def __init__(self):
        """Constructor."""

        self.frame         = None
        self.sub_frames    = []
        self.label         = None
        self.v_box_layout  = None
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb182}{182}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{Class representing column within the dialog to create new node
  instances.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Column}
% \label{editor:lst:add-node-dialog:column}
\end{figure}

\newthought{The dialog for adding a node instance} from a node definition shall
only be shown from within a scene, that is from within the scene view. Therefore
the add node dialog is added to the scene view.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap156}\raggedright\small
\NWtarget{nuweb183b}{} $\langle\,${\itshape Scene view constructor}\nobreak\ {\footnotesize {183b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.add_node_dialog = node.AddNodeDialog(self.parent())
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb134b}{134b}\NWlink{nuweb183b}{, 183b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb134a}{134a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The dialog for adding new node instances is initialized by the scene
  view.
  \newline{}\newline{}Editor $\rightarrow$ Scene view $\rightarrow$ Constructor}
% \label{editor:lst:scene-view:constructor:add-node-dialog}
\end{figure}

\newthought{Whenever the scene view is focused} and the tabulator key is being
pressed, the dialog for adding a node shall be shown. For achieving this,
the~\verb=event= method of the scene view needs to be overwritten.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap157}\raggedright\small
\NWtarget{nuweb184a}{} $\langle\,${\itshape Scene view methods}\nobreak\ {\footnotesize {184a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def event(self, event):
    if (
            event.type() == Qt.QEvent.KeyPress and
            event.key()  == QtCore.Qt.Key_Tab
    ):
        self.logger.debug("Tabulator was pressed")

        # Sanity check: Open the dialog only if it is not
        # opened already.
        if not self.add_node_dialog.isVisible():
            current_scene = self.scene()
            assert current_scene is not None
            insert_at = current_scene.insert_at
            self.logger.debug("Cursor at %s", insert_at)
            insert_position = QtCore.QPoint(
                insert_at.x() * node_gui_domain.NodeViewModel.WIDTH,
                insert_at.y() * node_gui_domain.NodeViewModel.HEIGHT
            )
            insert_position = self.mapToGlobal(self.mapFromScene(
                insert_position
            ))
            self.add_node_dialog.move(insert_position)
            add_dialog_result = self.add_node_dialog.exec()

            # At this point we are sure, that this dialog instance
            # was handled properly, so accepting the event might
            # be sane here.
            event.accept()

            if add_dialog_result == QtWidgets.QDialog.Accepted:
                |\hbox{$\langle\,${\itshape Handle node definition chosen}\nobreak\ {\footnotesize \NWlink{nuweb195d}{195d}}$\,\rangle$}|
                return True
            else:
                return False

    return super(SceneView, self).event(event)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb134a}{134a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace*{-20mm}\caption{The event method of the scene view is
    overwritten for being able to show the dialog for adding new
    instances of nodes when the tabulator key is pressed.
  \newline{}\newline{}Editor $\rightarrow$ Scene view $\rightarrow$ Methods}
% \label{editor:lst:scene-view:methods:event}
\end{figure*}

\newthought{Pressing the tabulator key} when the scene view is active, brings up
the dialog to add a node, but the dialog is empty. This is due to the
circumstance, that the node controller is not informing whenever he receives a
new node definition and that no other component is listening.

\newthought{The node controller has to emit} a signal whenever he reads a
new node definition. The signal itself is emitting a view model of the read node
definition.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap158}\raggedright\small
\NWtarget{nuweb184b}{} $\langle\,${\itshape Node controller signals}\nobreak\ {\footnotesize {184b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_add_node_view_definition = QtCore.pyqtSignal(node_gui_domain.NodeViewModel)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb184b}{184b}\NWlink{nuweb212c}{, 212c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace*{-15mm}\caption{The signal of the node controller that is emitted whenever a node
  definition was read.
  \newline{}\newline{}Editor $\rightarrow$ Node controller $\rightarrow$ Signals}
% \label{editor:lst:node-controller:signals:do-add-node-view-definition}
\end{figure*}

\newthought{Now other components may listen} and receive view models of newly
added node definitions. In this specific case it is is the dialog for adding a
node which needs to listen to the added signal. The listening is done by the
slot~\verb=on_node_definition_added=.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap159}\raggedright\small
\NWtarget{nuweb185a}{} $\langle\,${\itshape Add node dialog slots}\nobreak\ {\footnotesize {185a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(node_gui_domain.NodeViewModel)
def on_node_definition_added(self, node_view_model):
    """Slot which is called whenever a new node definition is added.

    :param node_view_model: The newly added node definition.
    :type  node_view_model: qde.editor.gui_domain.node.NodeDefinitionViewModel
    """

    self.logger.debug("Got new node definition: %s", node_view_model)

    node_name = node_view_model.domain_object.name
    type_name = node_view_model.domain_object.type_.name
    |\hbox{$\langle\,${\itshape On node definition added implementation}\nobreak\ {\footnotesize \NWlink{nuweb185b}{185b}}$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb182}{182}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace*{-20mm}\caption{The slot of the dialog to add a new node that is called whenever a new
  node definition is added.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Slots}
% \label{editor:lst:add-node-dialog:slots:on-node-definition-added}
\end{figure*}

\newthought{As the idea of the dialog} is to have one column per node type, the
column needs to be fetched first, based on the type name of the given node
definition. Then a sub frame is created which holds a representation of the node
definition. This representation is rendered like an actual instance of a node.
Its behavior is like a button, meaning it can be clicked. Clicking on a
representation of a node definition adds an instance of the clicked node
definition to the currently active scene at the cursor position where the dialog
for adding a node was opened.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap160}\raggedright\small
\NWtarget{nuweb185b}{} $\langle\,${\itshape On node definition added implementation}\nobreak\ {\footnotesize {185b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\hbox{$\langle\,${\itshape Check if the node definition is already known}\nobreak\ {\footnotesize \NWlink{nuweb185c}{185c}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Get or create column by type name}\nobreak\ {\footnotesize \NWlink{nuweb185d}{185d}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Create sub frame for given node definition}\nobreak\ {\footnotesize \NWlink{nuweb187b}{187b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Create button for given node definition and add to sub frame}\nobreak\ {\footnotesize \NWlink{nuweb188a}{188a}, \ldots\ }$\,\rangle$}|
|\hbox{$\langle\,${\itshape Add sub frame to column}\nobreak\ {\footnotesize \NWlink{nuweb188c}{188c}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Save the node definition to list of known nodes}\nobreak\ {\footnotesize \NWlink{nuweb189a}{189a}}$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb185a}{185a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace*{-20mm}\caption{Implementation of the slot of the dialog to add a new node that is
  called whenever a new node definition is added.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Slots}
% \label{editor:lst:add-node-dialog:slots:on-node-definition-added:impl}
\end{figure*}

\newthought{A node definition may already be present} although. If this is the
case the process will be stopped.

\begin{figure*}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap161}\raggedright\small
\NWtarget{nuweb185c}{} $\langle\,${\itshape Check if the node definition is already known}\nobreak\ {\footnotesize {185c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
if node_view_model.id_ not in self.node_definitions:
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb185b}{185b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\vspace*{-20mm}\caption{It is checked that the given node definition is not already known.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Slots}
% \label{editor:lst:add-node-dialog:slots:on-node-definition-added:impl:known}
\end{figure*}

\newthought{Getting or creating a column} is about calling the corresponding
method, as the task is abstracted into a method to maintain readability.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap162}\raggedright\small
\NWtarget{nuweb185d}{} $\langle\,${\itshape Get or create column by type name}\nobreak\ {\footnotesize {185d}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
    column = self.get_or_create_column_by_name(type_name)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb185b}{185b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The column which the node definition belongs to is depending on the
  node definition's type. If a column for the type of the node definition
  already exists, that column is used. Otherwise a new column is created for the
  type.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Slots}
% \label{editor:lst:add-node-dialog:slots:on-node-definition-added:impl:column}
\end{figure}

\newthought{The method to get a column},~\verb=get_or_create_column_by_name=,
tries to get a column by the given name and if no column by that name exists, it
creates a new column using the given name.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap163}\raggedright\small
\NWtarget{nuweb186a}{} $\langle\,${\itshape Add node dialog methods}\nobreak\ {\footnotesize {186a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def get_or_create_column_by_name(self, column_name):
    """Gets the column for the given column name.
    If there is no column for the given column name available,
    a new column using the given column name is created.

    :param column_name: the name of the column to get or create.
    :type  column_name: str

    :return: the column for the given column name.
    :rtype:  AddNodeDialog.Column
    """

    |\hbox{$\langle\,${\itshape Get existing column object by name}\nobreak\ {\footnotesize \NWlink{nuweb186b}{186b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Create new column object based on name}\nobreak\ {\footnotesize \NWlink{nuweb187a}{187a}}$\,\rangle$}|

    return column|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb182}{182}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The method for getting or creating a column by type name.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Methods}
% \label{editor:lst:add-node-dialog:methods:get-or-create-column-by-name}
\end{figure}

\newthought{Therefore, if a column by the given name already exists}, the
reference to the found column is returned.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap164}\raggedright\small
\NWtarget{nuweb186b}{} $\langle\,${\itshape Get existing column object by name}\nobreak\ {\footnotesize {186b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
if column_name in self.columns:
    column = self.columns[column_name]|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb186a}{186a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{If a column by the given name exists that column is returned.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Methods}
% \label{editor:lst:add-node-dialog:methods:get-or-create-column-by-name:check-exists}
\end{figure}

\newthought{If no column by the given name exists}, a new column using the given
name is created.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap165}\raggedright\small
\NWtarget{nuweb187a}{} $\langle\,${\itshape Create new column object based on name}\nobreak\ {\footnotesize {187a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
else:
    frame = QtWidgets.QFrame(self)
    self.layout().addWidget(frame)
    frame.setContentsMargins(0, 0, 0, 0)

    row = QtWidgets.QVBoxLayout(frame)
    row.setContentsMargins(0, 0, 0, 0)

    caption = "<h2>{0}</h2>".format(column_name)
    label = QtWidgets.QLabel(caption, frame)
    label.setContentsMargins(4, 2, 4, 2)
    label_font = QtGui.QFont()
    label_font.setFamily(label_font.defaultFamily())
    label_font.setBold(True)
    label_font.setUnderline(True)
    label.setFont(label_font)

    row.addWidget(label)
    row.addStretch(1)

    column = AddNodeDialog.Column()
    column.frame = frame
    column.label = column_name
    column.v_box_layout = row
    self.columns[column_name] = column|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb186a}{186a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{When no column for a specific name exists the column is created.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Methods}
% \label{editor:lst:add-node-dialog:methods:get-or-create-column-by-name:create}
\end{figure}

\newthought{For adding the representation} of the node definition to a column,
the creation of a sub frame is necessary.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap166}\raggedright\small
\NWtarget{nuweb187b}{} $\langle\,${\itshape Create sub frame for given node definition}\nobreak\ {\footnotesize {187b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
    sub_frame = QtWidgets.QFrame(column.frame)
    sub_frame_column = QtWidgets.QHBoxLayout(sub_frame)
    sub_frame_column.setContentsMargins(0, 0, 0, 0)
    sub_frame_column.setSpacing(0)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb185b}{185b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A sub frame is created for each new column.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Methods}
% \label{editor:lst:add-node-dialog:methods:get-or-create-column-by-name:create-subframe}
\end{figure}

\newthought{The node representation is then created} and added to the above
created sub frame. At this moment the presentation is simply a label.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap167}\raggedright\small
\NWtarget{nuweb188a}{} $\langle\,${\itshape Create button for given node definition and add to sub frame}\nobreak\ {\footnotesize {188a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
    button_label = gui_helper.ClickableLabel(node_name, sub_frame)
    button_label.setContentsMargins(4, 0, 4, 0)
    button_label.setSizePolicy(
        Qt.QSizePolicy.Expanding, Qt.QSizePolicy.Preferred
    )
    sub_frame_column.addWidget(button_label)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb188a}{188a}\NWlink{nuweb188b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb185b}{185b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{For the type of the given node definition a button is created and added
  to the previously created sub frame.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Methods}
% \label{editor:lst:add-node-dialog:methods:get-or-create-column-by-name:create-button}
\end{figure}

\newthought{On thing that stands out} in the above code fragment, is the
clickable label class. This label is nothing other than normal label emitting a
signal called~\verb=clicked= when receiving a mouse press event.

\newthought{For being able to react} whenever such a label is clicked, it is
necessary to handle the~\verb=clicked= signal of the label. Up to now all
signals emitted the necessary objects. As the~\verb=clicked= signal is very
generic, it does not emit an object. It is nevertheless necessary to emit the
chosen node definition.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap168}\raggedright\small
\NWtarget{nuweb188b}{} $\langle\,${\itshape Create button for given node definition and add to sub frame}\nobreak\ {\footnotesize {188b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}

    def _add_node_button_clicked(node_view_model):
        self.chosen_node_definition = node_view_model
        self.accept()

    button_label.do_add_node.connect(functools.partial(
        _add_node_button_clicked, node_view_model
    ))|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb188a}{188a}\NWlink{nuweb188b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb185b}{185b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{A callback function is created which gets triggered whenever a button
  is clicked. The callback function stores the selected node definition (type)
  and closes the dialog.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Methods}
% \label{editor:lst:add-node-dialog:methods:get-or-create-column-by-name:callback}
\end{figure}

\newthought{Finally the created sub frame is added} to the found or created
column.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap169}\raggedright\small
\NWtarget{nuweb188c}{} $\langle\,${\itshape Add sub frame to column}\nobreak\ {\footnotesize {188c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
    column.v_box_layout.insertWidget(
        column.v_box_layout.count() - 1, sub_frame
    )
    column.sub_frames.append(sub_frame)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb185b}{185b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The created sub frame is added to the layout of the column and appended
  to the list of sub frames of the column.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Methods}
% \label{editor:lst:add-node-dialog:methods:get-or-create-column-by-name:append-subframe}
\end{figure}

\newthought{If the node definition is not yet known}, it is saved to the list of
known node definitions. Otherwise a warning is being shown.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap170}\raggedright\small
\NWtarget{nuweb189a}{} $\langle\,${\itshape Save the node definition to list of known nodes}\nobreak\ {\footnotesize {189a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.node_definitions[node_view_model.id_] = node_view_model
    self.logger.debug("Added node definition %s", node_view_model)
    # TODO: Handle shortcuts

else:
    self.logger.warn(
        "Node definition %s is already known",
        node_view_model
    )
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb185b}{185b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The node definition is saved to the list of known node definitions.
  \newline{}\newline{}Editor $\rightarrow$ Add node dialog $\rightarrow$ Slots}
% \label{editor:lst:add-node-dialog:slots:on-node-definition-added:impl:append-definition}
\end{figure}

\newthought{The above defined slot} needs to be triggered as soon as a new node
definition is being added. This is done within the main window, by connecting
the slot with the~\verb=do_add_node_view_definition= signal.

\begin{figure}[!htbp]
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap171}\raggedright\small
\NWtarget{nuweb189b}{} $\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize {189b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.node_controller.do_add_node_view_definition.connect(
    self.main_window.scene_view.add_node_dialog.\
    on_node_definition_added
)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb114b}{114b}\NWlink{nuweb143c}{, 143c}\NWlink{nuweb189b}{, 189b}\NWlink{nuweb191b}{, 191b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90c}{90c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\caption{The main application connects the node controller's signal that a new node
  definition was added with the corresponding slot of the dialog to add nodes.
  \newline{}\newline{}Editor $\rightarrow$ Main application $\rightarrow$
  Constructor}
% \label{editor:lst:main-application:constructor:connect-add-node-definition}
\end{figure}

% -*- mode: latex; coding: utf-8 -*-

\chapter{Code fragments}
\label{chap:code-fragments}

\begin{fullwidth}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap172}\raggedright\small
\NWtarget{nuweb190}{} \verb@"../src/editor.py"@\nobreak\ {\footnotesize {190}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Main entry point for the QDE editor application. """

# System imports
import sys

# Project imports
from qde.editor.application import application

|\hbox{$\langle\,${\itshape Main entry point}\nobreak\ {\footnotesize \NWlink{nuweb87a}{87a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap173}\raggedright\small
\NWtarget{nuweb191a}{} \verb@"../src/qde/editor/application/application.py"@\nobreak\ {\footnotesize {191a}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""Main application module for the QDE editor."""

# System imports
import logging
import logging.config
import os
import json
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets

# Project imports
from qde.editor.foundation import common
from qde.editor.application import node
from qde.editor.application import scene
from qde.editor.gui import main_window as qde_main_window


|\hbox{$\langle\,${\itshape Main application declarations}\nobreak\ {\footnotesize \NWlink{nuweb87b}{87b}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap174}\raggedright\small
\NWtarget{nuweb191b}{} $\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize {191b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.main_window.scene_view.do_add_node.connect(
    self.node_controller.on_node_added
)
self.node_controller.do_add_node_model.connect(
    self.scene_controller.on_node_model_added
)
self.scene_controller.do_select_node.connect(
    self.main_window.render_view.on_node_selected
)
self.scene_controller.do_deselect_node.connect(
    self.main_window.render_view.on_node_deselected
)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb114b}{114b}\NWlink{nuweb143c}{, 143c}\NWlink{nuweb189b}{, 189b}\NWlink{nuweb191b}{, 191b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb90c}{90c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap175}\raggedright\small
\NWtarget{nuweb192a}{} \verb@"../src/qde/editor/gui/main_window.py"@\nobreak\ {\footnotesize {192a}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding the main application window. """

# System imports
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets

# Project imports
from qde.editor.foundation import common
from qde.editor.gui import render as gui_render
from qde.editor.gui import scene as gui_scene


|\hbox{$\langle\,${\itshape Main window declarations}\nobreak\ {\footnotesize \NWlink{nuweb89a}{89a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap176}\raggedright\small
\NWtarget{nuweb192b}{} $\langle\,${\itshape Set up render view in main window}\nobreak\ {\footnotesize {192b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.render_view = gui_render.RenderView(self)
self.render_view.setObjectName('render_view')
self.render_view.setMinimumSize(300, 300)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb92}{92}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap177}\raggedright\small
\NWtarget{nuweb192c}{} $\langle\,${\itshape Add render view to horizontal splitter in main window}\nobreak\ {\footnotesize {192c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
horizontal_splitter.addWidget(self.render_view)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb92}{92}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap178}\raggedright\small
\NWtarget{nuweb193a}{} \verb@"../src/qde/editor/domain/scene.py"@\nobreak\ {\footnotesize {193a}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding scene related aspects concerning the domain layer. """

# System imports
import uuid
from PyQt5 import Qt
from PyQt5 import QtCore

# Project imports


|\hbox{$\langle\,${\itshape Scene model declarations}\nobreak\ {\footnotesize \NWlink{nuweb93}{93}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap179}\raggedright\small
\NWtarget{nuweb193b}{} \verb@"../src/qde/editor/gui_domain/scene.py"@\nobreak\ {\footnotesize {193b}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}

#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding scene related aspects concerning the gui_domain layer. """

# System imports
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets

# Project imports
from qde.editor.foundation import common
from qde.editor.gui_domain import node as node_gui_domain

|\hbox{$\langle\,${\itshape Scene graph view model declarations}\nobreak\ {\footnotesize \NWlink{nuweb94b}{94b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Scene view model declarations}\nobreak\ {\footnotesize \NWlink{nuweb138a}{138a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap180}\raggedright\small
\NWtarget{nuweb193c}{} $\langle\,${\itshape Scene graph view model methods}\nobreak\ {\footnotesize {193c}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __str__(self):
    """Return the string representation of the current object."""

    return str(self.id_)[0:8]
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb105a}{105a}\NWlink{nuweb193c}{, 193c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb94b}{94b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap181}\raggedright\small
\NWtarget{nuweb194a}{} $\langle\,${\itshape Scene view model methods}\nobreak\ {\footnotesize {194a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __str__(self):
    """Return the string representation of the current object."""

    return str(self.id_)[0:8]
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb139}{139}\NWlink{nuweb194a}{, 194a}\NWlink{nuweb198a}{, 198a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb138a}{138a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap182}\raggedright\small
\NWtarget{nuweb194b}{} \verb@"../src/qde/editor/application/scene.py"@\nobreak\ {\footnotesize {194b}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding scene related aspects concerning the application layer.
"""

# System imports
from PyQt5 import Qt
from PyQt5 import QtCore

# Project imports
from qde.editor.foundation import common
from qde.editor.domain     import node  as node_domain
from qde.editor.gui_domain import node  as node_gui_domain
from qde.editor.domain     import scene as scene_domain
from qde.editor.gui_domain import scene as scene_gui_domain

|\hbox{$\langle\,${\itshape Scene graph controller declarations}\nobreak\ {\footnotesize \NWlink{nuweb96a}{96a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Scene controller declarations}\nobreak\ {\footnotesize \NWlink{nuweb137a}{137a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap183}\raggedright\small
\NWtarget{nuweb195a}{} \verb@"../src/qde/editor/gui/scene.py"@\nobreak\ {\footnotesize {195a}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding scene related aspects concerning the graphical user interface layer.
"""

# System imports
import uuid
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtWidgets

# Project imports
from qde.editor.foundation import common
from qde.editor.gui_domain import node as node_gui_domain
from qde.editor.gui_domain import scene
from qde.editor.gui import node

|\hbox{$\langle\,${\itshape Scene graph view declarations}\nobreak\ {\footnotesize \NWlink{nuweb105c}{105c}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Scene view declarations}\nobreak\ {\footnotesize \NWlink{nuweb134a}{134a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap184}\raggedright\small
\NWtarget{nuweb195b}{} $\langle\,${\itshape Scene graph view decorators}\nobreak\ {\footnotesize {195b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb105c}{105c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap185}\raggedright\small
\NWtarget{nuweb195c}{} $\langle\,${\itshape Scene view signals}\nobreak\ {\footnotesize {195c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_add_node = QtCore.pyqtSignal(uuid.UUID)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb134a}{134a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% Coming from: Scene view methods
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap186}\raggedright\small
\NWtarget{nuweb195d}{} $\langle\,${\itshape Handle node definition chosen}\nobreak\ {\footnotesize {195d}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
node_definition_vm = self.add_node_dialog.chosen_node_definition
self.logger.debug(
    "Node instance shall be added: %s",
    node_definition_vm
)
self.do_add_node.emit(node_definition_vm.id_)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb184a}{184a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap187}\raggedright\small
\NWtarget{nuweb196}{} $\langle\,${\itshape Scene controller signals}\nobreak\ {\footnotesize {196}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_select_node = QtCore.pyqtSignal(node_gui_domain.NodeViewModel)
do_deselect_node = QtCore.pyqtSignal()  # TODO: Send deselected node as well?
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb143a}{143a}\NWlink{nuweb196}{, 196}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb137a}{137a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap188}\raggedright\small
\NWtarget{nuweb197}{} $\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize {197}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(node_domain.NodeModel, node_gui_domain.NodeViewModel)
def on_node_model_added(self, node_domain_model, node_view_model):
    self.logger.debug("Shall add node domain model: %s", node_domain_model)

    assert self.current_scene is not None

    # Add node view model to scene view model
    self.current_scene.addItem(node_view_model)
    insert_pos_x = self.current_scene.insert_at.x() * node_gui_domain.NodeViewModel.WIDTH
    insert_pos_y = self.current_scene.insert_at.y() * node_gui_domain.NodeViewModel.HEIGHT
    node_view_model.setPos(insert_pos_x, insert_pos_y)

    # Handle (de-)selection of the node view model
    node_view_model.do_select_node.connect(self.on_node_selected)
    node_view_model.do_deselect_node.connect(self.on_node_deselected)

    # Add node domain model to scene domain model
    self.current_scene.nodes.append(node_domain_model)

    self.logger.debug(
        "Node instance '%s' was added to current scene (%s) at %s",
        node_view_model,
        self.current_scene,
        node_view_model.pos()
    )
    # TODO: Check if still necessary
    # self.node_added.emit(self.current_scene)

|\normalfont{}\fontfamily{}|QtCore.pyqtSlot()
def on_node_selected(self):
    """Gets triggered whenever a node was selected within the node graph
    view."""

    node_view_model = self.current_scene.selectedItems()[0]
    self.logger.debug("Node instance was selected: %s" % type(node_view_model))
    self.do_select_node.emit(node_view_model)

|\normalfont{}\fontfamily{}|QtCore.pyqtSlot()
def on_node_deselected(self):
    """Gets triggered whenever a node was deselected within the node graph
    view."""

    self.logger.debug("Currently selected node instance was deselected")
    self.do_deselect_node.emit()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb141}{141}\NWlink{nuweb142a}{, 142a}\NWlink{nuweb142b}{b}\NWlink{nuweb197}{, 197}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb137a}{137a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap189}\raggedright\small
\NWtarget{nuweb198a}{} $\langle\,${\itshape Scene view model methods}\nobreak\ {\footnotesize {198a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def mouseReleaseEvent(self, event):
    super(SceneViewModel, self).mouseReleaseEvent(event)

    # TODO: Check boundary conditions
    # * Boundaries of scene
    # * Other nodes

    if (
            event.button() & QtCore.Qt.LeftButton
    ):
        new_x = event.scenePos().x() / node_gui_domain.NodeViewModel.WIDTH
        new_y = event.scenePos().y() / node_gui_domain.NodeViewModel.HEIGHT
        self.insert_at.setX(new_x)
        self.insert_at.setY(new_y)
        self.logger.debug(
            "Set insert at to %s, %s",
            new_x, new_y
        )
        self.invalidate()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb139}{139}\NWlink{nuweb194a}{, 194a}\NWlink{nuweb198a}{, 198a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb138a}{138a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap190}\raggedright\small
\NWtarget{nuweb198b}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {198b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\hbox{$\langle\,${\itshape Scene graph controller add root node}\nobreak\ {\footnotesize \NWlink{nuweb97a}{97a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb99}{99}\NWlink{nuweb100}{, 100}\NWlink{nuweb101}{, 101}\NWlink{nuweb102}{, 102}\NWlink{nuweb103}{, 103}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb113}{, 113}\NWlink{nuweb114a}{, 114a}\NWlink{nuweb198b}{, 198b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb96a}{96a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap191}\raggedright\small
\NWtarget{nuweb199}{} \verb@"../logging.json"@\nobreak\ {\footnotesize {199}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
{
    "version": 1,
    "disable_existing_loggers": false,
    "formatters": {
        "simple": {
            "format": "%(asctime)s - %(levelname)-7s - %(name)s.%(funcName)s::%(lineno)s: %(message)s"
        }
    },

    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "level": "DEBUG",
            "formatter": "simple",
            "stream": "ext://sys.stdout"
        },

        "info_file_handler": {
            "class": "logging.handlers.RotatingFileHandler",
            "level": "INFO",
            "formatter": "simple",
            "filename": "info.log",
            "maxBytes": 10485760,
            "backupCount": 20,
            "encoding": "utf8"
        },

        "error_file_handler": {
            "class": "logging.handlers.RotatingFileHandler",
            "level": "ERROR",
            "formatter": "simple",
            "filename": "errors.log",
            "maxBytes": 10485760,
            "backupCount": 20,
            "encoding": "utf8"
        }
    },

    "root": {
        "level": "DEBUG",
        "handlers": ["console", "info_file_handler", "error_file_handler"],
        "propagate": "no"
    }
}|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap192}\raggedright\small
\NWtarget{nuweb200a}{} \verb@"../src/qde/editor/foundation/common.py"@\nobreak\ {\footnotesize {200a}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""Module holding common helper methods."""

# System imports
import logging
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets

# Project imports


def with_logger(cls):
    """Add a logger instance (using a stream handler) to the given class.

    :param cls: the class which the logger shall be added to.
    :type  cls: a class of type cls.

    :return: the class with the logger instance added.
    :rtype:  a class of type cls.
    """

    |\hbox{$\langle\,${\itshape Set logger name}\nobreak\ {\footnotesize \NWlink{nuweb118a}{118a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Logger interface}\nobreak\ {\footnotesize \NWlink{nuweb118b}{118b}}$\,\rangle$}|

|\hbox{$\langle\,${\itshape Common methods}\nobreak\ {\footnotesize \NWlink{nuweb200b}{200b}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap193}\raggedright\small
\NWtarget{nuweb200b}{} $\langle\,${\itshape Common methods}\nobreak\ {\footnotesize {200b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def multiply_colors(color1, color2):
    red   = (color1.redF()   * color2.redF()  ) * 255
    blue  = (color1.blueF()  * color2.blueF() ) * 255
    green = (color1.greenF() * color2.greenF()) * 255

    return QtGui.QColor(red, blue, green)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb200a}{200a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap194}\raggedright\small
\NWtarget{nuweb201}{} \verb@"../src/qde/editor/foundation/type.py"@\nobreak\ {\footnotesize {201}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-
"""Module for type-specific aspects."""

# System imports
import enum

# Project imports


|\hbox{$\langle\,${\itshape Node type declarations}\nobreak\ {\footnotesize \NWlink{nuweb124}{124}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node part state changed declarations}\nobreak\ {\footnotesize \NWlink{nuweb156b}{156b}}$\,\rangle$}|


class Vertex(enum.Enum):
    """Possible types of vertices."""

    FULL     = 0
    SIMPLE   = 1
    PARTICLE = 2
    INSTANCE = 3


class GeometryPrimitive(enum.Enum):
    """Possible types of geometrical primitives."""

    TRIANGLE_LIST   = 0
    QUAD_LIST       = 1
    LINE_LIST       = 2
    SPRITE_LIST     = 3
    TRIANGLE_STRIPS = 4
    LINE_STRIPS     = 5
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap195}\raggedright\small
\NWtarget{nuweb202}{} \verb@"../src/qde/editor/domain/parameter.py"@\nobreak\ {\footnotesize {202}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

"""Module for parameter-specific aspects."""

# System imports

# Project imports
from qde.editor.foundation import type as types
from qde.editor.domain import node

|\hbox{$\langle\,${\itshape Parameter declarations}\nobreak\ {\footnotesize \NWlink{nuweb125}{125}, \ldots\ }$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model value generic interface}\nobreak\ {\footnotesize \NWlink{nuweb169a}{169a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model value interface}\nobreak\ {\footnotesize \NWlink{nuweb169b}{169b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model dynamic value}\nobreak\ {\footnotesize \NWlink{nuweb205b}{205b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model float value}\nobreak\ {\footnotesize \NWlink{nuweb170a}{170a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model generic value}\nobreak\ {\footnotesize \NWlink{nuweb205a}{205a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model image value}\nobreak\ {\footnotesize \NWlink{nuweb204b}{204b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model mesh value}\nobreak\ {\footnotesize \NWlink{nuweb206a}{206a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model text value}\nobreak\ {\footnotesize \NWlink{nuweb204a}{204a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model scene value}\nobreak\ {\footnotesize \NWlink{nuweb170b}{170b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain model implicit value}\nobreak\ {\footnotesize \NWlink{nuweb206b}{206b}, \ldots\ }$\,\rangle$}|
|\hbox{$\langle\,${\itshape Parameter domain module methods}\nobreak\ {\footnotesize \NWlink{nuweb168}{168}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap196}\raggedright\small
\NWtarget{nuweb203}{} $\langle\,${\itshape Parameter declarations}\nobreak\ {\footnotesize {203}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    FloatValue = create_node_definition_part.__func__(
        id_="468aea9e-0a03-4e63-b6b4-8a7a76775a1a",
        type_=types.NodeType.FLOAT
    )
    Text = create_node_definition_part.__func__(
        id_="e43bdd1b-a895-4bd8-8d5a-b401a63f7a6f",
        type_=types.NodeType.TEXT
    )
    Scene = create_node_definition_part.__func__(
        id_="bfb47e7text7-1b05-4864-8397-de30bf005ff8",
        type_=types.NodeType.SCENE
    )
    Image = create_node_definition_part.__func__(
        id_="21fd1960-1307-4b53-b7bf-d08f02757335",
        type_=types.NodeType.IMAGE
    )
    DynamicValue = create_node_definition_part.__func__(
        id_="68720ae3-8068-43ce-94d8-8705dc3b8bfe",
        type_=types.NodeType.DYNAMIC
    )
    Mesh = create_node_definition_part.__func__(
        id_="9791d341-b92c-43dd-954a-9d83b9020e43",
        type_=types.NodeType.MESH
    )
    Implicit = create_node_definition_part.__func__(
        id_="c019271c-35b6-425c-9ff2-a1d893111adb",
        type_=types.NodeType.IMPLICIT
    )

    atomic_types = [
        FloatValue,
        Text,
        Scene,
        Image,
        DynamicValue,
        Mesh,
        Implicit,
    ]

|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb125}{125}\NWlink{nuweb126}{, 126}\NWlink{nuweb203}{, 203}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap197}\raggedright\small
\NWtarget{nuweb204a}{} $\langle\,${\itshape Parameter domain model text value}\nobreak\ {\footnotesize {204a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class TextValue(Value):
    """A class holding values for text/string nodes."""

    def __init__(self, string_value):
        """Constructor.

        :param string_value: the string value that shall be held
        :type  string_value: str
        """

        super(TextValue, self).__init__(string_value)
        self.function_type = types.NodeType.TEXT

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return TextValue(self.value)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap198}\raggedright\small
\NWtarget{nuweb204b}{} $\langle\,${\itshape Parameter domain model image value}\nobreak\ {\footnotesize {204b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class ImageValue(ValueInterface):
    """A class holding values for image nodes."""

    def __init__(self):
        """Constructor."""

        super(ImageValue, self).__init__()
        self.function_type = types.NodeType.IMAGE

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return ImageValue()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap199}\raggedright\small
\NWtarget{nuweb205a}{} $\langle\,${\itshape Parameter domain model generic value}\nobreak\ {\footnotesize {205a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class GenericValue(ValueInterface):
    """A class holding values for generic nodes."""

    def __init__(self):
        """Constructor."""

        super(GenericValue, self).__init__()
        self.function_type = types.NodeType.GENERIC

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return GenericValue()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap200}\raggedright\small
\NWtarget{nuweb205b}{} $\langle\,${\itshape Parameter domain model dynamic value}\nobreak\ {\footnotesize {205b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class DynamicValue(ValueInterface):
    """A class holding values for dynamic nodes."""

    def __init__(self):
        """Constructor."""

        super(DynamicValue, self).__init__()
        self.function_type = types.NodeType.DYNAMIC

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return DynamicValue()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap201}\raggedright\small
\NWtarget{nuweb206a}{} $\langle\,${\itshape Parameter domain model mesh value}\nobreak\ {\footnotesize {206a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class MeshValue(ValueInterface):
    """A class holding values for mesh nodes."""

    def __init__(self):
        """Constructor."""

        super(MeshValue, self).__init__()
        self.function_type = types.NodeType.MESH

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return MeshValue()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap202}\raggedright\small
\NWtarget{nuweb206b}{} $\langle\,${\itshape Parameter domain model implicit value}\nobreak\ {\footnotesize {206b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class ImplicitValue(ValueInterface):
    """A class holding values for implicit surface nodes."""

    def __init__(self):
        """Constructor."""

        super(ImplicitValue, self).__init__()
        self.function_type = types.NodeType.IMPLICIT

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return ImplicitValue()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb206b}{206b}\NWlink{nuweb207a}{, 207a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap203}\raggedright\small
\NWtarget{nuweb207a}{} $\langle\,${\itshape Parameter domain model implicit value}\nobreak\ {\footnotesize {207a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
class ImplicitValue(ValueInterface):
    """A class holding values for implicit types."""

    def __init__(self):
        """Constructor."""

        super(ImplicitValue, self).__init__()
        self.function_type = types.NodeType.IMPLICIT

    def clone(self):
        """Clones the currently set value.

        :return: a clone of the currently set value
        :rtype:  qde.editor.domain.parameter.ValueInterface
        """

        return ImplicitValue()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb206b}{206b}\NWlink{nuweb207a}{, 207a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb202}{202}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap204}\raggedright\small
\NWtarget{nuweb207b}{} \verb@"../src/qde/editor/domain/node.py"@\nobreak\ {\footnotesize {207b}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

"""Module for node-specific aspects."""

# System imports

# Project imports
from qde.editor.foundation import type as types
from qde.editor.foundation import flag

|\hbox{$\langle\,${\itshape Node domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb127a}{127a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node part domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb155a}{155a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node definition domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb157b}{157b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node definition part domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb150b}{150b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node definition input domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb171a}{171a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node definition output domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb174a}{174a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node definition connection domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb211a}{211a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node definition definition domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb211b}{211b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node definition invocation domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb212a}{212a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Node domain module methods}\nobreak\ {\footnotesize \NWlink{nuweb152}{152}, \ldots\ }$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap205}\raggedright\small
\NWtarget{nuweb208a}{} \verb@"../src/qde/editor/gui_domain/node.py"@\nobreak\ {\footnotesize {208a}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

""" Module holding node related aspects concerning the gui_domain layer. """

# System imports
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui

# Project imports
from qde.editor.foundation import common
from qde.editor.foundation import flag

|\normalfont{}\fontfamily{}|common.with_logger
|\hbox{$\langle\,${\itshape Node view model declarations}\nobreak\ {\footnotesize \NWlink{nuweb128a}{128a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap206}\raggedright\small
\NWtarget{nuweb208b}{} $\langle\,${\itshape Node view model constructor}\nobreak\ {\footnotesize {208b}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
    self.setPos(self.position)
    self.setAcceptHoverEvents(True)
    self.setFlag(Qt.QGraphicsObject.ItemIsFocusable)
    self.setFlag(Qt.QGraphicsObject.ItemIsMovable)
    self.setFlag(Qt.QGraphicsObject.ItemIsSelectable)
    self.setFlag(Qt.QGraphicsObject.ItemClipsToShape)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb128b}{128b}\NWlink{nuweb131a}{, 131a}\NWlink{nuweb208b}{, 208b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap207}\raggedright\small
\NWtarget{nuweb209}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {209}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def boundingRect(self):
    """Return the bounding rectangle of the node.

    :return: the bounding rectangle of the node.
    :rtype: Qt.QRectF
    """

    return Qt.QRectF(
        0, 0, self.width, self.height
    )

def create_pixmap(self):
    """"Creation of the pixmap (=bitmap, the actual 'image')"""

    image = QtGui.QImage(self.boundingRect().size().toSize(),
                         QtGui.QImage.Format_ARGB32_Premultiplied)
    pixmap = QtGui.QPixmap.fromImage(image)
    pixmap.fill(QtCore.Qt.transparent)

    rect = self.boundingRect()

    painter = QtGui.QPainter()
    painter.begin(pixmap)
    painter.setRenderHint(QtGui.QPainter.Antialiasing)

    # Shape
    path = QtGui.QPainterPath()
    path.addRect(rect)
    # path.addRoundedRect(rect, 5, 5)
    painter.drawPath(path)

    # Color / gradient
    color = QtGui.QColor(255, 0, 0, 128)
    color.setHsv(color.hsvHue(), 160, 255)
    color_desaturated = color
    color_desaturated.setHsv(color.hsvHue(), 40, 255)
    top_color = QtGui.QColor(60, 70, 80)
    if self.status is not flag.NodeStatus.OK:
        top_color = QtGui.QColor(255, 0, 0)
    gradient_top_color = common.multiply_colors(
        top_color, color_desaturated
    )
    gradient_bottom_color = common.multiply_colors(
        QtGui.QColor(110, 120, 130), color_desaturated
    )
    rect_gradient = QtGui.QLinearGradient(
        QtCore.QPoint(0.0, 0.0), QtCore.QPoint(0.0, rect.height())
    )
    rect_gradient.setColorAt(0.0, gradient_top_color)
    rect_gradient.setColorAt(1.0, gradient_bottom_color)

    brush = QtGui.QBrush(rect_gradient)

    painter.fillPath(path, brush)
    painter.end()

    return pixmap
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb129a}{129a}\NWlink{nuweb129b}{b}\NWlink{nuweb130b}{, 130b}\NWlink{nuweb131b}{, 131b}\NWlink{nuweb132a}{, 132a}\NWlink{nuweb209}{, 209}\NWlink{nuweb215}{, 215}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap208}\raggedright\small
\NWtarget{nuweb210a}{} \verb@"../nodes/16d90b34-a728-4caa-b07d-a3244ecc87e3.node"@\nobreak\ {\footnotesize {210a}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\hbox{$\langle\,${\itshape Implicit sphere node}\nobreak\ {\footnotesize \NWlink{nuweb144}{144}}$\,\rangle$}||\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap209}\raggedright\small
\NWtarget{nuweb210b}{} \verb@"../src/qde/editor/application/node.py"@\nobreak\ {\footnotesize {210b}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding node related aspects concerning the application layer.
"""

# System imports
import glob
import inspect
import os
import time
import uuid
from PyQt5 import Qt
from PyQt5 import QtCore

# Project imports
from qde.editor.foundation import common
from qde.editor.foundation import type as types
from qde.editor.technical  import json
from qde.editor.domain     import parameter
from qde.editor.domain     import node as node_domain
from qde.editor.gui_domain import node as node_gui_domain


|\hbox{$\langle\,${\itshape Node controller declarations}\nobreak\ {\footnotesize \NWlink{nuweb149a}{149a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap210}\raggedright\small
\NWtarget{nuweb211a}{} $\langle\,${\itshape Node definition connection domain model declarations}\nobreak\ {\footnotesize {211a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeDefinitionConnection(object):
    """Represents a connection of a definition of a node."""

    # Signals

    def __init__(self,
                 source_node_id, source_part_id,
                 target_node_id, target_part_id):
        """Constructor.

        :param source_node_id: the identifier of the source node.
        :type  source_node_id: uuid.uuid4
        :param source_part_id: the identifier of the part of the source node.
        :type  source_part_id: uuid.uuid4
        :param target_node_id: the identifier of the target node.
        :type  target_node_id: uuid.uuid4
        :param target_part_id: the identifier of the part of the target node.
        :type  target_part_id: uuid.uuid4
        """

        self.source_node_id = source_node_id
        self.source_part_id = source_part_id
        self.target_node_id = target_node_id
        self.target_part_id = target_part_id|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap211}\raggedright\small
\NWtarget{nuweb211b}{} $\langle\,${\itshape Node definition definition domain model declarations}\nobreak\ {\footnotesize {211b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeDefinitionDefinition(object):
    """Represents a definition part of a definition of a node."""

    def __init__(self, id_, script):
        """Constructor.

        :param id_: the globally unique identifier of the definition.
        :type  id_: uuid.uuid4
        :param script: the script part of the definition.
        :param script: str
        """

        self.id_ = id_
        self.script = script|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap212}\raggedright\small
\NWtarget{nuweb212a}{} $\langle\,${\itshape Node definition invocation domain model declarations}\nobreak\ {\footnotesize {212a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class NodeDefinitionInvocation(object):
    """Represents an invocation of a definition of a node."""

    def __init__(self, id_, script):
        """Constructor.

        :param id_: the globally unique identifier of the definition.
        :type  id_: uuid.uuid4
        :param script: the script part of the invocation.
        :param script: str
        """

        self.id_ = id_
        self.script = script|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb207b}{207b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap213}\raggedright\small
\NWtarget{nuweb212b}{} \verb@"../src/qde/editor/gui/node.py"@\nobreak\ {\footnotesize {212b}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""Module holding node related aspects."""

# System imports
import functools
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets

# Project imports
from qde.editor.foundation import common
from qde.editor.gui_domain import node   as node_gui_domain
from qde.editor.gui_domain import helper as gui_helper


|\hbox{$\langle\,${\itshape Add node dialog declarations}\nobreak\ {\footnotesize \NWlink{nuweb182}{182}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap214}\raggedright\small
\NWtarget{nuweb212c}{} $\langle\,${\itshape Node controller signals}\nobreak\ {\footnotesize {212c}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_add_node_model = QtCore.pyqtSignal(node_domain.NodeModel, node_gui_domain.NodeViewModel)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb184b}{184b}\NWlink{nuweb212c}{, 212c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap215}\raggedright\small
\NWtarget{nuweb213}{} $\langle\,${\itshape Node controller slots}\nobreak\ {\footnotesize {213}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(uuid.UUID)
def on_node_added(self, id):
    if id in self.node_definitions:
        node_definitions = self.node_definitions[id]

        domain_model = node_definitions[0]
        view_model   = node_definitions[1]

        # Create node domain model
        node_domain_model = node_domain.NodeModel(
            id_=domain_model.id_,
            name=domain_model.name
        )

        inputs = []
        for input in domain_model.inputs:
            self.logger.debug("Creating input %s", input.id_)
            input = node_domain.NodePart(input.id_, input.default_function)
            inputs.append(input)
        node_domain_model.inputs = inputs

        outputs = []
        for output in domain_model.outputs:
            self.logger.debug("Creating output %s of type %s", output.id_, output.type_)
            value = parameter.create_value(
                output.type_.name, ""
            )
            value_function = node_domain.create_value_function(value)
            output = node_domain.NodePart(output.id_, value_function, output.type_)
            outputs.append(output)
        node_domain_model.outputs = outputs

        definitions = []
        for definition in domain_model.definitions:
            self.logger.debug("Creating definition %s", definition.id_)
            value = parameter.create_value(
                types.NodeType.FLOAT.name, 0.0
            )
            value_function = node_domain.create_value_function(value)
            definition = node_domain.NodePart(
                definition.id_, value_function, types.NodeType.FLOAT, definition.script
            )
            definitions.append(definition)
        node_domain_model.definitions = definition

        invocations = []
        for invocation in domain_model.invocations:
            self.logger.debug("Creating invocation %s", invocation.id_)
            value = parameter.create_value(
                types.NodeType.FLOAT.name, 0.0
            )
            value_function = node_domain.create_value_function(value)
            invocation = node_domain.NodePart(
                invocation.id_, value_function, types.NodeType.FLOAT, invocation.script
            )
            invocations.append(invocation)
        node_domain_model.invocations = invocations

        parts = []
        for part in domain_model.parts:
            self.logger.debug("Creating part %s", part.id_)
            value = parameter.create_value(
                output.type_.name, ""
            )
            value_function = node_domain.create_value_function(value)
            part = node_domain.NodePart(part.id_, value_function, part.type_)
            parts.append(output)
        node_domain_model.parts = parts

        # Create node view model
        node_view_model = node_gui_domain.NodeViewModel(
            id_=node_domain_model.id_,
            domain_object=node_domain_model
        )

        # Inform other components about creation
        self.do_add_node_model.emit(node_domain_model, node_view_model)
        self.logger.debug("Added new node %s" % (node_domain_model))
    else:
        self.logger.warn("%s: Node definition %s not found!" % (__name__, id))|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb149a}{149a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap216}\raggedright\small
\NWtarget{nuweb214a}{} $\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize {214a}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
painter.setClipRect(option.exposedRect)
painter.drawPixmap(0, 0, pixmap)

if self.isSelected():
    color = QtGui.QColor(23, 135, 84)
    painter.setPen(color)
    painter.setBrush(QtGui.QBrush(color, QtCore.Qt.SolidPattern))
    painter.drawRect(
        0,
        self.boundingRect().height() - 2,
        self.boundingRect().width(),
        self.boundingRect().height()
    )

# TODO: Use another color if bypassed or hidden
painter.setPen(QtCore.Qt.white)

# Label
painter.drawText(self.boundingRect().adjusted(1, -9, -9, -1), QtCore.Qt.AlignCenter, self.name)
painter.drawText(self.boundingRect().adjusted(1, 20, -9, -1), QtCore.Qt.AlignCenter, self.type_.name)|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb132b}{132b}\NWlink{nuweb132c}{c}\NWlink{nuweb133}{, 133}\NWlink{nuweb214a}{, 214a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb130b}{130b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap217}\raggedright\small
\NWtarget{nuweb214b}{} $\langle\,${\itshape Node definition output domain model methods}\nobreak\ {\footnotesize {214b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|property
def type_(self):
    """returns the type of the node definition output.

    :return: the type of the output given by the node definition part
    :rtype:  qde.editor.foundation.types.nodetype
    """

    return self.node_definition_part.type_
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb174a}{174a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap218}\raggedright\small
\NWtarget{nuweb214c}{} $\langle\,${\itshape Node view model signals}\nobreak\ {\footnotesize {214c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
do_select_node = QtCore.pyqtSignal()
do_deselect_node = QtCore.pyqtSignal()|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap219}\raggedright\small
\NWtarget{nuweb215}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {215}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
def mouseReleaseEvent(self, event):
    """Event that gets triggered when the mouse was released over the current
    node.

    :param event: the event.
    :type  event: PyQt5.QtGui.QMouseEvent
    """

    self.setSelected(self.isSelected())
    if self.isSelected():
        self.logger.debug("Node %s was selected", self.id_)
        self.do_select_node.emit()
    super(NodeViewModel, self).mouseReleaseEvent(event)

def itemChange(self, change, value):
    if (change == Qt.QGraphicsItem.ItemSelectedHasChanged):
        self.logger.debug("Node %s was deselected", self.id_)
        self.do_deselect_node.emit()

    return super(NodeViewModel, self).itemChange(change, value)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb129a}{129a}\NWlink{nuweb129b}{b}\NWlink{nuweb130b}{, 130b}\NWlink{nuweb131b}{, 131b}\NWlink{nuweb132a}{, 132a}\NWlink{nuweb209}{, 209}\NWlink{nuweb215}{, 215}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb128a}{128a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap220}\raggedright\small
\NWtarget{nuweb216}{} \verb@"../src/qde/editor/foundation/flag.py"@\nobreak\ {\footnotesize {216}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

"""Module for flag-specific aspects."""

# System imports
import enum

# Project imports


class NodeStatus(enum.Enum):
    """Statues which a node can have."""

    OK              = 0
    NO_INPUTS       = 1
    WRONG_INPUT     = 2
    INPUT_ERRONEOUS = 3
    INPUT_CYCLIC    = 4
    LINK_MISSING    = 5
    TOO_MANY_INPUTS = 6


class Geometry(enum.Enum):
    """Flags denoting the type of geometric buffer."""

    STATIC          = 1
    DYNAMIC         = 2
    INDEX_BUFFER_16 = 4
    INDEX_BUFFER_32 = 8


class BlendMode(enum.Enum):
    """Flags denoting the available blend modes."""

    ZERO        = 1
    ONE         = 2
    SRCCOLOR    = 3
    INVSRCCOLOR = 4
    SRCALPHA    = 5
    INVSRCALPHA = 6
    DSTALPHA    = 7
    INVDSTALPHA = 8
    DSTCOLOR    = 9
    INVDSTCOLOR = 10


class BlendOperations(enum.Enum):
    """Flags denoting the available blend operations."""
    
    ADD    = 1
    SUB    = 2
    INVSUB = 3
    MIN    = 4
    MAX    = 5


class Culling(enum.Enum):
    """Flags denoting the available modes for culling."""

    NONE  = 1
    FRONT = 2
    BACK  = 3

class Depth(enum.Enum):
    """Flags denoting the available depth modes."""

    LESS          = 1
    EQUAL         = 2
    LESS_EQUAL    = 3
    GREATER       = 4
    NOT_EQUAL     = 5
    GREATER_EQUAL = 6
    ALWAYS        = 7


class TextureMaterial(enum.Enum):
    """Flags denoting the possible filtering modes for textures."""

    NEAREST   = 1
    BILINEAR  = 2
    TRILINEAR = 4
    PCF       = 8
    WRAPX     = 16
    WRAPY     = 32
    CLAMPX    = 64
    CLAMPY    = 128
    MIRRORX   = 256
    MIRRORY   = 512
    WRAP      = WRAPX   or WRAPY
    CLAMP     = CLAMPX  or CLAMPY
    MIRROR    = MIRRORX or MIRRORY
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap221}\raggedright\small
\NWtarget{nuweb217}{} \verb@"../src/qde/editor/foundation/constant.py"@\nobreak\ {\footnotesize {217}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

"""Module for constants."""

# System imports
import enum

# Project imports


class Graphics(object):
    """Constants related to graphical things."""

    MAXIMUM_TEXTURES       = 5
    MAXIMUM_RENDER_TARGETS = 5


class Buffer(enum.Enum):
    """Constants for buffers."""

    VERTEX_BUFFER_DYNAMIC = 0
    INDEX_BUFFER_DYNAMIC  = 1
    FRAME_BUFFER_DYNAMIC  = 2


class ShaderData(enum.Enum):
    """Constants for shader data."""

    CAMERA = 1
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap222}\raggedright\small
\NWtarget{nuweb218a}{} \verb@"../src/qde/editor/technical/json.py"@\nobreak\ {\footnotesize {218a}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding JSON related aspects.
"""

# System imports
import json
import uuid

# Project imports
from qde.editor.foundation import common
from qde.editor.foundation import type as types
from qde.editor.domain import node
from qde.editor.domain import parameter


|\hbox{$\langle\,${\itshape JSON module declarations}\nobreak\ {\footnotesize \NWlink{nuweb218b}{218b}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap223}\raggedright\small
\NWtarget{nuweb218b}{} $\langle\,${\itshape JSON module declarations}\nobreak\ {\footnotesize {218b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class Json(object):
    """Class handling JSON relevant tasks.
    """

    |\hbox{$\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize \NWlink{nuweb163}{163}, \ldots\ }$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb218a}{218a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap224}\raggedright\small
\NWtarget{nuweb219}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {219}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def build_node_definition_connection(cls, json_input):
    """Builds and returns a connection for a node definition from the given
    JSON input data.

    :param json_input: the input in JSON format
    :type  json_input: dict

    :return: the connection of a node definition.
    :rtype:  qde.editor.domain.node.NodeDefinitionConnection
    """

    source_node_id = uuid.UUID(json_input['source_node'])
    source_part_id = uuid.UUID(json_input['source_part'])
    target_node_id = uuid.UUID(json_input['target_node'])
    target_part_id = uuid.UUID(json_input['target_part'])

    node_definition_connection = node.NodeDefinitionConnection(
        source_node_id,
        source_part_id,
        target_node_id,
        target_part_id
    )

    cls.logger.debug("Built node definition connection")
    return node_definition_connection
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb163}{163}\NWlink{nuweb166}{, 166}\NWlink{nuweb173}{, 173}\NWlink{nuweb175}{, 175}\NWlink{nuweb180}{, 180}\NWlink{nuweb219}{, 219}\NWlink{nuweb220}{, 220}\NWlink{nuweb221}{, 221}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb218b}{218b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap225}\raggedright\small
\NWtarget{nuweb220}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {220}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def build_node_definition_definition(cls, json_input):
    """Builds and returns a definition for a node definition from the given
    JSON input data.

    :param json_input: the input in JSON format
    :type  json_input: dict

    :return: the definition of a node definition.
    :rtype:  qde.editor.domain.node.NodeDefinitionDefinition
    """

    definition_id = uuid.UUID(json_input['id_'])
    script        = str(json_input['script'])

    node_definition_definition = node.NodeDefinitionDefinition(
        definition_id,
        script
    )

    cls.logger.debug("Built node definition definition")
    return node_definition_definition
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb163}{163}\NWlink{nuweb166}{, 166}\NWlink{nuweb173}{, 173}\NWlink{nuweb175}{, 175}\NWlink{nuweb180}{, 180}\NWlink{nuweb219}{, 219}\NWlink{nuweb220}{, 220}\NWlink{nuweb221}{, 221}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb218b}{218b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap226}\raggedright\small
\NWtarget{nuweb221}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {221}}$\,\rangle+\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def build_node_definition_invocation(cls, json_input):
    """Builds and returns a invocation for a node definition from the given
    JSON input data.

    :param json_input: the input in JSON format
    :type  json_input: dict

    :return: the invocation of a node definition.
    :rtype:  qde.editor.domain.node.NodeDefinitionInvocation
    """

    invocation_id = uuid.UUID(json_input['id_'])
    script        = str(json_input['script'])

    node_definition_invocation = node.NodeDefinitionInvocation(
        invocation_id,
        script
    )

    cls.logger.debug("Built node definition invocation")
    return node_definition_invocation
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb163}{163}\NWlink{nuweb166}{, 166}\NWlink{nuweb173}{, 173}\NWlink{nuweb175}{, 175}\NWlink{nuweb180}{, 180}\NWlink{nuweb219}{, 219}\NWlink{nuweb220}{, 220}\NWlink{nuweb221}{, 221}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb218b}{218b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap227}\raggedright\small
\NWtarget{nuweb222}{} \verb@"../src/qde/editor/gui_domain/helper.py"@\nobreak\ {\footnotesize {222}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
#!/usr/bin/python
# -*- coding: utf-8 -*-

"""Module holding graphical user interface related helper classes and
methods."""

# System imports
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets

# Project importss
from qde.editor.foundation import common
from qde.editor.gui_domain import node


|\normalfont{}\fontfamily{}|common.with_logger
class ClickableLabel(QtWidgets.QLabel):
    """Class providing a label object which emits a signal called 'clicked'
    when receiving a mouse press event."""

    # Signals
    do_add_node = QtCore.pyqtSignal()

    def __init__(self, text, parent):
        """Constructor.

        :param text: the text, that the label will show.
        :type text: str
        :param parent: the parent object of this label.
        :type parent: Qt.QObject
        """

        super(ClickableLabel, self).__init__(text, parent)
        parent.installEventFilter(self)
        label_font = QtGui.QFont()
        label_font.setFamily(label_font.defaultFamily())
        self.setFont(label_font)
        self.logger.debug(self.font())

    def eventFilter(self, object, event):
        if event.type() == QtCore.QEvent.Enter:
            font = self.font()
            font.setUnderline(True)
            self.setFont(font)
            return True
        elif event.type() == QtCore.QEvent.Leave:
            font = self.font()
            font.setUnderline(False)
            self.setFont(font)
            return True

        return False

    |\hbox{$\langle\,${\itshape Mouse press event of clickable label}\nobreak\ {\footnotesize \NWlink{nuweb223a}{223a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap228}\raggedright\small
\NWtarget{nuweb223a}{} $\langle\,${\itshape Mouse press event of clickable label}\nobreak\ {\footnotesize {223a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
    def mousePressEvent(self, event):
        """Event handler when a mouse button was pressed on this label. Emits a
        signal called 'do_add_node'.

        :param event: the event which occurred.
        :type event: Qt.QMouseEvent
        """

        self.do_add_node.emit()
        super(ClickableLabel, self).mousePressEvent(event)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb222}{222}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap229}\raggedright\small
\NWtarget{nuweb223b}{} \verb@"../src/qde/editor/technical/graphics.py"@\nobreak\ {\footnotesize {223b}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

"""Module providing an abstraction layer for graphics."""

# System imports
import jinja2
import numpy as np
import os
import sys
from PyQt5 import QtCore
from PyQt5 import QtGui

# Project imports
from qde.editor.foundation import common
from qde.editor.foundation import constant
from qde.editor.foundation import flag
from qde.editor.technical import geometry


|\hbox{$\langle\,${\itshape Graphics class}\nobreak\ {\footnotesize \NWlink{nuweb224}{224}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Render state class}\nobreak\ {\footnotesize \NWlink{nuweb225a}{225a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Shader data class}\nobreak\ {\footnotesize \NWlink{nuweb225b}{225b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Shader object class}\nobreak\ {\footnotesize \NWlink{nuweb226a}{226a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap230}\raggedright\small
\NWtarget{nuweb224}{} $\langle\,${\itshape Graphics class}\nobreak\ {\footnotesize {224}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class Graphics(object):
    """A class providing an abstraction layer for the graphical processing
    unit."""

    __singleton_instance = None

    |\hbox{$\langle\,${\itshape Graphics constructor}\nobreak\ {\footnotesize \NWlink{nuweb226b}{226b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics activate render state}\nobreak\ {\footnotesize \NWlink{nuweb226c}{226c}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics activate render target}\nobreak\ {\footnotesize \NWlink{nuweb227a}{227a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics activate all render targets}\nobreak\ {\footnotesize \NWlink{nuweb227b}{227b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics add geometry}\nobreak\ {\footnotesize \NWlink{nuweb228}{228}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics add shader}\nobreak\ {\footnotesize \NWlink{nuweb229}{229}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics clear}\nobreak\ {\footnotesize \NWlink{nuweb230a}{230a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics clear render state}\nobreak\ {\footnotesize \NWlink{nuweb230b}{230b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics create buffer}\nobreak\ {\footnotesize \NWlink{nuweb231a}{231a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics create FBO}\nobreak\ {\footnotesize \NWlink{nuweb231b}{231b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics create IBO}\nobreak\ {\footnotesize \NWlink{nuweb232a}{232a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics create VAO}\nobreak\ {\footnotesize \NWlink{nuweb232b}{232b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics create VBO}\nobreak\ {\footnotesize \NWlink{nuweb232c}{232c}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics deactivate all render targets}\nobreak\ {\footnotesize \NWlink{nuweb233c}{233c}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics deactivate current render state}\nobreak\ {\footnotesize \NWlink{nuweb233a}{233a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics deactivate render target}\nobreak\ {\footnotesize \NWlink{nuweb233b}{233b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics load geometry}\nobreak\ {\footnotesize \NWlink{nuweb234}{234}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics get attribute location}\nobreak\ {\footnotesize \NWlink{nuweb236a}{236a}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics get uniform location}\nobreak\ {\footnotesize \NWlink{nuweb236b}{236b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics load shader from template}\nobreak\ {\footnotesize \NWlink{nuweb237}{237}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics render geometry}\nobreak\ {\footnotesize \NWlink{nuweb238}{238}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics render implicit}\nobreak\ {\footnotesize \NWlink{nuweb240b}{240b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics set clear color}\nobreak\ {\footnotesize \NWlink{nuweb240c}{240c}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics set up IBO}\nobreak\ {\footnotesize \NWlink{nuweb241}{241}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics set up VAO}\nobreak\ {\footnotesize \NWlink{nuweb242}{242}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics set up VBO}\nobreak\ {\footnotesize \NWlink{nuweb243}{243}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics set value for uniform}\nobreak\ {\footnotesize \NWlink{nuweb244}{244}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics convert vertices to array}\nobreak\ {\footnotesize \NWlink{nuweb245a}{245a}}$\,\rangle$}|

    # Slots

    # Classmethods

    |\hbox{$\langle\,${\itshape Graphics create instance}\nobreak\ {\footnotesize \NWlink{nuweb245b}{245b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Graphics get instance}\nobreak\ {\footnotesize \NWlink{nuweb246a}{246a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb223b}{223b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap231}\raggedright\small
\NWtarget{nuweb225a}{} $\langle\,${\itshape Render state class}\nobreak\ {\footnotesize {225a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class RenderState(object):
    """A class representing the state of rendering."""

    def __init__(self):
        self.blend_source      = flag.BlendMode.ONE
        self.blend_destination = flag.BlendMode.ZERO
        self.blend_operation   = flag.BlendOperations.ADD
        self.cull_mode         = flag.Culling.NONE
        self.depth_func        = flag.Depth.LESS
        self.depth_test        = True
        self.depth_write       = True
        self.render_target     = None
        self.shader_object     = None
        self.textures          = []
        self.texture_flags     = {}
        self.viewport          = QtCore.QRect()
        self.write_colors      = True

        tm = flag.TextureMaterial
        flags = tm.CLAMP or tm.BILINEAR
        for i in range(constant.Graphics.MAXIMUM_TEXTURES):
            self.texture_flags[i] = flags
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb223b}{223b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap232}\raggedright\small
\NWtarget{nuweb225b}{} $\langle\,${\itshape Shader data class}\nobreak\ {\footnotesize {225b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class ShaderData(object):
    """A class holding GLSL shader related data."""


    class Data(object):
        """"A class for holding arbitrary structures."""

        pass

    def __init__(self, type):
        """Constructor."""

        self._type = type
        self.data  = self.Data()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb223b}{223b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap233}\raggedright\small
\NWtarget{nuweb226a}{} $\langle\,${\itshape Shader object class}\nobreak\ {\footnotesize {226a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class ShaderObject(object):
    """A class representing an OpenGL Shading Language (GLSL) shader object
    containing a compute, a fragment and a vertex shader, as well as the
    shader's data an program."""

    def __init__(self):
        """Constructor."""

        self.compute_shader  = None
        self.fragment_shader = None
        self.program         = None
        self.shader_data     = None
        self.vertex_shader   = None
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb223b}{223b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap234}\raggedright\small
\NWtarget{nuweb226b}{} $\langle\,${\itshape Graphics constructor}\nobreak\ {\footnotesize {226b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, opengl_context, size, path="data"):
    """Constructor."""

    self.ctx    = opengl_context
    self.size   = size
    self.path   = path

    self.gl     = self.ctx.version_functions
    self.width  = size.width()
    self.height = size.height()

    self.render_state   = RenderState()

    self.geometries     = []
    self.shader_objects = []
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap235}\raggedright\small
\NWtarget{nuweb226c}{} $\langle\,${\itshape Graphics activate render state}\nobreak\ {\footnotesize {226c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def activate_render_state(self):
    """Clears the buffer bits and activates the render targets of the
    current rendering state."""

    self.clear()
    self.activate_render_targets()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap236}\raggedright\small
\NWtarget{nuweb227a}{} $\langle\,${\itshape Graphics activate render target}\nobreak\ {\footnotesize {227a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def activate_render_target(self, rt):
    """Activates (binds) the given render target.

    :param rt: the render target to activate/bind.
    :type rt:  TODO
    """

    if rt is not None:
        if rt.isValid() and not rt.isBound():
            rt.bind()
            self.clear()
        else:
            self.logger.warn(
                "Render target (id=%s) is fishy, cannot bind. Valid: %s",
                rt.handle(), rt.isValid()
            )
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap237}\raggedright\small
\NWtarget{nuweb227b}{} $\langle\,${\itshape Graphics activate all render targets}\nobreak\ {\footnotesize {227b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def activate_render_targets(self):
    """Activates (binds) all available render targets."""

    rt = self.render_state.render_target
    self.activate_render_target(rt)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap238}\raggedright\small
\NWtarget{nuweb228}{} $\langle\,${\itshape Graphics add geometry}\nobreak\ {\footnotesize {228}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def add_geometry(self, flags, vertex_type, primitive_type,
                 fill_callback=None, fill_callback_params=None):
    """TODO: Describe method."""

    new_geometry = geometry.Geometry()
    # TODO: Fix this!
    # new_geometry.is_dynamic = (flags & qflags.Geometry.dynamic.value)
    new_geometry.is_dynamic = True
    new_geometry.vertex_type = vertex_type
    new_geometry.primitive_type = primitive_type
    new_geometry.fill_callback = fill_callback
    new_geometry.fill_callback_params = fill_callback_params
    # TODO: Fix this!
    # geometry.is_indexed = ((flags & qflags.Geometry.index_buffer_16.value) or
    #                        (flags & qflags.Geometry.index_buffer_32.value))
    new_geometry.is_indexed = True

    # TODO: Do this dynamically!
    new_geometry.vertex_size = sys.getsizeof(geometry.SimpleVertex)
    # TODO: geometry.index_size  = ?
    new_geometry.is_loading = False
    new_geometry.used_indices = 0
    new_geometry.used_vertices = 0
    new_geometry.max_indices = 0
    new_geometry.max_vertices = 0
    new_geometry.ibo = None
    new_geometry.vbo = None

    self.geometries.append(new_geometry)

    return new_geometry
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap239}\raggedright\small
\NWtarget{nuweb229}{} $\langle\,${\itshape Graphics add shader}\nobreak\ {\footnotesize {229}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def add_shader(self, name):
    """Creates and returns a OpenGL Shader Language (GLSL) object based on
    given files. Searches for a vertex and fragment shader templates
    matching the pattern 'given_name.vs.tpl'' and 'given_name.fs.tpl'
    respectively.

    :param name: the name of the shader and the shader template files.
    :type  name: str

    :return: a linked shader as a shader object
    :rtype:  qde.editor.technical.graphics.ShaderObject
    """

    shader_object = ShaderObject()
    path   = "{0}{1}{2}".format(
        self.path, os.path.sep, "shaders"
    )
    vertex_shader   = QtGui.QOpenGLShader(QtGui.QOpenGLShader.Vertex)
    fragment_shader = QtGui.QOpenGLShader(QtGui.QOpenGLShader.Fragment)
    program         = QtGui.QOpenGLShaderProgram(self.ctx)

    vs_tpl_name = "{0}.vs.tpl".format(name)
    vertex_shader.setObjectName(vs_tpl_name)
    fs_tpl_name = "{0}.fs.tpl".format(name)
    fragment_shader.setObjectName(fs_tpl_name)

    vs_tpl = self.load_shader_template(path, vs_tpl_name)
    fs_tpl = self.load_shader_template(path, fs_tpl_name)

    assert vertex_shader.compileSourceCode(vs_tpl.render()), \
        "Could not compile vertex shader for '%s' at '%s'" % (name, path)
    assert fragment_shader.compileSourceCode(fs_tpl.render()), \
        "Could not compile fragment shader for '%s' at '%s'" % (name, path)

    program.addShader(vertex_shader)
    program.addShader(fragment_shader)
    program.link()
    program.setObjectName(name)

    shader_object.vertex_shader = vertex_shader
    shader_object.fragment_shader = fragment_shader
    shader_object.program = program

    self.shader_objects.append(shader_object)

    return shader_object
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap240}\raggedright\small
\NWtarget{nuweb230a}{} $\langle\,${\itshape Graphics clear}\nobreak\ {\footnotesize {230a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def clear(self):
    """Clears the color and depth buffer bits."""

    # TODO: Move this to render_state
    self.logger.debug("Clearing")
    bitmask = self.gl.GL_COLOR_BUFFER_BIT or self.gl.GL_DEPTH_BUFFER_BIT
    self.gl.glClear(bitmask)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap241}\raggedright\small
\NWtarget{nuweb230b}{} $\langle\,${\itshape Graphics clear render state}\nobreak\ {\footnotesize {230b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def clear_render_state(self):
    """Clears the current render state. """

    self.render_state.depth_test = True
    self.render_state.depth_write = True
    self.render_state.depth_func = qflags.Depth.less

    self.render_state.cull_mode = qflags.Culling.back

    self.render_state.blend_source      = qflags.BlendMode.one
    self.render_state.blend_destination = qflags.BlendMode.zero
    self.render_state.blend_operation   = qflags.BlendOperations.add
    self.render_state.write_colors      = True

    tm = qflags.TextureMaterial
    flags = tm.clamp or tm.bilinear
    for i in range(qcns.Graphics.MAXIMUM_TEXTURES):
        self.render_state.texture_flags[i] = flags

    self.render_state.viewport.setWidth(self.width)
    self.render_state.viewport.setHeight(self.height)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap242}\raggedright\small
\NWtarget{nuweb231a}{} $\langle\,${\itshape Graphics create buffer}\nobreak\ {\footnotesize {231a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_buffer(self, buffer_type):
    """Creates a buffer object of given type.

    :param buffer_type: type of the buffer to create.
    :type  buffer_type: TODO

    :return: the created buffer object.
    :rtype:  TODO
    """

    buffer = QtGui.QOpenGLBuffer(buffer_type)
    buffer.create()

    return buffer
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap243}\raggedright\small
\NWtarget{nuweb231b}{} $\langle\,${\itshape Graphics create FBO}\nobreak\ {\footnotesize {231b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_fbo(self, size):
    """Creates a framebuffer object with the provided size.

    :param size: size of the render target.
    :type  size: PyQt5.QtCore.QSize

    :return: the created framebuffer object.
    :rtype:  PyQt5.QtGui.QOpenGLFramebufferObject
    """

    assert(self.ctx is not None)
    assert(self.ctx.isValid())
    surface = self.ctx.surface()
    if not self.ctx.makeCurrent(surface):
        message = "Could not make surface current, no FBO created!"
        self.logger.fatal(message)
        raise Exception(message)

    format = QtGui.QOpenGLFramebufferObjectFormat()
    format.setAttachment(QtGui.QOpenGLFramebufferObject.CombinedDepthStencil)
    # TODO: Use parameter for samples
    # TODO: Use samples
    format.setSamples(0)
    width = size.width()
    height = size.height()
    buffer = QtGui.QOpenGLFramebufferObject(width, height, format)

    return buffer
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap244}\raggedright\small
\NWtarget{nuweb232a}{} $\langle\,${\itshape Graphics create IBO}\nobreak\ {\footnotesize {232a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_ibo(self):
    """Creates a index buffer object (IBO).

    :return: the created index buffer object.
    :rtype:  TODO
    """

    ibo = self.create_buffer(QtGui.QOpenGLBuffer.IndexBuffer)

    return ibo
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap245}\raggedright\small
\NWtarget{nuweb232b}{} $\langle\,${\itshape Graphics create VAO}\nobreak\ {\footnotesize {232b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_vao(self):
    """Creates a vertex array object (VAO).

    :return: the created vertex array object.
    :rtype:  TODO
    """

    vao = QtGui.QOpenGLVertexArrayObject()
    vao.create()

    return vao
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap246}\raggedright\small
\NWtarget{nuweb232c}{} $\langle\,${\itshape Graphics create VBO}\nobreak\ {\footnotesize {232c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def create_vbo(self):
    """Creates a vertex buffer object (VBO).

    :return: the created vertex buffer object.
    :rtype:  TODO
    """

    vbo = self.create_buffer(QtGui.QOpenGLBuffer.VertexBuffer)

    return vbo
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap247}\raggedright\small
\NWtarget{nuweb233a}{} $\langle\,${\itshape Graphics deactivate current render state}\nobreak\ {\footnotesize {233a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def deactivate_render_state(self):
    """Deactivates the current render state."""

    self.deactivate_render_targets()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap248}\raggedright\small
\NWtarget{nuweb233b}{} $\langle\,${\itshape Graphics deactivate render target}\nobreak\ {\footnotesize {233b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def deactivate_render_target(self, rt):
    """Deactivates the given render target.

    :param rt: the render target to deactivate.
    :type  rt: TODO
    """

    if rt is not None:
        if rt.isValid() and rt.isBound():
            rt.release()
        else:
            self.logger.warn(
                "Render target (%s) is fishy, cannot release. Valid: %s",
                rt.handle(), rt.isValid()
            )
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap249}\raggedright\small
\NWtarget{nuweb233c}{} $\langle\,${\itshape Graphics deactivate all render targets}\nobreak\ {\footnotesize {233c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def deactivate_render_targets(self):
    """Deactivates all render targets."""

    rt = self.render_state.render_target
    self.deactivate_render_target(rt)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap250}\raggedright\small
\NWtarget{nuweb234}{} $\langle\,${\itshape Graphics load geometry}\nobreak\ {\footnotesize {234}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def load_geometry(self, geometry, vertices, indices=None, colors=None):
    """Loads the given geometry by adding vertices (optionally using
    indices) and colors.

    :param geometry: TODO
    :type geometry: TODO
    :param vertices: TODO
    :type vertices: TODO
    :param indices: TODO
    :type indices: TODO
    :param colors: TODO
    :type colors: TODO
    """

    assert(vertices is not None)
    assert(geometry.is_loading == False)

    program = self.render_state.shader_object.program

    vertex_location  = program.attributeLocation("a_position")
    if geometry.has_texture:
        texture_location = self.get_attribute_location(program,
                                                       "a_texCoords")

    geometry.is_loading    = True
    geometry.used_colors  = 0
    geometry.used_indices  = 0
    geometry.used_vertices = 0

    if indices is not None:
        geometry.is_indexed = True
    else:
        geometry.is_indexed = False
    self.logger.debug("Using indices: %s", geometry.is_indexed)
    self.logger.debug("Using texture: %s", geometry.has_texture)

    if geometry.is_dynamic:
        |\hbox{$\langle\,${\itshape Graphics load dynamic geometry}\nobreak\ {\footnotesize \NWlink{nuweb235}{235}}$\,\rangle$}|

    else:
        # TODO: Handle static geometries
        self.logger.warn("Static rendering not yet implemented")

    geometry.is_loading = False
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap251}\raggedright\small
\NWtarget{nuweb235}{} $\langle\,${\itshape Graphics load dynamic geometry}\nobreak\ {\footnotesize {235}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
vertex_array = self.vertices_to_array(geometry, *vertices)
self.logger.debug("Vertices: %s", vertex_array)
vao = self.setup_vao(geometry)
vbo = self.setup_vbo(geometry, vertex_array)

program.enableAttributeArray(vertex_location)
program.setAttributeBuffer(
    vertex_location,
    self.gl.GL_FLOAT,  # Type
    0,                 # Offset
    3,                 # Tuple size
    0                  # Stride
)
if geometry.is_indexed:
    self.logger.debug("Setting up IBO")
    ibo = self.setup_ibo(geometry, indices)
if colors not in [None, []]:
    self.logger.debug("Setting up CBO")
    colors_array = self.colors_to_array(colors)
    cbo = self.setup_cbo(geometry, colors_array)
    colors_location = self.get_attribute_location(program, "a_colors")
    program.enableAttributeArray(colors_location)
    program.setAttributeBuffer(
        colors_location,
        self.gl.GL_FLOAT,  # Type
        0,                 # Offset
        4,                 # Tuple size
        0,                 # Stride
    )
if geometry.has_texture:
    self.logger.debug("Setting up texture buffer")
    texture_coord_location = self.get_attribute_location(program, "a_texCoords")
    program.enableAttributeArray(texture_coord_location)
    program.setAttributeBuffer(
        texture_location,
        self.gl.GL_FLOAT,                 # Type
        3 * vertex_array.dtype.itemsize,  # Offset
        2,                                # Tuple size
        5 * vertex_array.dtype.itemsize,  # Stride
    )
if colors not in [None, []]:
    cbo.release()
if geometry.is_indexed:
    ibo.release()
vbo.release()
vao.release()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb234}{234}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap252}\raggedright\small
\NWtarget{nuweb236a}{} $\langle\,${\itshape Graphics get attribute location}\nobreak\ {\footnotesize {236a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def get_attribute_location(self, program, location):
    """Returns the location of the given attribute within the given shader
    program.


    :param program: TODO
    :type  program: TODO
    :param location: TODO
    :param location: TODO
    """

    program_location = program.attributeLocation(location)
    assert program_location > -1, \
        "Attribute '%s' not found in program '%s'" % (
            location,
            program.objectName()
        )

    return program_location
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap253}\raggedright\small
\NWtarget{nuweb236b}{} $\langle\,${\itshape Graphics get uniform location}\nobreak\ {\footnotesize {236b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def get_uniform_location(self, program, location):
    """Returns the location of the given uniform within the given shader
    program.


    :param program: TODO
    :type  program: TODO
    :param location: TODO
    :param location: TODO
    """

    program_location = program.uniformLocation(location)
    if program_location < 0:
        self.logger.warn("Uniform '%s' not found in program '%s'" %
                         (location, program.objectName()))

    return program_location
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap254}\raggedright\small
\NWtarget{nuweb237}{} $\langle\,${\itshape Graphics load shader from template}\nobreak\ {\footnotesize {237}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def load_shader_template(self, path, tpl_name):
    """Loads a shader template by the given name from the given path in the
    Jinja2 format.

    :param path: the path of the template to load.
    :type  path: str
    :param tpl_name: the name of the template to load.
    :type  tpl_name: str

    :return: the loaded template
    :rtype:  jinja2.Template
    """

    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(path)
    )
    return env.get_template(tpl_name)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap255}\raggedright\small
\NWtarget{nuweb238}{} $\langle\,${\itshape Graphics render geometry}\nobreak\ {\footnotesize {238}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def render_geometry(self, geometry):
    """Renders the given geometry.

    :param geometry: the geometry to render.
    :type geometry:  qde.editor.technical.geometry.Geometry
    """

    assert(geometry is not None)
    assert(not geometry.is_loading)

    if geometry.is_dynamic and geometry.fill_callback is not None:
        geometry.fill_callback(geometry, geometry.fill_callback_params)

    if not geometry.used_vertices:
        self.logger.warn("No used vertices for current geometry")
        return

    # TODO: Do this properly
    # self.gl.glMatrixMode(self.gl.GL_PROJECTION)

    self.activate_render_state()
    program = self.render_state.shader_object.program
    program.bind()
    self.logger.debug("Rendering using shader %s", program.objectName())
    vao = geometry.vertex_array_object
    vao.bind()
    vertex_location = self.get_attribute_location(program, "a_position")
    assert(vertex_location > -1)
    program.enableAttributeArray(vertex_location)

    # TODO: Do this dynamically
    |\hbox{$\langle\,${\itshape Graphics set global uniforms}\nobreak\ {\footnotesize \NWlink{nuweb239a}{239a}}$\,\rangle$}|

    # TODO: Read from render_state / geometry
    if geometry.is_indexed:
        |\hbox{$\langle\,${\itshape Graphics render indexed geometry}\nobreak\ {\footnotesize \NWlink{nuweb239b}{239b}}$\,\rangle$}|

    else:
        |\hbox{$\langle\,${\itshape Graphics render non-indexed geometry}\nobreak\ {\footnotesize \NWlink{nuweb240a}{240a}}$\,\rangle$}|

    vao.release()
    program.disableAttributeArray(vertex_location)
    program.release()
    self.deactivate_render_state()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap256}\raggedright\small
\NWtarget{nuweb239a}{} $\langle\,${\itshape Graphics set global uniforms}\nobreak\ {\footnotesize {239a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
resolution_location = self.get_uniform_location(program, "u_globalResolution")
resolution = QtGui.QVector2D(self.size.width(), self.size.height())
self.set_uniform_value(program, resolution_location, resolution)

if geometry.colour_buffer is None:
    color_location = self.get_uniform_location(program, "u_color")
    color = QtGui.QColor(100, 80, 150, 255)
    self.set_uniform_value(program, color_location, color)

# TODO: Set this using a camera class
mvp_matrix_location = self.get_uniform_location(program, "u_mvpMatrix")
# TODO: mvp_matrix = self.render_state.shader_object.shader_data.data.mvp_matrix
mvp_matrix = QtGui.QMatrix4x4()
mvp_matrix.setToIdentity()
self.set_uniform_value(program, mvp_matrix_location, mvp_matrix)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb238}{238}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap257}\raggedright\small
\NWtarget{nuweb239b}{} $\langle\,${\itshape Graphics render indexed geometry}\nobreak\ {\footnotesize {239b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
vao = geometry.vertex_array_object
vao.bind()

if geometry.has_texture:
    texture_coord_location = self.get_attribute_location(program, "a_texCoords")
    program.enableAttributeArray(texture_coord_location)
    self.gl.glActiveTexture(self.gl.GL_TEXTURE0)
    self.gl.glBindTexture(self.gl.GL_TEXTURE_2D, geometry.texture)
    texture_location = self.get_uniform_location(program, "u_texture")
    # TODO: Fix this!
    self.set_uniform_value(program, texture_location, 0)  # self.gl.GL_TEXTURE0)

if geometry.colour_buffer is not None:
    cbo = geometry.colour_buffer
    cbo.bind()

self.logger.debug("Rendering indexed using %d indices", geometry.used_indices)
# self.gl.glDrawArrays(self.gl.GL_TRIANGLES, 0, geometry.used_indices)
# self.gl.glDrawArrays(self.gl.GL_TRIANGLE_STRIP, 0, geometry.used_indices)
self.gl.glDrawElements(
    self.gl.GL_TRIANGLES,
    geometry.used_indices,
    self.gl.GL_UNSIGNED_INT,
    geometry.indices
)
if geometry.has_texture:
    program.disableAttributeArray(texture_coord_location)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb238}{238}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap258}\raggedright\small
\NWtarget{nuweb240a}{} $\langle\,${\itshape Graphics render non-indexed geometry}\nobreak\ {\footnotesize {240a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
self.logger.debug("Rendering non-indexed using %d vertices", geometry.used_vertices)
self.gl.glDrawArrays(self.gl.GL_TRIANGLES, 0, geometry.used_vertices)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb238}{238}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap259}\raggedright\small
\NWtarget{nuweb240b}{} $\langle\,${\itshape Graphics render implicit}\nobreak\ {\footnotesize {240b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def render_implicit(self):
    """Renders implicit scenes."""

    self.activate_render_state()
    program = self.render_state.shader_object.program
    program.bind()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap260}\raggedright\small
\NWtarget{nuweb240c}{} $\langle\,${\itshape Graphics set clear color}\nobreak\ {\footnotesize {240c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def set_clear_color(self, c):
    """Sets the clear color of OpenGL to the given color.

    :param c: the color to set the clear color to.
    :type  c: PyQt5.QtGui.QColor
    """

    self.clear_color = c
    self.gl.glClearColor(c.redF(), c.greenF(), c.blueF(), c.alphaF())
    self.clear()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap261}\raggedright\small
\NWtarget{nuweb241}{} $\langle\,${\itshape Graphics set up IBO}\nobreak\ {\footnotesize {241}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def setup_ibo(self, geometry, indices):
    """Sets up a index buffer object (IBO) and assigns it to the given
    geometry.

    :param geometry: the geometry which the generated IBO will be assigned
                     to.
    :type geometry:  qde.editor.technical.geometry.Geometry
    :param indices:  a numpy float32 array holding the ordered indices.
    :type indices:   numpy.array
    :return:         the generated IBO.
    :rtype:          TODO
    """

    indices_array = np.asarray(indices, dtype=np.int16)
    assert len(indices) == np.size(indices_array)

    required_ib_size      = np.size(indices_array) * indices_array.dtype.itemsize
    geometry.index_size   = required_ib_size
    geometry.max_indices  = np.size(indices_array)
    geometry.used_indices = np.size(indices_array)
    assert geometry.used_indices == len(indices)

    if geometry.index_buffer is None:
        ibo = self.create_ibo()
        geometry.index_buffer = ibo
    else:
        ibo = geometry.index_buffer
    assert(ibo.isCreated())
    assert(ibo.bind())

    ibo.allocate(indices_array.tostring(), required_ib_size)
    assert required_ib_size == ibo.size(), \
        "Required: %s, allocated: %s"  % (required_ib_size, ibo.size())

    geometry.indices = indices

    return ibo
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap262}\raggedright\small
\NWtarget{nuweb242}{} $\langle\,${\itshape Graphics set up VAO}\nobreak\ {\footnotesize {242}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def setup_vao(self, geometry):
    """Sets up a vertex array object (VAO) and assigns it to the given
    geometry.

    :param geometry: the geometry which the generated VAO will be assigned
                     to.
    :type geometry:  qde.editor.technical.geometry.Geometry
    :param vertices: a numpy float32 array holding the ordered vertices.
    :type vertices:  numpy.array

    :return:         the generated VAO.
    :rtype:          TODO
    """

    if geometry.vertex_array_object is None:
        vao = self.create_vao()
        geometry.vertex_array_object = vao
    else:
        vao = geometry.vertex_array_object
    assert(vao.isCreated())
    vao.bind()

    return vao
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap263}\raggedright\small
\NWtarget{nuweb243}{} $\langle\,${\itshape Graphics set up VBO}\nobreak\ {\footnotesize {243}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def setup_vbo(self, geometry, vertices):
    """Sets up a vertex buffer object (VBO) and assigns it to the given
    geometry.

    :param geometry: the geometry which the generated VBO will be assigned
                     to.
    :type geometry:  qgeom.Geometry
    :param vertices: an numpy float32 array holding the ordered vertices.
    :type vertices:  numpy.array
    :return:         the generated VBO.
    :rtype:          QOpenGLBuffer of type QOpenGLBuffer.VertexBuffer
    """

    if geometry.has_texture:
        required_vb_size   = np.size(vertices) * 5 * vertices.dtype.itemsize
    else:
        required_vb_size   = np.size(vertices) * 3 * vertices.dtype.itemsize
    geometry.vertex_size   = required_vb_size
    geometry.max_vertices  = np.size(vertices) / 3
    geometry.used_vertices = np.size(vertices) / 3

    if geometry.vertex_buffer is None:
        vbo = self.create_vbo()
        geometry.vertex_buffer = vbo
    else:
        vbo = geometry.vertex_buffer
    assert(vbo.isCreated())
    assert(vbo.bind())

    vbo.allocate(required_vb_size)
    assert required_vb_size == vbo.size(), \
        "Required: %s, allocated: %s"  % (required_vb_size, vbo.size())
    vbo.setUsagePattern(QtGui.QOpenGLBuffer.StaticDraw)
    vbo.write(0, vertices.tostring(), len(vertices.tostring()))
    geometry.vertices = vertices

    return vbo
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap264}\raggedright\small
\NWtarget{nuweb244}{} $\langle\,${\itshape Graphics set value for uniform}\nobreak\ {\footnotesize {244}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def set_uniform_value(self, program, location, value):
    """Sets the given value for the given location within the provided
    shader program.

    :param program: TODO
    :type program: TODO
    :param location: TODO
    :type location: TODO
    :param value: the value to set.
    :type value: TODO
    """

    assert(program is not None)
    assert(program.isLinked())
    assert(location is not None)
    assert(value is not None)

    if location >= 0:
        program.setUniformValue(location, value)
    else:
        self.logger.warn(
            "Could not set %s at %s within %s",
            value,
            location,
            program
        )
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap265}\raggedright\small
\NWtarget{nuweb245a}{} $\langle\,${\itshape Graphics convert vertices to array}\nobreak\ {\footnotesize {245a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def vertices_to_array(self, geometry, *vertices):
    """Returns the given vertices as array.

    :param geometry: TODO
    :type geometry: TODO
    :param vertices: TODO
    :type vertices: TODO

    :return: an array containing the given vertices.
    :rtype:  np.array
    """

    temp = []

    for v in vertices:
        pos = v.position
        temp.append(pos.x())
        temp.append(pos.y())
        temp.append(pos.z())

        if geometry.has_texture and v.uv is not None:
            temp.append(v.uv.x())
            temp.append(v.uv.y())

    return np.array(temp, dtype=np.float32)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap266}\raggedright\small
\NWtarget{nuweb245b}{} $\langle\,${\itshape Graphics create instance}\nobreak\ {\footnotesize {245b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def create(cls, opengl_context, path="data"):
    """Creates an instance of the graphics interface."""

    if cls.__singleton_instance is not None:
        raise Exception("Graphics was already created")

    cls.__singleton_instance = cls(opengl_context, path)
    return cls.__singleton_instance
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap267}\raggedright\small
\NWtarget{nuweb246a}{} $\langle\,${\itshape Graphics get instance}\nobreak\ {\footnotesize {246a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|classmethod
def instance(cls):
    """Returns the initialized singleton instance.

    :return: the singleton instance of the initialized graphics abstraction
             object.
    :rtype:  qde.editor.technical.graphics.Graphics
    """
    assert cls.__singleton_instance is not None, \
        "Graphics were not initialized yet"
    return cls.__singleton_instance
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb224}{224}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap268}\raggedright\small
\NWtarget{nuweb246b}{} \verb@"../src/qde/editor/technical/geometry.py"@\nobreak\ {\footnotesize {246b}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

"""Module holding geometrical definitions."""

# System imports
from PyQt5 import QtGui

# Project imports
from qde.editor.foundation import type as types


|\hbox{$\langle\,${\itshape Geometrical object class}\nobreak\ {\footnotesize \NWlink{nuweb246c}{246c}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Vertex class}\nobreak\ {\footnotesize \NWlink{nuweb247a}{247a}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Geometry class}\nobreak\ {\footnotesize \NWlink{nuweb247b}{247b}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Simple vertex class}\nobreak\ {\footnotesize \NWlink{nuweb248}{248}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap269}\raggedright\small
\NWtarget{nuweb246c}{} $\langle\,${\itshape Geometrical object class}\nobreak\ {\footnotesize {246c}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class GeometricalObject(object):
    """Class providing a basis for any geometrical object, containing a
    teporary value and a tag, acting as counters."""

    def __init__(self):
        self.temp = 0
        self.tag  = 0
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb246b}{246b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap270}\raggedright\small
\NWtarget{nuweb247a}{} $\langle\,${\itshape Vertex class}\nobreak\ {\footnotesize {247a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class Vertex(GeometricalObject):
    """Class providing an abstraction to vertices."""

    def __init__(self):
        self.position = QtGui.QVector3D()
        self.normal   = None
        self.uv       = None
        self.color    = QtGui.QColor()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb246b}{246b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap271}\raggedright\small
\NWtarget{nuweb247b}{} $\langle\,${\itshape Geometry class}\nobreak\ {\footnotesize {247b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class Geometry(GeometricalObject):
    """Class providing an abstraction to geometrical objects."""

    def __init__(self):
        """Constructor."""
        self._type                   = types.GeometryPrimitive.TRIANGLE_LIST
        self.colour_buffer           = None
        self.face_culling_parameters = None
        self.fill_callback           = None
        self.fill_callback_params    = None
        self.index_buffer            = None
        self.index_size              = 0
        self.indices                 = []
        self.is_loading              = False
        self.is_indexed              = False
        self.is_dynamic              = False
        self.max_vertices            = 0
        self.max_indices             = 0
        self.texture                 = None
        self.used_colors             = 0
        self.used_indices            = 0
        self.used_vertices           = 0
        self.vertex_array_object     = None
        self.vertex_buffer           = None
        self.vertex_size             = 0
        self.vertex_type             = types.Vertex.FULL
        self.vertices                = []

    |\normalfont{}\fontfamily{}|property
    def has_texture(self):
        return self.texture is not None
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb246b}{246b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap272}\raggedright\small
\NWtarget{nuweb248}{} $\langle\,${\itshape Simple vertex class}\nobreak\ {\footnotesize {248}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class SimpleVertex(GeometricalObject):
    """Class representing a simplified vertex, containing only its position and
    texture coordinates (UV)."""

    def __init__(self):
        """Constructor."""

        self.position = QtGui.QVector3D()
        self.uv       = QtGui.QVector2D()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb246b}{246b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: poly-latex+python; coding: utf-8 -*-

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap273}\raggedright\small
\NWtarget{nuweb249}{} \verb@"../src/qde/editor/gui/render.py"@\nobreak\ {\footnotesize {249}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

"""Module holding renderering related aspects concerning the graphical user
interface layer."""

# System imports
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets


# Project imports
from qde.editor.foundation import common
from qde.editor.foundation import type as node_types
from qde.editor.technical  import graphics
from qde.editor.technical  import render
from qde.editor.gui_domain import node as node_gui_domain


|\normalfont{}\fontfamily{}|common.with_logger
class RenderView(QtWidgets.QOpenGLWidget):
    """The render view widget. A widget for rendering nodes."""

    OPENGL_MAJOR        = 4
    OPENGL_MINOR        = 1


    |\hbox{$\langle\,${\itshape Render view constructor}\nobreak\ {\footnotesize \NWlink{nuweb250}{250}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Render view initialize OpenGL}\nobreak\ {\footnotesize \NWlink{nuweb251}{251}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Render view check for valid render target}\nobreak\ {\footnotesize \NWlink{nuweb252a}{252a}}$\,\rangle$}|

    def paintGL(self):
        """Renders the currently set content."""

        self.render_current_node()

    |\hbox{$\langle\,${\itshape Render view render current node}\nobreak\ {\footnotesize \NWlink{nuweb252b}{252b}}$\,\rangle$}|

    def render_none(self):
        """Renders nothing except a solid background color."""

        color = QtGui.QColor(QtCore.Qt.cyan)
        self.gfx.set_clear_color(color)

    def render_implicit(self, node):
        """Renders the given node of type implicit."""

        self.logger.debug("Rendering implicit")
        self.render_scene(scene=None, camera=None, time=0.0)

    |\hbox{$\langle\,${\itshape Render view render scene}\nobreak\ {\footnotesize \NWlink{nuweb253a}{253a}}$\,\rangle$}|

    def resizeGL(self, w, h):
        """Gets triggered whenever the widget's view port is resized."""

        size = QtCore.QSize(w, h)
        self.gfx.size = size
        self.has_view_changed = True
        # self.update()

    def setup_render_target(self):
        """Sets up a render target."""

        # TODO: Remove current fbo?
        if not self.has_valid_render_target():
            self.render_target = self.gfx.create_fbo(self.size())

    # Slots

    |\hbox{$\langle\,${\itshape Render view handle node selection}\nobreak\ {\footnotesize \NWlink{nuweb253b}{253b}}$\,\rangle$}|
    |\hbox{$\langle\,${\itshape Render view handle node deselection}\nobreak\ {\footnotesize \NWlink{nuweb254a}{254a}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap274}\raggedright\small
\NWtarget{nuweb250}{} $\langle\,${\itshape Render view constructor}\nobreak\ {\footnotesize {250}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def __init__(self, parent=None):
    """Constructor."""

    super(RenderView, self).__init__(parent)

    self.current_node  = None
    self.render_target = None
    self.renderer      = None

    self.has_view_changed = False

    self.surface_format = QtGui.QSurfaceFormat()
    self.surface_format.setProfile(QtGui.QSurfaceFormat.CoreProfile)
    self.surface_format.setVersion(self.OPENGL_MAJOR, self.OPENGL_MINOR)

    self.version_profile = QtGui.QOpenGLVersionProfile(self.surface_format)
    self.version_profile.setProfile(QtGui.QSurfaceFormat.CoreProfile)
    self.version_profile.setVersion(self.OPENGL_MAJOR, self.OPENGL_MINOR)

    self.setFocusPolicy(QtCore.Qt.StrongFocus)
    self.setFormat(self.surface_format)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb249}{249}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap275}\raggedright\small
\NWtarget{nuweb251}{} $\langle\,${\itshape Render view initialize OpenGL}\nobreak\ {\footnotesize {251}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def initializeGL(self):
    """Initializes OpenGL."""

    try:
        version_functions = self.context().versionFunctions(
            self.version_profile
        )
        if version_functions is None:
            message = (
                'Could not initialize OpenGL with profile {0}'
            ).format(
                self.surface_format.version()
            )
            self.logger.fatal(message)
            raise Exception(message)

    except Exception as e:
            message = (
                'Could not initialize OpenGL with profile {0} ({1})'
            ).format(
                self.surface_format.version(),
                e
            )
            self.logger.fatal(message)
            raise Exception(message)

    self.ctx = self.context()
    self.ctx.version_functions = version_functions
    self.ctx.size = self.frameSize()
    self.gfx = graphics.Graphics.create(self.ctx, self.size())
    self.renderer = render.RayMarchingRenderer(self.ctx)

    # Seems to happen under OS X (10.11) using PyQt5.7 on an Intel
    # Iris 6100 only.
    # The main render target seem to need the ID 1, as otherwise
    # the render target is empty. Well, there _is_ data, but somehow
    # it is not usable, although it has the same properties as when
    # the render target is set up first.
    self.setup_render_target()

    color = QtGui.QColor(QtCore.Qt.black)
    self.gfx.set_clear_color(color)

    self.logger.info('Initialized OpenGL with profile {0} at ({1})'.format(
        self.surface_format.version(),
        self.size()
    ))
    self.logger.info("Size: %s", self.frameSize())

|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb249}{249}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap276}\raggedright\small
\NWtarget{nuweb252a}{} $\langle\,${\itshape Render view check for valid render target}\nobreak\ {\footnotesize {252a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def has_valid_render_target(self):
    """Returns wether the render target is valid or not.

    :return: the validity of the render target.
    :rtype:  bool
    """

    if self.render_target is None:
        return False

    if self.render_target.size() != self.size():
        return False

    return True
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb249}{249}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap277}\raggedright\small
\NWtarget{nuweb252b}{} $\langle\,${\itshape Render view render current node}\nobreak\ {\footnotesize {252b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def render_current_node(self):
    """Renders the currently selected node."""

    # TODO: Process node (time-wise)
    # TODO: Set view changed to True if node has been processed/

    if self.has_view_changed:
        if self.current_node is None:
            self.render_none()
            self.logger.warn("No node set for rendering")
        elif self.current_node.type_ == node_types.NodeType.IMPLICIT:
            self.render_implicit(self.current_node)
        else:
            self.render_none()
            self.logger.warn("Rendered unknown node")

        self.has_view_changed = False
    else:
        self.logger.debug("No change, not rendering")
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb249}{249}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap278}\raggedright\small
\NWtarget{nuweb253a}{} $\langle\,${\itshape Render view render scene}\nobreak\ {\footnotesize {253a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
def render_scene(self, scene, camera, time):
    """Renders the given scene using the given camera at the given time.

    :param scene: TODO
    :type scene: TODO
    :param camera: TODO
    :type camera: TODO
    :param time: TODO
    :type time: TODO
    """

    assert(time >= 0.0)

    self.renderer.render_scene(scene, camera, None, time)
    # self.renderer.render_scene(scene, camera, self.render_target, time)
    # self.copy_render_target_to_screen()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb249}{249}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap279}\raggedright\small
\NWtarget{nuweb253b}{} $\langle\,${\itshape Render view handle node selection}\nobreak\ {\footnotesize {253b}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot(node_gui_domain.NodeViewModel)
def on_node_selected(self, node_view_model):
    """Slot that gets triggered whenever a node gets selected within the
    node graph view.

    :param node_view_model: view model of the selected node
    :type  node_view_model: qde.editor.gui_domain.node.NodeViewModel
    """

    self.logger.debug("Set selected node for rendering: %s" % node_view_model)

    # TODO: Check if node is valid
    self.current_node = node_view_model

    # TODO: Remove this and process time wise
    # This must get done in render_current_node
    self.has_view_changed = True
    self.update()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb249}{249}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap280}\raggedright\small
\NWtarget{nuweb254a}{} $\langle\,${\itshape Render view handle node deselection}\nobreak\ {\footnotesize {254a}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|QtCore.pyqtSlot()
def on_node_deselected(self):
    """Slot that gets triggered whenever a node gets deselected within the
    node graph view.
    """

    self.current_node = None

    # TODO: Remove this and process time wise
    # This must get done in render_current_node
    self.has_view_changed = True
    self.update()
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb249}{249}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap281}\raggedright\small
\NWtarget{nuweb254b}{} \verb@"../src/qde/editor/technical/render.py"@\nobreak\ {\footnotesize {254b}}$\equiv$
\vspace{-1ex}
\begin{pythoncode}
# -*- coding: utf-8 -*-

"""Module providing an abstraction layer for rendering."""

# System imports
from PyQt5 import QtCore
from PyQt5 import QtGui

# Project imports
from qde.editor.foundation import common
from qde.editor.foundation import flag
from qde.editor.foundation import type as types
from qde.editor.technical  import geometry
from qde.editor.technical  import graphics


|\hbox{$\langle\,${\itshape Renderer class}\nobreak\ {\footnotesize \NWlink{nuweb255}{255}}$\,\rangle$}|
|\hbox{$\langle\,${\itshape Ray marching renderer class}\nobreak\ {\footnotesize \NWlink{nuweb256}{256}}$\,\rangle$}|
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap282}\raggedright\small
\NWtarget{nuweb255}{} $\langle\,${\itshape Renderer class}\nobreak\ {\footnotesize {255}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
|\normalfont{}\fontfamily{}|common.with_logger
class Renderer(object):
    """Renderer base class."""

    def __init__(self, default_shader_name="default"):
        """Constructor.

        :param default_shader_name: name of the shader that gets used by default.
        :type  default_shader_name: str
        """

        gfx = graphics.Graphics.instance()
        flags = (flag.Geometry.DYNAMIC.value &
                 flag.Geometry.INDEX_BUFFER_32.value)
        self.default_geometry = gfx.add_geometry(flags, types.Vertex.SIMPLE,
                                                 types.GeometryPrimitive.QUAD_LIST)
        self.quad_geometry = gfx.add_geometry(flags, types.Vertex.SIMPLE,
                                              types.GeometryPrimitive.QUAD_LIST)

        # Set up shader(s)
        self.default_shader = gfx.add_shader(default_shader_name)
        color = QtGui.QColor(QtCore.Qt.black)
        gfx.set_clear_color(color)

    def render_scene(self, scene, camera, render_target, time):
        raise NotImplemented(
            "%s must be implemented in child class." % __name__
        )
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb254b}{254b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap283}\raggedright\small
\NWtarget{nuweb256}{} $\langle\,${\itshape Ray marching renderer class}\nobreak\ {\footnotesize {256}}$\,\rangle\equiv$
\vspace{-1ex}
\begin{pythoncode}
class RayMarchingRenderer(Renderer):
    """Provides a ray marching renderer using sphere tracing."""

    def __init__(self, opengl_context):
        """Constructor.

        :param opengl_context: a valid OpenGL context.
        :type  opengl_context: PyQt5.QtGui.QOpenGLContext
        """

        super(RayMarchingRenderer, self).__init__(
            "sphere_tracer"
        )
        self.ctx = opengl_context

    def render_scene(self, scene, camera, render_target, time):
        """Renders the given scene using the given camera for the given render
        target.

        :param scene: TODO
        :type  scene: TODO
        :param camera: TODO
        :type  camera: TODO
        :param render_target: TODO
        :type  render_target: TODO
        :param time: TODO
        :type  time: TODO
        """

        gfx = graphics.Graphics.instance()
        gfx.render_state.shader_object = self.default_shader

        v1 = geometry.Vertex()
        v1.position = QtGui.QVector3D(-1.0, -1.0,  0.0)
        v2 = geometry.Vertex()
        v2.position = QtGui.QVector3D( 1.0, -1.0,  0.0)
        v3 = geometry.Vertex()
        v3.position = QtGui.QVector3D(-1.0,  1.0,  0.0)
        v4 = geometry.Vertex()
        v4.position = QtGui.QVector3D( 1.0,  1.0,  0.0)
        # vertices = cluster.vertices
        # indices  = cluster.indices
        vertices = [v1, v2, v3, v4]
        indices = [0, 1, 2, 2, 1, 3]
        gfx.load_geometry(self.default_geometry, vertices, indices)
        gfx.render_geometry(self.default_geometry)
|\NWsep|
\end{pythoncode}
\vspace{1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb254b}{254b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\end{fullwidth}


% Bibliography
\printbibliography{}

\end{document}
