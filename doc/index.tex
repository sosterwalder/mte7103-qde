\newcommand{\NWtarget}[2]{\hypertarget{#1}{#2}}
\newcommand{\NWlink}[2]{\hyperlink{#1}{#2}}
\newcommand{\NWtxtMacroDefBy}{Fragment defined by}
\newcommand{\NWtxtMacroRefIn}{Fragment referenced in}
\newcommand{\NWtxtMacroNoRef}{Fragment never referenced}
\newcommand{\NWtxtDefBy}{Defined by}
\newcommand{\NWtxtRefIn}{Referenced in}
\newcommand{\NWtxtNoRef}{Not referenced}
\newcommand{\NWtxtFileDefBy}{File defined by}
\newcommand{\NWtxtIdentsUsed}{Uses:}
\newcommand{\NWtxtIdentsNotUsed}{Never used}
\newcommand{\NWtxtIdentsDefed}{Defines:}
\newcommand{\NWsep}{${\diamond}$}
\newcommand{\NWnotglobal}{(not defined globally)}
\newcommand{\NWuseHyperlinks}{}
% -*- mode: latex; coding: utf-8 -*-

\documentclass[
    a4paper,      % paper format
    10pt,         % fontsize
    %twoside,     % double-sided
    openright,    % begin new chapter on right side
    notitlepage,  % use no standard title page
    parskip=half, % set paragraph skip to half of a line
]{scrreprt}       % KOMA-script report
% ]{tufte-book}
%---------------------------------------------------------------------------
\raggedbottom{}
\KOMAoptions{cleardoublepage=plain} % Add header and footer on blank pages


% Load Standard Packages:
%---------------------------------------------------------------------------
\usepackage{scrpage2}                    % Control of page headers and footers in LaTeX,
\usepackage{scrhack}
\usepackage{marginnote}
                                         % needed for e.g. deftripstyle (to defined page styles)
\usepackage[english]{babel}              % English hyphenation
\usepackage[utf8]{inputenc}              % UTF-8 input encoding
\usepackage[T1]{fontenc}                 % hyphenation of words with ä,ö and ü
\usepackage{textcomp}                    % additional symbols
\usepackage{float}                       % floating objects
\usepackage{booktabs,tabularx}           % package for nicer tables
\newcommand{\ra}[1]{\renewcommand{\arraystretch}{#1}}
\usepackage{tocvsec2}                    % provides means of controlling the sectional numbering
\usepackage{pgfgantt}                    % Provides GANTT charts
\usepackage[owncaptions]{vhistory}       % Provides framework for creating history outline
\renewcommand{\vhhistoryname}{Versions}  % Rename version history to german name "Versionen"
\usepackage{csquotes}                    % Quotes
\usepackage{nameref}                     % Allows referencing of names
\usepackage{blindtext}                   % Dummy text
\usepackage{standalone}                  % Combine documents
%---------------------------------------------------------------------------

% Environments
% ---------------------------------------------------------------------------
\newenvironment{loggentry}[2]% date, heading
{\noindent\textbf{#1}\marginnote{#2}\\}

% Bibliography
%---------------------------------------------------------------------------
% \usepackage[
%     style=alphabetic,
%     backend=biber,
%     citestyle=authoryear
% ]{biblatex}
% \addbibresource{inc/static/bibliography.bib}
\usepackage[
    backend=biber,
    style=ieee,
    sortlocale=de_DE,
    natbib=true,
    url=false, 
    doi=true,
    eprint=false
]{biblatex}
% \bibliographystyle{IEEEtranS}
\addbibresource{inc/bibliography.bib}
\DefineBibliographyStrings{ngerman}{
    andothers = {{et\,al\adddot}},
}
%---------------------------------------------------------------------------

% Load Math Packages
%---------------------------------------------------------------------------
\usepackage{mathtools}                       % Provide equation and gather environments
\usepackage{amsthm}                          % Provide the possibility to define definitions
\theoremstyle{definition}                    % Add new theorem style
\newtheorem{definition}{Definition}[section] % Add new theorem
\usepackage{bm}                              % bold font in math mode
\usepackage{amssymb}                         % mathematical special characters, e.g. mathbb
\usepackage{exscale}                         % mathematical size corresponds to textsize
\usepackage{esvect}                          % Provides nicer vector display in math mode
%---------------------------------------------------------------------------

% Definition of fonts
%---------------------------------------------------------------------------
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{9} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{9}  % for normal
%---------------------------------------------------------------------------

% Definition of colors
%---------------------------------------------------------------------------
\RequirePackage{color}
\definecolor{linkblue}{rgb}{0,0,0.8}       % Standard
\definecolor{darkblue}{rgb}{0,0.08,0.45}   % Dark blue
\definecolor{bfhgrey}{rgb}{0.41,0.49,0.57} % BFH grey
\definecolor{linkcolor}{rgb}{0,0,0}
\colorlet{Black}{black}
\definecolor{keywords}{rgb}{255,0,0}
\definecolor{red}{rgb}{0.6,0,0}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{blue}{rgb}{0,0,0.5}
% Syntax colors
\definecolor{syntaxRed}{rgb}{0.6,0,0}
\definecolor{syntaxBlue}{rgb}{0,0,0.5}
\definecolor{syntaxComment}{rgb}{0,0.5,0}
% Background colors
\definecolor{syntaxBackground}{rgb}{0.95, 0.95, 0.95}

% Load listings package
% which provides source code formatting
%---------------------------------------------------------------------------
\usepackage{listings}
\lstdefinestyle{python}{%
    language=Python,
    basicstyle=\ttm\ttfamily\linespread{1.15},
    backgroundcolor = \color{syntaxBackground},
    % columns=fullflexible,
    commentstyle=\color{green},
    emphstyle=\ttb\color{red},
    escapechar=§,
    frame=tlbr,
    framesep=0.2cm,
    framerule=0pt,
    numbers=left,
    numbersep=5pt,                   % how far the line-numbers are from the code
    numberstyle=\tiny\color{gray}, % the style that is used for the line-numbers
    identifierstyle=\color{black},
    keywordstyle=\ttb\color{blue},
    otherkeywords={self, param},
    % procnamekeys={def,class},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    stringstyle=\color{syntaxComment},
    tab=\rightarrowfill,
    xleftmargin=0.7cm,
}
\lstset{style=python}
% Hyperref Package (Create links in a pdf)
%---------------------------------------------------------------------------
\usepackage{hyperref}
% \usepackage[
%     ngerman,bookmarks,plainpages=false,pdfpagelabels,
%     backref = {false},                                        % No index backreference
%     colorlinks = {true},                                      % Color links in a PDF
%     hypertexnames = {true},                                   % no failures "same page(i)"
%     bookmarksopen = {true},                                   % opens the bar on the left side
%     bookmarksopenlevel = {0},                                 % depth of opened bookmarks
%     pdftitle = {QDE --- A visual animation system},           % PDF-property
%     pdfauthor = {Sven Osterwalder},                           % PDF-property
%     pdfsubject = {QDE},                                       % PDF-property
%     linkcolor = {linkcolor},                                  % Color of Links
%     citecolor = {linkcolor},                                  % Color of Cite-Links
%     urlcolor = {linkcolor},                                   % Color of URLs
% ]{hyperref}

% Geometry package: Set up page dimension
%---------------------------------------------------------------------------
\usepackage[a4paper,
    left=25mm,
    right=25mm,
    top=27mm,
    headheight=20mm,
    headsep=10mm,
    textheight=242mm,
    footskip=15mm
]{geometry}

% Makeindex Package
%---------------------------------------------------------------------------
\usepackage{makeidx}
\makeindex

% Glossary Package
%---------------------------------------------------------------------------
\usepackage[nonumberlist,nomain]{glossaries}
% -*- coding: utf-8 -*-\makeglossaries{}

% Fancyrb package
%---------------------------------------------------------------------------
\usepackage{fancyvrb}
\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}
{fontsize=\footnotesize,
    frame=lines,  % top and bottom rule only
    framesep=2em, % separation between frame and text rulecolor=\color{Gray},
    label=\fbox{\color{Black}},
    labelposition=topline,
    % commandchars=\|\(\), % escape character and argument delimiters for
    % commands within the verbatim
    % commentchar=*        % comment character
}

% TODO notes package
%---------------------------------------------------------------------------
\usepackage[textwidth=65mm]{todonotes}

\begin{document}
\settocdepth{section}
\pagenumbering{roman}

% Title variables
%---------------------------------------------------------------------------
\providecommand{\titletext}{QDE --- A visual animation system.}
\providecommand{\subtitletext}{MTE7103}
\providecommand{\subsubtitletext}{Master-Thesis}

% Set up header and footer using page style
%---------------------------------------------------------------------------
\deftripstyle{newlayout}
  [0pt] % no header line
  [0pt] % no footer line
  {} % Header left
  {} % Header center
  {} % Header right
  {\color{bfhgrey} \footnotesize \titletext, Version \vhCurrentVersion,
      \vhCurrentDate} % Footer left
  {} % Footer center
  {\color{bfhgrey} \thepage} % Footer right

\deftripstyle{titlepageStyle}
  [0pt] % no header line
  [0pt] % no footer line
  {} % Header left
  {} % Header center
  {} % Header right
  {\color{bfhgrey}\fontsize{9pt}{10pt}\selectfont
    Berner Fachhochschule | Haute école spécialisée bernoise | Bern
    University of Applied Sciences} % Footer left
  {} % Footer center
  {} % Footer right


\pagestyle{newlayout}
% use "pagestyle" also on chapter starting pages
\renewcommand{\chapterpagestyle}{newlayout}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.  #1}{}}
\renewcommand*{\headfont}{\normalfont}
\renewcommand*{\footfont}{\normalfont}

% Title Page and Abstract
%---------------------------------------------------------------------------
\setcounter{page}{1}
% -*- mode: latex; coding: utf-8 -*-

\begin{titlepage}

    % BFH-Logo absolute placed at (28,12) on A4 and picture (16:9 or 15cm x 8.5cm)
    % Actually not a realy satisfactory solution but working.
    %---------------------------------------------------------------------------
    \setlength{\unitlength}{1mm}
    % \includegraphics[scale=1.0]{img/BFH_Logo_B}
    BFH Logo

    \begin{picture}(150,2)
        \put(0,0){\color{bfhgrey}\rule{150mm}{2mm}}
    \end{picture}

    \begin{figure}[H]
        \hspace*{0.25cm}
        % \includegraphics{img/logo.pdf}
        LOGO
    \end{figure}

    \begin{picture}(150,2)
        \put(0,0){\color{bfhgrey}\rule{150mm}{2mm}}
    \end{picture}

    \begin{flushleft}
        \fontsize{26pt}{28pt}\selectfont
        \textbf{\titletext} \\
        \vspace{3mm}
        \subtitletext{}\\
        \vspace{6mm}
        \fontsize{14pt}{16pt}\selectfont
        \textbf{\subsubtitletext} \\
        \vspace{3mm}

        \fontsize{10pt}{17pt}\selectfont
        \begin{tabbing}
        xxxxxxxxxxxxxxx   \= xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \kill
        Major:            \> Computer science                                         \\
        Author:           \> Sven Osterwalder\protect\footnotemark[1]{}         \\
        Advisor:          \> Prof.~Claude Fuhrer\protect\footnotemark[2]{} \\
        Expert:           \> Dr.~Eric Dubuis\protect\footnotemark[3]{} \\
        Date:             \> \vhCurrentDate{}\\
        Version:          \> \vhCurrentVersion\\
        \end{tabbing}
    \end{flushleft}
    \footnotetext[1]{sven.osterwalder@students.bfh.ch}
    \footnotetext[2]{claude.fuhrer@bfh.ch}
    \footnotetext[3]{eric.dubuis@comet.ch}

    \vfill
    % \includegraphics[height=\baselineskip]{img/by-sa}\\ \small{\sffamily{Licensed under the Creative Commons Attribution-ShareAlike 3.0 License}}
    by-sa

    \thispagestyle{titlepageStyle}

\end{titlepage}
% -*- mode: latex; coding: utf-8 -*-

% Versions:
% -----------------------------------------------

\chapter*{}
\label{chap:versions}

\begin{versionhistory}
    \vhEntry{0.1}{29.03.2017}{SO}{Initial creation of the documentation}
\end{versionhistory}
\listoftodos{}
\addcontentsline{toc}{chapter}{Abstract}
% -*- coding: utf-8 -*-

\chapter*{Abstract}
\label{chap:abstract}

\blindtext
% Table of contents
%---------------------------------------------------------------------------
\tableofcontents
\cleardoublepage{}

% Main part
%---------------------------------------------------------------------------
\pagenumbering{arabic}
% -*- mode: latex; coding: utf-8 -*-

\chapter{Introduction}
\label{chap:introduction}

\blindtext{}
\blindtext{}

\section{Purpose and situation}
\label{sec:purpose}

\subsection{Motivation}
\label{subsec:motivation}

\blindtext{}

\subsection{Objectives and limitations}
\label{subsec:objectives}

\blindtext{}

\subsection{Preliminary activities}
\label{subsec:preliminary}

\blindtext{}

\section{Related works}
\label{sec:related-works}

Preliminary to this thesis two project works were done: ``Volume
ray casting --- basics \& principles''~\cite{osterwalder_volume_2016}, which
describes the basics and principles of sphere tracing, a special form of ray
tracing, and ``QDE --- a visual animation system,
architecture''~\cite{osterwalder_qde_2016}, which established the ideas and
notions of an editor and a player component as well as the basis for a possible
software architecture for these components. The latter project work is presented
in detail in the chapter about the procedure, the former project work is
presented in the chapter about the implementation.

\section{Document structure}
\label{sec:document-structure}

This document is divided into N chapters, the first being this introduction. The
second chapter on \textit{administrative aspects} shows the planning of the
project, including the involved persons, deliverables and the phases and
milestones.

The administrative aspects are followed by a chapter on the \textit{procedure}.
The purpose of that chapter is to show the procedure concerning the execution of
this thesis. It introduces a concept called literate programming, which builds
the foundation for this thesis. Furthermore it establishes a framework for the
actual implementation, which is heavily based on the previous project work,
``QDE --- a visual animation system, architecture''~\cite{osterwalder_qde_2016}
and also includes standards and principles.

The following chapter on the \textit{implementation} shows how the
implementation of the editor and the player component as well as how the
rendering is done using a special form of ray tracing as described in ``Volume
ray casting --- basics \& principles''~\cite{osterwalder_volume_2016}. As the
editor component defines the whole data structure it builds the basis of the
thesis and can be seen as main part of the thesis. The player component re-uses
concepts established within the editor.

Given that literate programming is very complete and elaborated, as components
being developed using this procedure are completely derived from the
documentation, the actual implementation is found in the appendix as otherwise
this thesis would be simply too extensive.

The last chapter is \textit{discussion and conclusion} and discusses the
procedure as well as the implementation. Some further work on the editor and the
player components is proposed as well.

After the regular content follows the \textit{appendix}, containing the
requirements for building the before mentioned components, the actual source
code in form of literal programming as well as test cases for the components.% -*- mode: latex; coding: utf-8 -*-

\chapter{Administrative aspects}
\label{chap:administrative_aspects}

Some administrative aspects of this thesis are covered, while they are not
required for the understanding of the result.

The whole documentation uses the male form, whereby both genera are equally
meant.

\section{Involved persons}
\label{sec:involved_persons}

\begin{table}[h]
  \begin{tabularx}{\textwidth}{|l|l|X|}
    \textbf{Author}  & Sven Osterwalder\protect\footnotemark[1]{}     & \\
    \textbf{Advisor} & Prof.\ Claude Fuhrer\protect\footnotemark[2]{} & \textit{Supervises the student doing the thesis}\\
    \textbf{Expert}  & Dr.\ Eric Dubuis\protect\footnotemark[3]{}     & \textit{Provides expertise concerning the thesis's subject, monitors and grades the thesis}\\
  \end{tabularx}
  \caption{List of the involved persons.}
\end{table}
\footnotetext[1]{sven.osterwalder@students.bfh.ch}
\footnotetext[2]{claude.fuhrer@bfh.ch}
\footnotetext[3]{eric.dubuis@comet.ch}

\section{Deliverables}
\label{sec:deliverables}

\begin{itemize}
\item \textbf{Report} \\
  \blindtext{}
\item \textbf{Implementation} \\
  \blindtext{}
\end{itemize}

\section{Organization of work}
\label{sec:organization-of-work}

\subsection{Meetings}
\label{subsec:meetings}

Various meetings with the supervising professor, Mr. Claude Fuhrer, helped
reaching the defined goals and preventing erroneous directions of the thesis.
The supervisor supported the author of this thesis by providing suggestions
throughout the held meetings. The minutes of the meetings may be found under
<<Meeting minutes>>.

\subsection{Phases of the project and milestones}
\label{subsec:project-phases-milestones}

\begin{table}[h]
  \begin{tabularx}{\textwidth}{|X|X|r|}
    \hline{}
    \textbf{Phase}   & \textbf{Description} & \textbf{Week / 2017} \\
    \hline{}
    Start of the project & & 8 \\
    Definition of objectives and limitation & & 8-9 \\
    Documentation and development & & 8-30 \\
    Corrections & & 30-31 \\
    Preparation of the thesis' defense & & 31-32 \\
    \hline
  \end{tabularx}
  \caption{Phases of the project.}
\end{table}

\begin{table}[h]
  \begin{tabularx}{\textwidth}{|X|X|r|}
    \hline{}
    \textbf{Phase}   & \textbf{Description} & \textbf{End of week / 2017} \\
    \hline{}
    Project structure is set up & & 8 \\
    Mandatory project goals are reached & & 30 \\
    Hand-in of the thesis & & 31 \\
    Defense of the thesis & & 32 \\
    \hline
  \end{tabularx}
  \caption{Milestones of the project.}
\end{table}

\begin{figure}[H]
    \begin{ganttchart}[
        vgrid,
        x unit=0.5cm,
        bar/.append style={fill=bfhgrey!50},
    ]{1}{26}
        \gantttitle{2017}{26} \ganttnewline{}
        \gantttitlelist{7,...,32}{1} \ganttnewline{}
        \ganttbar{Start of the project}{1}{1} \ganttnewline{}
        \ganttmilestone{Project is set up}{1} \ganttnewline{}
        \ganttlinkedbar{Objectives and limitations}{2}{3} \ganttnewline{}
        \ganttlinkedbar{Documentation}{3}{23} \ganttnewline{}
        \ganttbar{Development}{3}{23} \ganttnewline{}
        \ganttmilestone{Goals reached}{23} \ganttnewline{}
        \ganttlinkedbar{Corrections}{23}{24} \ganttnewline{}
        \ganttmilestone{Hand-in}{24} \ganttnewline{}
        \ganttlinkedbar{Thesis' defense preparation}{25}{26} \ganttnewline{}
        \ganttmilestone{Thesis defense}{26}
    \end{ganttchart}
    \caption{Schedule of the project by calendar weeks, including milestones.}\label{fig:timeschedule}
\end{figure}% -*- mode: latex; coding: utf-8 -*-

\chapter{Procedure}
\label{chap:procedure}

\subsection{Literate programming}
\label{subsec:literate-programming}

This thesis' implementation is done by a procedure named ``literate
programming'', invented by Donald Knuth. What this means, is that the
documentation as well as the code for the resulting program reside in the same
file. The documentation is then /weaved/ into a separate document, which may be
any by the editor support format. The code of the program is /tangled/ into a
run-able computer program.~\todo[inline]{Provide more information about literate
programming. Citations, explain fragments, explain referencing fragments, code
structure does not have to be ``normal''}

Originally it was planned to develop this thesis' application test driven,
providing (unit-) test-cases first and implementing the functionality
afterwards. Initial trails showed quickly that this method, in company with
literate programming, would exaggerate the effort needed. Therefore conventional
testing is used. Test are developed after implementing functionality and run
separately. A coverage as high as possible is intended. Test cases are /tangled/
too, and may be found in the appendix.\todo[inline]{Insert reference/link to test cases here.}

\section{Standards and principles}
\label{sec:standards-principles}

\subsection{Requirements}
\label{subsec:requirements}

The requirements are defined by the preceding project work,~\enquote{QDE --- a
  visual animation system, software architecture}~\citep[p. 8
ff.]{osterwalder_qde_2016}, and are still valid.

For the editor application however, Python is used as a programming language.
This decision is made as the author of the thesis has several years of
experience concerning Python and as the performance of the editor is not
a critical factor. By performance all aspects are concerned, e.g. the evaluation
of the node graph or rendering itself.

As Python provides no direct bindings to Qt, an additional library is needed,
which provides those bindings. Currently there exist two Python bindings for Qt:
PySide and PyQt. As Qt version 5 is used, the bindings need to provide access to
version 5 too. Currently this is only achieved by PyQt5 in a stable and complete
way. PySide2 supports Qt version 5 too, is although under heavy development and
far from being complete and stable.

Therefore PyQt5 is an additional requirement.

\subsection{Code}
\label{subsec:code}

\begin{itemize}
\item Classes use camel case.
\item Folders / name-spaces use only small letters.
\item Methods are all small caps and use underscores as spaces.
\item Signals: do\_something
\item Slots: on\_something
\item Importing: {{{verb(from Foo import Bar)}}}\\
      As the naming of the PyQt5 modules prefixes them by /Qt/, it is very
      unlikely to have naming conflicts with other modules. Therefore the import
      format {{{verb(from PyQt5 import [QtModuleName])}}} is used. This still
      provides a (relatively) unique naming most probably without any conflicts
      but reduces the effort when writing a bit. The import of system modules is
      therefore as follows.
\end{itemize}

\subsubsection{Layering}
\label{ssubsec:layering}

Concerning the architecture, a layered architecture is foreseen, as stated in
\cite[p. 38 ff.]{osterwalder_qde_2016}. A relaxed layered architecture leads to
low coupling, reduces dependencies and enhances cohesion as well as clarity.

As the architecture's core \todo{Link to components} components are all graphical, a graphical user
interface for those components is developed. As the their data shall be
exportable, it would be relatively tedious if the graphical user interface would
hold and control that data. Instead models and model-view separation are used.
Additionally controllers are introduced which act as workflow objects of the
=application= layer and interfere between the model and its view.

\subsubsection{Model-View-Controller}
\label{ssubsec:mvc}

While models may be instantiated anywhere directly, this would although not
contribute to having clean code and sane data structures. Instead controllers,
lying within the {{{verb(application)}}} layer, will manage instances of models.
The instantiating may either be induced by the graphical user interface
or by the player when loading and playing exported animations.

A view may never contain model-data (coming from the {{{verb(domain)}}} layer)
directly, instead view models are used \cite{martin_fowler_presentation_2004}.

The behavior described above corresponds to the well-known model-view-controller
pattern expanded by view models.

As Qt is used as the core for the editor, it may be quite obvious to use Qt's
model/view programming practices, as described by
[fn:20:http://doc.qt.io/qt-5/model-view-programming.html]. However, Qt combines
the controller and the view, meaning the view acts also as a controller while
still separating the storage of data. The editor application does not actually
store data (in a conventional way, e.g. using a database) but solely exports it.
Due to this circumstance the model-view-controller pattern is explicitly used,
as also stated in \cite[p. 38]{osterwalder_qde_2016}.

\todo[inline]{Describe the exact process of communication between ViewModel,
Controller and Model.}

To avoid coupling and therefore dependencies, signals and
slots[fn:16:http://doc.qt.io/qt-5/signalsandslots.html] are used in terms of the
observer pattern to allow inter-object and inter-layer communication.% -*- mode: latex; coding: utf-8 -*-

\chapter{Implementation}
\label{chap:implementation}

% -*- mode: latex; coding: utf-8 -*-

\section{Editor}
\label{sec:editor}

% -*- mode: latex; coding: utf-8 -*-

\section{Player}
\label{sec:player}

% -*- mode: latex; coding: utf-8 -*-

\section{Rendering}
\label{sec:rendering}

% Glossary
%---------------------------------------------------------------------------
\cleardoublepage{}
\phantomsection{}
\addcontentsline{toc}{chapter}{Glossary}
\glsaddall{}
\printglossaries{}

% Bibliography
%---------------------------------------------------------------------------
\cleardoublepage{}
\phantomsection{}
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography{}

% Listings
%---------------------------------------------------------------------------
%\cleardoublepage
\phantomsection{}
\addcontentsline{toc}{chapter}{List of figures}
\listoffigures
%\cleardoublepage
\phantomsection{}
\addcontentsline{toc}{chapter}{List of tables}
\listoftables
%\cleardoublepage
\phantomsection{}
\addcontentsline{toc}{chapter}{List of listings}
\lstlistoflistings{}

% Index
%---------------------------------------------------------------------------
%\cleardoublepage
%\phantomsection{}
%\addcontentsline{toc}{chapter}{Stichwortverzeichnis}
%\renewcommand{\indexname}{Stichwortverzeichnis}
%\printindex

% Appendix
%---------------------------------------------------------------------------
% -*- mode: latex; coding: utf-8 -*-

\chapter{Appendix}
\label{chap:appendix}

% -*- mode: latex; coding: utf-8 -*-

\section{Implementation}
\label{sec:appendix-implementation}

To start the implementation of a project, it is necessary to first think about the
goal that one wants to reach and about some basic structures and guidelines
which lead to the fulfillment of that goal.

The main goal is to have a visual animation system, which allows the creation
and rendering of visually appealing scenes, using a graphical user interface for
creation, and a ray tracing based algorithm for rendering.

The thoughts to reach this goal were already developed
in~\autoref{chap:procedure}, \enquote{\nameref{chap:procedure}}, and will
therefore not be repeated again.

As stated in~\autoref{chap:procedure}, literate programming is used to implement
the components. To maintain readability only relevant code fragments are shown
in place. The whole code fragments, which are needed for tangling, are found
at~\autoref{sec:code-fragments}.

First, the implementation of the editor component is described, as it is the
basis for the whole project and also contains many concepts, that are re-used by
the player component. Before starting with the implementation it is necessary to
define requirements and some kind of framework for the implementation.

\subsection{Requirements}
\label{subsec:appendix-requirements}

At the current point of time, the requirements for running the components are
the following:

\begin{itemize}
\item A Unix derivative as operating system (Linux, macOS).
\item Python~\footnote{\url{http://www.python.org}} version 3.5.x or above
\item PyQt5~\footnote{\url{https://riverbankcomputing.com/software/pyqt/intro}}
      version 5.7 or above
\end{itemize}
\todo[inline]{Add more requirements? E.g. OpenGL?}

\subsection{Name spaces and project structure}
\label{subsec:appendix-name-spaces}

To give the whole project a structure and for being able to stick to the
thoughts established in~\autoref{chap:procedure}, it may be wise to structure
the project in analogous way as defined in~\autoref{chap:procedure}.

Therefore the whole source code shall be placed in the \textit{src} directory
underneath the main directory. The creation of the single directories is not
explicitly shown, it is done by parts of this documentation which are tangled
but not exported.

When dealing with directories and files, Python uses the term \textit{package} for
(sub-) directories and \textit{module} for files within
directories.\footnote{https://docs.python.org/3/reference/import.html\#packages}

To prevent having multiple modules having the same name, name spaces are
used.\footnote{https://docs.python.org/3/tutorial/classes.html\#python-scopes-and-namespaces}
The main name space shall be analogous to the project's name: \textit{qde}. Underneath
the source code folder \textit{src}, each sub-folder represents a package and acts
therefore also as a name space.

To actually allow a whole package and its modules being imported \textit{as modules},
it needs to have at least a file inside, called~\textit{\_\_init\_\_.py}. Those files may be
empty or they may contain regular source code such as classes or methods.

\subsection{Coding style}
\label{subsec:appendix-implementation-coding-style}

To stay consistent throughout the implementation of components, a coding style
is applied which is defined as follows.

\begin{itemize}
\item Classes use camel case, e.g. \verb+class SomeClassName+.
\item Folders respectively name spaces use only small letters, e.g.
  \textit{foo.bar.baz}.
\item Methods are all small caps and use underscores as spaces, e.g. \verb+some_method_name+.
\item Signals are methods, which are prefixed by the word \enquote{do}, e.g. \verb+do_something+.
\item Slots are methods, which are prefixed by the word \enquote{on}, e.g. \verb+on_something+.
\item Importing is done by the \verb+from Foo import Bar+ syntax, whereas
  \verb+Foo+ is a module and \verb+Bar+ is either a module, a class or a method.
\end{itemize}

\subsubsection{Importing of modules}
\label{ssubsec:appendix-implementation-coding-style-imports}

As mentioned at~\autoref{subsec:appendix-requirements}, Python is used. Python
has~\enquote{batteries included}, which means that it offers a lot of
functionality through various modules, which have to be imported first before
using them. The same applies of course for self written modules.

Python offers multiple possibilities concerning imports, for details
see~\url{https://docs.python.org/3/tutorial/modules.html}.
\todo[inline]{Is direct url reference ok or does this need to be citation?}

However, PEP number 8 recommends to either import modules directly or to import
the needed functionality
directly.~\footnote{\url{https://www.python.org/dev/peps/pep-0020/}}. As defined
by the coding style,~\autoref{subsec:appendix-implementation-coding-style},
imports are done by the \verb+from Foo import Bar+ syntax.

The imported modules are always split up: first the system modules are imported,
modules which are provided by Python itself or by external libraries, then
project-related modules are imported.

\subsubsection{Framework for implementation}
\label{ssubsec:appendix-implementation-framework}

For also staying consistent when implementing classes and methods, it make sense
to define a rough framework for implementation, which is as follows:

\begin{itemize}
\item Define necessary signals.
\item Within the constructor,
  \begin{itemize}
    \item Set up the user interface when it is a class concerning the graphical user interface.
    \item Set up class-specific aspects, such as the name, the tile or an icon.
    \item Set up other components, used by that class.
    \item Initialize the connections, meaning hooking up the defined signals with
      corresponding methods.
  \end{itemize}
\item Implement the remaining functionality in terms of methods and slots.
\end{itemize}

Now, having defined the requirements, a project structure, a coding style and a
framework for the actual implementation, the implementation of the editor may
begin.

%-*- mode: latex; coding: utf-8 -*-

\subsection{Editor}
\label{subsec:editor}

Before diving right into the implementation of the editor, it may be good to
reconsider what shall actually be implemented, therefore what the main
functionality of the editor is and what its components are.

The quintessence of the editor application is to output a structure, be it in
the JSON format or even in bytecode, which defines an animation.

An animation is simply a composition of scenes which run in a sequential order
within a time span. A scene is then a composition of nodes, which are at the end
of their evaluation nothing else as shader specific code which gets executed on
the GPU.

As this definition is rather abstract, it may be easier to define what shall be
achieved in terms of content and then work towards this definition.

A very basic definition of what shall be achieved is the following.

It shall be possible to create an animated scene using the editor application.
The scene shall be composed of two objects, a sphere and a cube. Additionally it
shall have a camera as well as a point light.

The camera shall be placed 5 units in height and 10 units in front of the center
of the scene. The cube shall be placed in the middle of the scene, the sphere
shall have an offset of 5 units to the right and 2 units in depth. The point
light shall be placed 10 units above the center.

Both objects shall have different materials: the cube shall have a dull surface
of any color whereas the sphere shall have a glossy surface of any color.

There shall be an animation of ten seconds duration. During this animation the
sphere shall move towards the cube and they shall merge into a blob-like object.
The camera shall move 5 units towards the two objects during this time.

\todo[inline]{Scene: Composition of nodes. Define scene already here.}

To achieve this overall goal while providing the user a user-friendly
experience, several components are needed. These are the following, being
defined in~\citetitle[pp. 29 ff.]{osterwalder_qde_2016}

\begin{itemize}
\item A scene graph, allowing the creation and deletion of scenes. The scene graph
      has at least a root scene.
\item A node-based graph structure, allowing the composition of scenes using nodes
      and connections between the nodes. There exists at least a root node at
      the root scene of the scene graph.
\item A parameter window, showing parameters of the currently selected graph node.
\item A rendering window, rendering the currently selected node or scene.
\item A sequencer, allowing a time-based scheduling of defined scenes.
\end{itemize}

However, the above list is not complete. It is somehow intuitively clear, that
there needs to be some main component, which holds all the mentioned components
and allows a proper handling of the application (like managing resources,
shutting down properly and so on).

As the whole architecture uses layers and the MVC principle
(see~\autoref{ssubsec:layering} and~\autoref{ssubsec:mvc}), the main component is
composed of a view and a controller. A model is (at least at this point) not
necessary. The view component shall be called~\textit{main window} and its
controller shall be called~\textit{main application}.

\todo[inline]{Fix references to subsection (they are displaying section atm)}

\subsubsection{Main entry point}
\label{ssubsec:main-entry-point}

Before implementing any of these components, the editor application needs an
entry point, that is a point where the application starts when being called.

Python does this by evaluating a special variable within a module,
called~\verb+__name__+. Its value is set to \verb+'__main__'+ if the module
is~\enquote{read from standard input, a script, or from an interactive
prompt.}~\footnote{\url{https://docs.python.org/3/library/__main__.html}}

All that the entry point needs to do in case of the editor application, is
spawning the editor application, execute it and exit again, as can be seen below.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap1}\raggedright\small
\NWtarget{nuweb14}{} $\langle\,${\itshape Main entry point}\nobreak\ {\footnotesize {14}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@if __name__ == "__main__":@\\
\mbox{}\lstinline@    app = application.Application(sys.argv)@\\
\mbox{}\lstinline@    status = app.exec()@\\
\mbox{}\lstinline@    sys.exit(status)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb87a}{87a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
But where to place this entry point? A very direct approach would be to
implement that main entry point within the main application controller. But when
running the editor application by calling it from the command line, calling a
controller directly may rather be confusing. Instead it is more intuitive to
have only a minimal entry point which is clearly visible as such. Therefore the
main entry point will be put in a file called \textit{editor.py} which is at the
top level of the \textit{src} directory.

\subsubsection{Main application}
\label{ssubsec:main-application}

Although a main entry point is defined by now, the editor application cannot be
started as there is no such thing as an editor application yet. Therefore a main
application needs to be implemented.

As stated in the requirements, see~\autoref{subsec:requirements}, Qt version 5
is used through the PyQt5 wrapper. Therefore all functionality of Qt 5 may be
used. Qt already offers a main application class, which can be used as a
controller. The class is called~\verb+QApplication+.

But what does such a main application class actually do? What is its
functionality? Very roughly sketched, such a type of application initializes
resources, enters a main loop, where it stays until told to shut down, and at
the end it frees the allocated resources again.

Due to the usage of \verb+QApplication+ as super class it is not necessary to
implement a main (event-) loop, as such is provided by Qt
itself~\footnote{http://doc.qt.io/Qt-5/qapplication.html\#exec}.

As the main application initializes resources, it act as central node between the
various layers of the architecture, initializing them and connecting them using
signals.\cite[pp. 37 --- 38]{osterwalder_qde_2016}

Therefore it needs to do at least three things: initialize itself, set up
components and connect components. This all happens when the main application is
being initialized.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap2}\raggedright\small
\NWtarget{nuweb15a}{} $\langle\,${\itshape Main application declarations}\nobreak\ {\footnotesize {15a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@class Application(QtWidgets.QApplication):@\\
\mbox{}\lstinline@    """Main application for QDE."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Main application constructor}\nobreak\ {\footnotesize \NWlink{nuweb15b}{15b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Main application methods}\nobreak\ {\footnotesize \NWlink{nuweb38a}{38a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb87b}{87b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap3}\raggedright\small
\NWtarget{nuweb15b}{} $\langle\,${\itshape Main application constructor}\nobreak\ {\footnotesize {15b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, arguments):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param arguments: a (variable) list of arguments, that are@\\
\mbox{}\lstinline@                      passed when calling this class.@\\
\mbox{}\lstinline@    :type  argv:      list@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Set up internals for main application}\nobreak\ {\footnotesize \NWlink{nuweb15c}{15c}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Set up components for main application}\nobreak\ {\footnotesize \NWlink{nuweb17b}{17b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Add root node for main application}\nobreak\ {\footnotesize \NWlink{nuweb23c}{23c}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Set model for scene graph view}\nobreak\ {\footnotesize \NWlink{nuweb30b}{30b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    self.main_window.show()@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb15a}{15a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Setting up the internals is straight forward: Passing any given arguments
directly to~\verb+QApplication+, setting an application icon, a name as well as
a display name.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap4}\raggedright\small
\NWtarget{nuweb15c}{} $\langle\,${\itshape Set up internals for main application}\nobreak\ {\footnotesize {15c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@super(Application, self).__init__(arguments)@\\
\mbox{}\lstinline@self.setWindowIcon(QtGui.QIcon("assets/icons/im.png"))@\\
\mbox{}\lstinline@self.setApplicationName("QDE")@\\
\mbox{}\lstinline@self.setApplicationDisplayName("QDE")@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb15c}{15c}\NWlink{nuweb38b}{, 38b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb15b}{15b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The other two steps, setting up the components and connecting them can however
not be done at this point, as there simply are no components available. A
component to start with is the view component of the main application, the main
window.

\subsubsection{Main window}
\label{ssubsec:main-window}

Having a very basic implementation of the main application, its view component,
the main window, can now be implemented and then be set up by the main
application.

The main functionality of the main window is to set up the actual user
interface, containing all the views of the components. Qt offers the class
\verb+QMainWindow+ from which \verb=MainWindow= may inherit.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap5}\raggedright\small
\NWtarget{nuweb16a}{} $\langle\,${\itshape Main window declarations}\nobreak\ {\footnotesize {16a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@class MainWindow(QtWidgets.QMainWindow):@\\
\mbox{}\lstinline@    """The main window class.@\\
\mbox{}\lstinline@    Acts as main view for the QDE editor application.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Main window signals}\nobreak\ {\footnotesize \NWlink{nuweb16b}{16b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Main window methods}\nobreak\ {\footnotesize \NWlink{nuweb17a}{17a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb88a}{88a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% 

For being able to shut down the main application and therefore the main window,
they need to react to a request for shutting down, either by a keyboard shortcut
or a menu command. However, the main window is not able to force the main
application to quit by itself. It would be possible to pass the main window a
reference to the application, but that would lead to tight coupling and is
therefore not considered as an option. Signals and slots allow exactly such
cross-layer communication without coupling components tightly.

To avoid tight coupling a signal within the main window is introduced, which
tells the main application to shut down. A fitting name for the signal might be
\verb=do_close=.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap6}\raggedright\small
\NWtarget{nuweb16b}{} $\langle\,${\itshape Main window signals}\nobreak\ {\footnotesize {16b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@do_close = QtCore.pyqtSignal()@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb16a}{16a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Now, that the signal for closing the window and the application is defined, two
additional things need to be considered: The emission of the signal by
the main window itself as well as the consumption of the signal by a slot of
other classes.

The signal shall be emitted when the escape key on the keyboard is pressed or
when the corresponding menu item was selected. As there is no menu at the
moment, only the key pressed event is implemented by now.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap7}\raggedright\small
\NWtarget{nuweb17a}{} $\langle\,${\itshape Main window methods}\nobreak\ {\footnotesize {17a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, parent=None):@\\
\mbox{}\lstinline@    """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    super(MainWindow, self).__init__(parent)@\\
\mbox{}\lstinline@    self.setup_ui()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def keyPressEvent(self, event):@\\
\mbox{}\lstinline@    """Gets triggered when a key press event is raised.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param event: holds the triggered event.@\\
\mbox{}\lstinline@    :type  event: QKeyEvent@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if event.key() == QtCore.Qt.Key_Escape:@\\
\mbox{}\lstinline@        self.do_close.emit()@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        super(MainWindow, self).keyPressEvent(event)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb17a}{17a}\NWlink{nuweb19}{, 19}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb16a}{16a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% For emitting the signal when selecting a menu entry, an action needs to be
% defined which is then attached to the menu entry. The action emits a signal as
% soon as the menu entry was clicked. It is however not possible to trigger the
% defined \verb+do_close+ signal using the actions signal. There a slot needs to
% be defined which then in its turn triggers \verb+do_close+.

The main window can now be set up by the main application controller, which also
listens to the \verb=do_close= signal through the inherited \verb=quit= slot.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap8}\raggedright\small
\NWtarget{nuweb17b}{} $\langle\,${\itshape Set up components for main application}\nobreak\ {\footnotesize {17b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Set up controllers for main application}\nobreak\ {\footnotesize \NWlink{nuweb29b}{29b}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Connect controllers for main application}\nobreak\ {\footnotesize \NWlink{nuweb52a}{52a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Set up main window for main application}\nobreak\ {\footnotesize \NWlink{nuweb17c}{17c}}$\,\rangle$}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb15b}{15b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap9}\raggedright\small
\NWtarget{nuweb17c}{} $\langle\,${\itshape Set up main window for main application}\nobreak\ {\footnotesize {17c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.main_window = qde_main_window.MainWindow()@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize \NWlink{nuweb17d}{17d}, \ldots\ }$\,\rangle$}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb17b}{17b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap10}\raggedright\small
\NWtarget{nuweb17d}{} $\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize {17d}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.main_window.do_close.connect(self.quit)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb17d}{17d}\NWlink{nuweb37a}{, 37a}\NWlink{nuweb56b}{, 56b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb17c}{17c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The used view component for the main window, \verb+QMainWindow+, needs at least
a central widget with a layout for being
rendered.~\footnote{http://doc.qt.io/qt-5/qmainwindow.html\#creating-main-window-components}

As the main window will set up and hold the whole layout for the application
through multiple view components, a method \verb+setup_ui+ is introduced, which
sets up the whole layout. The method creates a central widget containing a grid
layout.

As the main window holds all other view components and a look as proposed
in~\citetitle[p. 9]{osterwalder_qde_2016} is targeted, a simple grid layout does
not provide enough possibilities. Instead a horizontal box layout in combination
with splitters is used.

Recalling the components, the following layout is approached:

\begin{itemize}
\item{%
    A scene graph, on the left of the window, covering the whole height.}
\item{%
    A node graph on the right of the scene graph, covering as much height as
    possible.}
\item{%
    A view for showing the properties (and therefore parameters) of the selected
    node on the right of the node graph, covering as much height as possible.}
\item{%
    A display for rendering the selected node, on the right of the properties
    view, covering as much height as possible}
\item{%
    A sequencer at the right of the scene graph and below the other components
    at the bottom of the window, covering as much width as possible}
\end{itemize}

\todo[inline]{Provide a picture of the layout here.}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap11}\raggedright\small
\NWtarget{nuweb19}{} $\langle\,${\itshape Main window methods}\nobreak\ {\footnotesize {19}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def setup_ui(self):@\\
\mbox{}\lstinline@    """Sets up the user interface specific components."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.setObjectName('MainWindow')@\\
\mbox{}\lstinline@    self.setWindowTitle('QDE')@\\
\mbox{}\lstinline@    self.resize(1024, 768)@\\
\mbox{}\lstinline@    self.move(100, 100)@\\
\mbox{}\lstinline@    # Ensure that the window is not hidden behind other windows@\\
\mbox{}\lstinline@    self.activateWindow()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    central_widget = QtWidgets.QWidget(self)@\\
\mbox{}\lstinline@    central_widget.setObjectName('central_widget')@\\
\mbox{}\lstinline@    grid_layout = QtWidgets.QGridLayout(central_widget)@\\
\mbox{}\lstinline@    central_widget.setLayout(grid_layout)@\\
\mbox{}\lstinline@    self.setCentralWidget(central_widget)@\\
\mbox{}\lstinline@    self.statusBar().showMessage('Ready.')@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    horizontal_layout_widget = QtWidgets.QWidget(central_widget)@\\
\mbox{}\lstinline@    horizontal_layout_widget.setObjectName('horizontal_layout_widget')@\\
\mbox{}\lstinline@    horizontal_layout_widget.setGeometry(QtCore.QRect(12, 12, 781, 541))@\\
\mbox{}\lstinline@    horizontal_layout_widget.setSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding,@\\
\mbox{}\lstinline@    QtWidgets.QSizePolicy.MinimumExpanding)@\\
\mbox{}\lstinline@    grid_layout.addWidget(horizontal_layout_widget, 0, 0)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    horizontal_layout = QtWidgets.QHBoxLayout(horizontal_layout_widget)@\\
\mbox{}\lstinline@    horizontal_layout.setObjectName('horizontal_layout')@\\
\mbox{}\lstinline@    horizontal_layout.setContentsMargins(0, 0, 0, 0)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.scene_graph_view = guiscene.SceneGraphView()@\\
\mbox{}\lstinline@    self.scene_graph_view.setObjectName('scene_graph_view')@\\
\mbox{}\lstinline@    self.scene_graph_view.setMaximumWidth(300)@\\
\mbox{}\lstinline@    horizontal_layout.addWidget(self.scene_graph_view)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Set up scene view in main window}\nobreak\ {\footnotesize \NWlink{nuweb51b}{51b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Set up parameter view in main window}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Set up render view in main window}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    horizontal_splitter = QtWidgets.QSplitter()@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Add render view to horizontal splitter in main window}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Add parameter view to horizontal splitter in main window}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    vertical_splitter = QtWidgets.QSplitter()@\\
\mbox{}\lstinline@    vertical_splitter.setOrientation(QtCore.Qt.Vertical)@\\
\mbox{}\lstinline@    vertical_splitter.addWidget(horizontal_splitter)@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Add scene view to vertical splitter in main window}\nobreak\ {\footnotesize \NWlink{nuweb51c}{51c}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    horizontal_layout.addWidget(vertical_splitter)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb17a}{17a}\NWlink{nuweb19}{, 19}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb16a}{16a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
All the above taken actions to lay out the main window change nothing in the
window's yet plain appearance. This is quite obvious, as none of the actual
components are implemented yet.

The most straight-forward component to implement may be scene graph, so this is
a good starting point for the implementation of the remaining components.

\subsubsection{Scene graph}
\label{ssubsec:scene-graph}

As mentioned in~\autoref{subsec:editor}, the scene graph has also two aspects to
consider: a graphical aspect as well as its data structure.

\todo[inline]{Define what a scene is by prose and code.}

As described in~\autoref{chap:procedure}, two kinds of models are used. A domain
model, containing the actual data and a view model, which holds a reference to
its corresponding domain model.

% \todo[inline]{Check whether to move into procedure.}
% Both models are managed by the same controller. View models are displayed by views,
% e.g. node view models in the node graph view.
% 
% Therefore the controller of the scene graph will manage instances of scene
% domain models whereas the view of the scene graph will display a tree of scene
% view models.

As the domain model builds the basis for the whole (data-) structure, it is
implemented first.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap12}\raggedright\small
\NWtarget{nuweb20a}{} $\langle\,${\itshape Scene model declarations}\nobreak\ {\footnotesize {20a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class SceneModel(object):@\\
\mbox{}\lstinline@    """The scene model.@\\
\mbox{}\lstinline@    It is used as a base class for scene instances within the whole system.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene model methods}\nobreak\ {\footnotesize \NWlink{nuweb20b}{20b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene model slots}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb88b}{88b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
At this point the only known fact is, that a scene is a composition of nodes,
and therefore it holds its nodes as a list. Additionally it holds a reference to
its parent.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap13}\raggedright\small
\NWtarget{nuweb20b}{} $\langle\,${\itshape Scene model methods}\nobreak\ {\footnotesize {20b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, parent=None):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param parent: the parent scene of this scene. The parent is None if the@\\
\mbox{}\lstinline@                   current scene is the root scene.@\\
\mbox{}\lstinline@    :type parent: SceneModel@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.id_ = uuid.uuid4()@\\
\mbox{}\lstinline@    self.nodes = []@\\
\mbox{}\lstinline@    self.parent = parent@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb20a}{20a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The counter part of the domain model is the view model. View models are used to
visually represent something within the graphical user interface and they
provide an interface to the \verb+domain+ layer. To this point, a simple
reference in terms of an attribute is used as interface, which may be changed
later on.

Concerning the user interface, a view model must fulfill the requirements posed
by the user interface's corresponding component. In this case, this are actually
two components: the scene graph view as well as the scene view.

It would therefore make sense the use one view model for both components, but
this is not possible as the view model of the scene view, \verb+QGraphicsScene+,
uses its own data model.

Therefore \verb+QObject+ will be used for the scene graph view model and
\verb+QGraphicsScene+ will be used for the scene view model.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap14}\raggedright\small
\NWtarget{nuweb21a}{} $\langle\,${\itshape Scene graph view model declarations}\nobreak\ {\footnotesize {21a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class SceneGraphViewModel(Qt.QObject):@\\
\mbox{}\lstinline@    """View model representing scene graph items.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    The SceneGraphViewModel corresponds to an entry within the scene graph. It is@\\
\mbox{}\lstinline@    used by the QAbstractItemModel class and must therefore at least provide a@\\
\mbox{}\lstinline@    name and a row.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph view model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph view model constructor}\nobreak\ {\footnotesize \NWlink{nuweb21b}{21b}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph view model methods}\nobreak\ {\footnotesize \NWlink{nuweb29a}{29a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph view model slots}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb88c}{88c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
In terms of the scene graph, the view model must provide at least a name and a
row. In addition, as written above, it holds a reference to the domain model.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap15}\raggedright\small
\NWtarget{nuweb21b}{} $\langle\,${\itshape Scene graph view model constructor}\nobreak\ {\footnotesize {21b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(@\\
\mbox{}\lstinline@        self,@\\
\mbox{}\lstinline@        row,@\\
\mbox{}\lstinline@        domain_object,@\\
\mbox{}\lstinline@        name=QtCore.QCoreApplication.translate('SceneGraphViewModel', 'New scene'),@\\
\mbox{}\lstinline@        parent=None@\\
\mbox{}\lstinline@):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param row:           The row the view model is in.@\\
\mbox{}\lstinline@    :type  row:           int@\\
\mbox{}\lstinline@    :param domain_object: Reference to a scene model.@\\
\mbox{}\lstinline@    :type  domain_object: qde.editor.domain.scene.SceneModel@\\
\mbox{}\lstinline@    :param name:          The name of the view model, which will be displayed in@\\
\mbox{}\lstinline@                          the scene graph.@\\
\mbox{}\lstinline@    :type  name:          str@\\
\mbox{}\lstinline@    :param parent:        The parent of the current view model within the scene@\\
\mbox{}\lstinline@                          graph.@\\
\mbox{}\lstinline@    :type parent:         qde.editor.gui_domain.scene.SceneGraphViewModel@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    super(SceneGraphViewModel, self).__init__(parent)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.id_ = domain_object.id_@\\
\mbox{}\lstinline@    self.row  = row@\\
\mbox{}\lstinline@    self.domain_object = domain_object@\\
\mbox{}\lstinline@    self.name = name@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb21b}{21b}\NWlink{nuweb28b}{, 28b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Scenes may now be instantiated, it is although necessary to manage scenes in a
controlled manner. Therefore the class \verb+SceneGraphController+ will now be
implemented, for being able to manage scenes.

As the scene graph shall be built as a tree structure, an appropriate data
structure is needed. Qt provides the \verb+QTreeWidget+ class, but that
class is in this case not suitable, as it does not separate the data from its
representation, as stated by Qt:~\enquote{Developers who do not need the flexibility of
the Model/View framework can use this class to create simple hierarchical lists
very easily. A more flexible approach involves combining a QTreeView with a
standard item model. This allows the storage of data to be separated from its
representation.}\footnote{http://doc.qt.io/qt-5/qtreewidget.html\#details}

Such a standard item model is
\verb+QAbstractItemModel+\footnote{\label{footnote:qabstractitemmodel}
http://doc.qt.io/qt-5/qabstractitemmodel.html}, which is used as a base class
for the scene graph controller.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap16}\raggedright\small
\NWtarget{nuweb22a}{} $\langle\,${\itshape Scene graph controller declarations}\nobreak\ {\footnotesize {22a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@class SceneGraphController(QtCore.QAbstractItemModel):@\\
\mbox{}\lstinline@    """The scene graph controller.@\\
\mbox{}\lstinline@    A controller for managing the scene graph by adding, editing and removing@\\
\mbox{}\lstinline@    scenes.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph controller signals}\nobreak\ {\footnotesize \NWlink{nuweb37b}{37b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph controller constructor}\nobreak\ {\footnotesize \NWlink{nuweb22b}{22b}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize \NWlink{nuweb23b}{23b}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph controller slots}\nobreak\ {\footnotesize \NWlink{nuweb35}{35}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb89c}{89c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As at this point the functionality of the scene graph controller is not fully
known, the constructor simply initializes its parent class and an empty list of
scenes.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap17}\raggedright\small
\NWtarget{nuweb22b}{} $\langle\,${\itshape Scene graph controller constructor}\nobreak\ {\footnotesize {22b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, parent=None):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param parent: The parent of the current view model within the scene@\\
\mbox{}\lstinline@                    graph.@\\
\mbox{}\lstinline@    :type parent:  qde.editor.gui_domain.scene.SceneGraphViewModel@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    super(SceneGraphController, self).__init__(parent)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb22b}{22b}\NWlink{nuweb23d}{, 23d}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As the scene graph controller holds and manages the data, it needs to have at
least a root node. As the controller manages both, domain models and the view
models, it needs to create both models.

Due to the dependencies of other components this cannot be done within the
constructor, as components dependening on the scene graph controller may not be
listening to its signals at this point. Therefore this is done in a separate
method called \verb+add_root_node+.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap18}\raggedright\small
\NWtarget{nuweb23a}{} $\langle\,${\itshape Scene graph controller add root node}\nobreak\ {\footnotesize {23a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def add_root_node(self):@\\
\mbox{}\lstinline@    """Add a root node to the data structure.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if self.root_node is None:@\\
\mbox{}\lstinline@        root_node = domain_scene.SceneModel()@\\
\mbox{}\lstinline@        self.view_root_node = guidomain_scene.SceneGraphViewModel(@\\
\mbox{}\lstinline@            row=0,@\\
\mbox{}\lstinline@            domain_object=root_node,@\\
\mbox{}\lstinline@            name=QtCore.QCoreApplication.translate(__class__.__name__, 'Root scene')@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        self.do_add_scene.emit(root_node)@\\
\mbox{}\lstinline@        self.layoutChanged.emit()@\\
\mbox{}\lstinline@        self.logger.debug("Added root node")@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        self.logger.warn("Not (re-) adding root node, already present!")@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb23b}{23b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap19}\raggedright\small
\NWtarget{nuweb23b}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {23b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene graph controller add root node}\nobreak\ {\footnotesize \NWlink{nuweb23a}{23a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% TODO
The root scene can then be added by the main application, when all components
are set up properly.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap20}\raggedright\small
\NWtarget{nuweb23c}{} $\langle\,${\itshape Add root node for main application}\nobreak\ {\footnotesize {23c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@self.scene_graph_controller.add_root_node()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb15b}{15b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The scene graph controller must also provide the header data, which is used to
display the header within the view (due to the usage of the Qt view
model\todo{Add reference to Qts view model}). As header data the name of the
scenes as well as the number of nodes a scene contains shall be displayed.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap21}\raggedright\small
\NWtarget{nuweb23d}{} $\langle\,${\itshape Scene graph controller constructor}\nobreak\ {\footnotesize {23d}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.header_data = [@\\
\mbox{}\lstinline@        QtCore.QCoreApplication.translate(__class__.__name__, 'Name'),@\\
\mbox{}\lstinline@        QtCore.QCoreApplication.translate(__class__.__name__, '# Nodes')@\\
\mbox{}\lstinline@    ]@\\
\mbox{}\lstinline@    self.root_node = None@\\
\mbox{}\lstinline@    self.view_root_node = None@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb22b}{22b}\NWlink{nuweb23d}{, 23d}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% TODO: Check if needed
% Before implementing the actual methods, it is important to think about the
% attributes, that the scene graph controller will have, as attributes define and
% influence the methods.

As \verb+QAbstractItemModel+ is used as a basis for the scene graph controller,
some methods must be implemented at very least:~\enquote{When subclassing
QAbstractItemModel, at the very least you must implement index(), parent(),
rowCount(), columnCount(), and data(). These functions are used in all read-only
models, and form the basis of editable
models.}\footref{footnote:qabstractitemmodel}

The method \verb+index+ returns the position of an item in the (data-) model for
a given row and column below a parent item.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap22}\raggedright\small
\NWtarget{nuweb24}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {24}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def index(self, row, column, parent=QtCore.QModelIndex()):@\\
\mbox{}\lstinline@    """Return the index of the item in the model specified by the given row,@\\
\mbox{}\lstinline@    column and parent index.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param row: The row for which the index shall be returned.@\\
\mbox{}\lstinline@    :type  row: int@\\
\mbox{}\lstinline@    :param column: The column for which the index shall be returned.@\\
\mbox{}\lstinline@    :type column: int@\\
\mbox{}\lstinline@    :param parent: The parent index of the item in the model. An invalid model@\\
\mbox{}\lstinline@                   index is given as the default parameter.@\\
\mbox{}\lstinline@    :type parent: QtQore.QModelIndex@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the model index based on the given row, column and the parent@\\
\mbox{}\lstinline@             index.@\\
\mbox{}\lstinline@    :rtype: QtCore.QModelIndex@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not parent.isValid():@\\
\mbox{}\lstinline@        self.logger.debug((@\\
\mbox{}\lstinline@            "Getting index for row {0}, col {1}, root node"@\\
\mbox{}\lstinline@        ).format(row, column))@\\
\mbox{}\lstinline@        return self.createIndex(row, column, self.view_root_node)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    parent_node = parent.internalPointer()@\\
\mbox{}\lstinline@    self.logger.debug((@\\
\mbox{}\lstinline@        "Getting index for row {0}, col {1}, parent {2}. Children: {3}"@\\
\mbox{}\lstinline@    ).format(row, column, parent_node, len(parent_node.children())))@\\
\mbox{}\lstinline@    child_nodes = parent_node.children()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # It may happen, that the index is called at the same time as a node is@\\
\mbox{}\lstinline@    # being deleted respectively was deleted. In this case an invalid index is@\\
\mbox{}\lstinline@    # returned.@\\
\mbox{}\lstinline@    try:@\\
\mbox{}\lstinline@        child_node  = child_nodes[row]@\\
\mbox{}\lstinline@        return self.createIndex(row, column, child_node)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    except IndexError:@\\
\mbox{}\lstinline@        return QtCore.QModelIndex()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The method \verb+parent+ returns the parent item of an item identified by a
provided index. If that index is invalid, an invalid index is returned as well.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap23}\raggedright\small
\NWtarget{nuweb25a}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {25a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def parent(self, model_index):@\\
\mbox{}\lstinline@    """Return the parent of the model item with the given index. If the item has@\\
\mbox{}\lstinline@    no parent, an invalid QModelIndex is returned.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param model_index: The model index which the parent model index shall be@\\
\mbox{}\lstinline@                        derived for.@\\
\mbox{}\lstinline@    :type model_index: int@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the model index of the parent model item for the given model index.@\\
\mbox{}\lstinline@    :rtype: QtCore.QModelIndex@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # self.logger.debug("Getting parent")@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not model_index.isValid():@\\
\mbox{}\lstinline@        # self.logger.debug("No valid index for parent")@\\
\mbox{}\lstinline@        return QtCore.QModelIndex()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # The internal pointer of the the model index returns a scene graph view@\\
\mbox{}\lstinline@    # model.@\\
\mbox{}\lstinline@    node = model_index.internalPointer()@\\
\mbox{}\lstinline@    if node and node.parent() is not None:@\\
\mbox{}\lstinline@        # self.logger.debug("Index for parent")@\\
\mbox{}\lstinline@        return self.createIndex(node.parent().row, 0, node.parent())@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        # self.logger.debug("Index for root")@\\
\mbox{}\lstinline@        return QtCore.QModelIndex()@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Implementing the \verb+columnCount+ and \verb+rowCount+ methods is straight
forward. The former returns simply the number of columns, in this case the
number of headers, therefore 2.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap24}\raggedright\small
\NWtarget{nuweb25b}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {25b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def columnCount(self, parent):@\\
\mbox{}\lstinline@    """Return the number of columns for the children of the given parent.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param parent: The index of the item in the scene graph, which the@\\
\mbox{}\lstinline@                    column count shall be returned for.@\\
\mbox{}\lstinline@    :type  parent: QtCore.QModelIndex@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the number of columns for the children of the given parent.@\\
\mbox{}\lstinline@    :rtype:  int@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    column_count = len(self.header_data) - 1@\\
\mbox{}\lstinline@    self.logger.debug("Getting column count: %s", column_count)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return column_count@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The method \verb+rowCount+ returns the number of nodes for a given parent
item (identified by its index within the data model).

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap25}\raggedright\small
\NWtarget{nuweb26}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {26}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def rowCount(self, parent):@\\
\mbox{}\lstinline@    """Return the number of rows for the children of the given parent.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param parent: The index of the item in the scene graph, which the@\\
\mbox{}\lstinline@                    row count shall be returned for.@\\
\mbox{}\lstinline@    :type  parent: QtCore.QModelIndex@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the number of rows for the children of the given parent.@\\
\mbox{}\lstinline@    :rtype:  int@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not parent.isValid():@\\
\mbox{}\lstinline@        self.logger.debug("Parent is not valid")@\\
\mbox{}\lstinline@        row_count = 1@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        # Get the actual object stored by the parent. In this case it is a@\\
\mbox{}\lstinline@        # SceneGraphViewModel.@\\
\mbox{}\lstinline@        node = parent.internalPointer()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        if node is None:@\\
\mbox{}\lstinline@            self.logger.debug("Parent (node) is not valid")@\\
\mbox{}\lstinline@            row_count = 1@\\
\mbox{}\lstinline@        else:@\\
\mbox{}\lstinline@            row_count = len(node.children())@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.logger.debug("Getting row count: %s", row_count)@\\
\mbox{}\lstinline@    return row_count@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The last method, that has to be implemented due to the usage of
\verb+QAbstractItemModel+, is the \verb+data+ method. It returns the data for an
item identified by the given index for the given role.

A role indicates what type of data is provided. Currently the only role
considered is the display of models (further information may be found
at~\url{http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum}).

Depending on the column of the model index, the method returns either the name
of the scene graph node or the number of nodes a scene contains.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap26}\raggedright\small
\NWtarget{nuweb27}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {27}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def data(self, model_index, role=QtCore.Qt.DisplayRole):@\\
\mbox{}\lstinline@    """Return the data stored under the given role for the item referred by the@\\
\mbox{}\lstinline@    index.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param model_index: The (data-) model index of the item.@\\
\mbox{}\lstinline@    :type model_index: int@\\
\mbox{}\lstinline@    :param role: The role which shall be used for representing the data. The@\\
\mbox{}\lstinline@                 default (and currently only supported) is displaying the data.@\\
\mbox{}\lstinline@    :type role:  QtCore.Qt.DisplayRole@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the data stored under the given role for the item referred by the@\\
\mbox{}\lstinline@             given index.@\\
\mbox{}\lstinline@    :rtype:  str@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not model_index.isValid():@\\
\mbox{}\lstinline@        self.logger.debug("Model index is not valid")@\\
\mbox{}\lstinline@        return None@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # The internal pointer of the model index returns a scene graph view model.@\\
\mbox{}\lstinline@    node = model_index.internalPointer()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if node is None:@\\
\mbox{}\lstinline@        self.logger.debug("Node is not valid")@\\
\mbox{}\lstinline@        return None@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if role == QtCore.Qt.DisplayRole:@\\
\mbox{}\lstinline@        # Return either the name of the scene or its number of nodes.@\\
\mbox{}\lstinline@        column = model_index.column()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        if column == 0:@\\
\mbox{}\lstinline@            return node.name@\\
\mbox{}\lstinline@        elif column == 1:@\\
\mbox{}\lstinline@            return node.node_count@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
In addition to the above mentioned methods, the \verb+QAbstractItemModel+ offers
the method \verb+headerData+, which~\enquote{returns the data for the given role
and section in the header with the specified orientation.}\footnote{http://doc.qt.io/qt-5/qabstractitemmodel.html\#headerData}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap27}\raggedright\small
\NWtarget{nuweb28a}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {28a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def headerData(self, section, orientation=QtCore.Qt.Horizontal,@\\
\mbox{}\lstinline@               role=QtCore.Qt.DisplayRole):@\\
\mbox{}\lstinline@    """Return the data for the given role and section in the header with the@\\
\mbox{}\lstinline@    specified orientation.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    Currently vertical is the only supported orientation. The only supported@\\
\mbox{}\lstinline@    role is DisplayRole. As the sections correspond to the header, there are@\\
\mbox{}\lstinline@    only two supported sections: 0 and 1. If one of those parameters is not@\\
\mbox{}\lstinline@    within the described values, None is returned.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param section: the section in the header. Currently only 0 and 1 are@\\
\mbox{}\lstinline@                    supported.@\\
\mbox{}\lstinline@    :type  section: int@\\
\mbox{}\lstinline@    :param orientation: the orientation of the display. Currently only@\\
\mbox{}\lstinline@                        Horizontal is supported.@\\
\mbox{}\lstinline@    :type orientation:  QtCore.Qt.Orientation@\\
\mbox{}\lstinline@    :param role: The role which shall be used for representing the data. The@\\
\mbox{}\lstinline@                 default (and currently only supported) is displaying the data.@\\
\mbox{}\lstinline@    :type role:  QtCore.Qt.DisplayRole@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the header data for the given section using the given role and@\\
\mbox{}\lstinline@             orientation.@\\
\mbox{}\lstinline@    :rtype:  str@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if (@\\
\mbox{}\lstinline@            orientation == QtCore.Qt.Horizontal  and@\\
\mbox{}\lstinline@            role        == QtCore.Qt.DisplayRole and@\\
\mbox{}\lstinline@            section     in [0, 1]@\\
\mbox{}\lstinline@    ):@\\
\mbox{}\lstinline@        return self.header_data[section]@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
One thing, that may stand out, is, that the above defined \verb+data+ method
returns the number of graph nodes within a scene by accessing the
\verb+node_count+ property of the \textit{scene graph view model}.

The \textit{scene graph view model} does therefore need to keep track of the nodes it
contains, in form of a list, analogous to the domain model.

It does not make sense however to use the list of nodes from the domain model,
as the view model will hold references to graphical objects where as the domain
model holds only pure data objects. Therefore it is necessary, that the scene
view model keeps track of its nodes separately.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap28}\raggedright\small
\NWtarget{nuweb28b}{} $\langle\,${\itshape Scene graph view model constructor}\nobreak\ {\footnotesize {28b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.nodes = []@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb21b}{21b}\NWlink{nuweb28b}{, 28b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The method \verb+node_count+ then simply returns the length of the node list.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap29}\raggedright\small
\NWtarget{nuweb29a}{} $\langle\,${\itshape Scene graph view model methods}\nobreak\ {\footnotesize {29a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@property@\\
\mbox{}\lstinline@def node_count(self):@\\
\mbox{}\lstinline@    """Return the number of nodes that this scene contains."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return len(self.nodes)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb29a}{29a}\NWlink{nuweb89a}{, 89a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% The object \verb+node+ is in this case a scene graph view model, which holds a
% reference to scene graph view model. This may be confusing at first, as they seem very
% similar. But as stated before, view models are used to visually represent
% something within the graphical user interface. Therefore the \textit{scene graph
% view model} stands for an entry within the scene graph where as the
% \textit{scene graph view model} represents a

The scene graph controller can now be set up by the main application controller.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap30}\raggedright\small
\NWtarget{nuweb29b}{} $\langle\,${\itshape Set up controllers for main application}\nobreak\ {\footnotesize {29b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.scene_graph_controller = scene.SceneGraphController(self)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb29b}{29b}\NWlink{nuweb52d}{, 52d}\NWlink{nuweb84b}{, 84b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb17b}{17b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
At this point data structures in terms of a (data-) model and a view model
concerning the scene graph are implemented. Further a controller for handling
the flow of the data for both models is implemented. What is still missing, is
the actual representation of the scene graph in terms of a view.

Qt offers a plethora of widgets for implementing views. One such widget is
\verb+QTreeView+, which~\enquote{implements a tree representation of items from
a model. This class is used to provide standard hierarchical lists that were
previously provided by the QListView class, but using the more flexible approach
provided by Qt's model/view
architecture.}~\footnote{fn:f377826acb87691:http://doc.qt.io/qt-5/qtreeview.html\#details}
Therefore \verb+QTreeView+ is used as basis for the scene graph view.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap31}\raggedright\small
\NWtarget{nuweb29c}{} $\langle\,${\itshape Scene graph view declarations}\nobreak\ {\footnotesize {29c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene graph view decorators}\nobreak\ {\footnotesize \NWlink{nuweb92b}{92b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@class SceneGraphView(QtWidgets.QTreeView):@\\
\mbox{}\lstinline@    """The scene graph view widget.@\\
\mbox{}\lstinline@    A widget for displaying and managing the scene graph.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph view signals}\nobreak\ {\footnotesize \NWlink{nuweb32a}{32a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph view constructor}\nobreak\ {\footnotesize \NWlink{nuweb30a}{30a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph view methods}\nobreak\ {\footnotesize \NWlink{nuweb31b}{31b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene graph view slots}\nobreak\ {\footnotesize \NWlink{nuweb31a}{31a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb90}{90}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As at this point the functionality of the scene graph view is not fully
known, the constructor simply initializes its parent class.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap32}\raggedright\small
\NWtarget{nuweb30a}{} $\langle\,${\itshape Scene graph view constructor}\nobreak\ {\footnotesize {30a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, parent=None):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param parent:        The parent of the current view widget.@\\
\mbox{}\lstinline@    :type parent:         QtCore.QObject@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    super(SceneGraphView, self).__init__(parent)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb30a}{30a}\NWlink{nuweb32c}{, 32c}\NWlink{nuweb33}{, 33}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
For being able to display anything, the scene graph view needs a controller to
work with. In terms of Qt, the controller is called a model, as due its
model/view architecture. This model may although not be set too early, as
otherwise problems arise. It may only then be added, when the depending
components are properly initialized, e.g. when the root node has been added.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap33}\raggedright\small
\NWtarget{nuweb30b}{} $\langle\,${\itshape Set model for scene graph view}\nobreak\ {\footnotesize {30b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@self.main_window.scene_graph_view.setModel(@\\
\mbox{}\lstinline@    self.scene_graph_controller@\\
\mbox{}\lstinline@)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb15b}{15b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
But scenes shall not only be displayed, instead it shall be possible to work
with them. What shall be achieved, are three things: Adding and removing scenes,
renaming scenes and switching scenes.

To switch between scenes it is necessary to emit what scene was selected. This
is needed to tell the other components, such as the node graph for example, that
the scene has changed.

Through the \verb+selectionChanged+ signal the scene graph view already provides
a possibility to detect if another scene was selected. This signal emits an item
selection in terms of model indices although.

As this is very view- and model-specific, it would be easier for other
components if the selected scene is emitted directly. To emit the selected
index of the currently selected scene directly, the slot
\verb+on_tree_item_selected+ is introduced.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap34}\raggedright\small
\NWtarget{nuweb31a}{} $\langle\,${\itshape Scene graph view slots}\nobreak\ {\footnotesize {31a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot(QtCore.QItemSelection, QtCore.QItemSelection)@\\
\mbox{}\lstinline@def on_tree_item_selected(self, selected, deselected):@\\
\mbox{}\lstinline@    """Slot which is called when the selection within the scene graph view is@\\
\mbox{}\lstinline@    changed.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    The previous selection (which may be empty) is specified by the deselected@\\
\mbox{}\lstinline@    parameter, the new selection is specified by the selected paramater.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    This method emits the selected scene graph item as scene graph view model.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param selected: The new selection of scenes.@\\
\mbox{}\lstinline@    :type  selected: QtCore.QModelIndex@\\
\mbox{}\lstinline@    :param deselected: The previous selected scenes.@\\
\mbox{}\lstinline@    :type  deselected: QtCore.QModelIndex@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    selected_item = selected.first()@\\
\mbox{}\lstinline@    selected_index = selected_item.indexes()[0]@\\
\mbox{}\lstinline@    self.do_select_item.emit(selected_index)@\\
\mbox{}\lstinline@    self.logger.debug("Tree item was selected: %s" % selected_index)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb31a}{31a}\NWlink{nuweb34}{, 34}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The \verb+on_tree_item_selected+ slot needs to be triggered as soon as the
selection is changed. This is done by connecting the slot with the
\verb+selectionChanged+ signal. The \verb+selectionChanged+ signal is however
not directly accessible, it is only accessible through the selection model of
the scene graph view (which is given by the usage of \verb+QTreeView+). The
selection model can although only be accessed when setting the data model of the
view, which needs therefore to be expanded.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap35}\raggedright\small
\NWtarget{nuweb31b}{} $\langle\,${\itshape Scene graph view methods}\nobreak\ {\footnotesize {31b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def setModel(self, model):@\\
\mbox{}\lstinline@    """Set the model for the view to present.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    This method is only used for being able to use the selection model's@\\
\mbox{}\lstinline@    selectionChanged method and setting the current selection to the root node.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param model: The item model which the view shall present.@\\
\mbox{}\lstinline@    :type  model: QtCore.QAbstractItemModel@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    super(SceneGraphView, self).setModel(model)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Use a slot to emit the selected scene graph view model upon the selection of a@\\
\mbox{}\lstinline@    # tree item@\\
\mbox{}\lstinline@    selection_model = self.selectionModel()@\\
\mbox{}\lstinline@    selection_model.selectionChanged.connect(@\\
\mbox{}\lstinline@        self.on_tree_item_selected@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Set the index to the first node of the model@\\
\mbox{}\lstinline@    self.setCurrentIndex(model.index(0, 0))@\\
\mbox{}\lstinline@    self.logger.debug("Root node selected")@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As stated in the above code fragment, \verb+on_tree_item_selected+ emits another
signal containing a reference to the currently selected scene.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap36}\raggedright\small
\NWtarget{nuweb32a}{} $\langle\,${\itshape Scene graph view signals}\nobreak\ {\footnotesize {32a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@do_select_item = QtCore.pyqtSignal(QtCore.QModelIndex)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb32a}{32a}\NWlink{nuweb32b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
In the same manner as the selection of an item was implemented, the adding and
removal of a scene are implemented. However, the tree widget does not provide
direct signals for those cases as it is the case when selecting a tree item,
instead own signals, slots and actions have to be used.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap37}\raggedright\small
\NWtarget{nuweb32b}{} $\langle\,${\itshape Scene graph view signals}\nobreak\ {\footnotesize {32b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@do_add_item = QtCore.pyqtSignal(QtCore.QModelIndex)@\\
\mbox{}\lstinline@do_remove_item = QtCore.pyqtSignal(QtCore.QModelIndex)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb32a}{32a}\NWlink{nuweb32b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
An action gets triggered, typically by hovering over some item (in terms of a
context menu for example) or by pressing a defined keyboard shortcut. For the
adding and the removal, a keyboard shortcut will be used.

Adding of a scene item shall happen when pressing the \verb=a= key on the
keyboard.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap38}\raggedright\small
\NWtarget{nuweb32c}{} $\langle\,${\itshape Scene graph view constructor}\nobreak\ {\footnotesize {32c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    new_action_label = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@        __class__.__name__, 'New scene'@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    new_action = QtWidgets.QAction(new_action_label, self)@\\
\mbox{}\lstinline@    new_action.setShortcut(Qt.QKeySequence('a'))@\\
\mbox{}\lstinline@    new_action.setShortcutContext(QtCore.Qt.WidgetShortcut)@\\
\mbox{}\lstinline@    new_action.triggered.connect(self.on_new_tree_item)@\\
\mbox{}\lstinline@    self.addAction(new_action)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb30a}{30a}\NWlink{nuweb32c}{, 32c}\NWlink{nuweb33}{, 33}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Removal of a selected node shall be triggered upon the press of the
\verb+delete+ and the \verb+backspace+ key on the keyboard.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap39}\raggedright\small
\NWtarget{nuweb33}{} $\langle\,${\itshape Scene graph view constructor}\nobreak\ {\footnotesize {33}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    remove_action_label = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@        __class__.__name__, 'Remove selected scene(s)'@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    remove_action = QtWidgets.QAction(remove_action_label, self)@\\
\mbox{}\lstinline@    remove_action.setShortcut(Qt.QKeySequence('Delete'))@\\
\mbox{}\lstinline@    remove_action.setShortcut(Qt.QKeySequence('Backspace'))@\\
\mbox{}\lstinline@    remove_action.setShortcutContext(QtCore.Qt.WidgetShortcut)@\\
\mbox{}\lstinline@    remove_action.triggered.connect(self.on_tree_item_removed)@\\
\mbox{}\lstinline@    self.addAction(remove_action)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb30a}{30a}\NWlink{nuweb32c}{, 32c}\NWlink{nuweb33}{, 33}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As can be seen in the two above listings, the \verb+triggered+ signals are
connected with a corresponding slot. All these slots do is emitting another
signal, but this time it contains a scene graph view model, which may be used by
other components, instead of a model index.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap40}\raggedright\small
\NWtarget{nuweb34}{} $\langle\,${\itshape Scene graph view slots}\nobreak\ {\footnotesize {34}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot()@\\
\mbox{}\lstinline@def on_new_tree_item(self):@\\
\mbox{}\lstinline@    """Slot which is called when a new tree item was added by the scene graph@\\
\mbox{}\lstinline@    view.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    This method emits the selected scene graph item as new tree item in form of@\\
\mbox{}\lstinline@    a scene graph view model.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    selected_indexes = self.selectedIndexes()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Sanity check: is actually an item selected?@\\
\mbox{}\lstinline@    if len(selected_indexes) > 0:@\\
\mbox{}\lstinline@        selected_item = selected_indexes[0]@\\
\mbox{}\lstinline@        self.do_add_item.emit(selected_item)@\\
\mbox{}\lstinline@        @\hbox{$\langle\,${\itshape Scene graph view log tree item added}\nobreak\ {\footnotesize \NWlink{nuweb39d}{39d}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot()@\\
\mbox{}\lstinline@def on_tree_item_removed(self):@\\
\mbox{}\lstinline@    """Slot which is called when a one or multiple tree items were removed by@\\
\mbox{}\lstinline@    the scene graph view.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    This method emits the removed scene graph item in form of scene graph view@\\
\mbox{}\lstinline@    models.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    selected_indexes = self.selectedIndexes()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Sanity check: is actually an item selected? And has that item a parent?@\\
\mbox{}\lstinline@    # We only allow removal of items with a valid parent, as we do not want to@\\
\mbox{}\lstinline@    # have the root item removed.@\\
\mbox{}\lstinline@    if len(selected_indexes) > 0:@\\
\mbox{}\lstinline@        selected_item = selected_indexes[0]@\\
\mbox{}\lstinline@        if selected_item.parent().isValid():@\\
\mbox{}\lstinline@            self.do_remove_item.emit(selected_item)@\\
\mbox{}\lstinline@            @\hbox{$\langle\,${\itshape Scene graph view log tree item removed}\nobreak\ {\footnotesize \NWlink{nuweb40}{40}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@        else:@\\
\mbox{}\lstinline@            self.logger.warn("Root scene cannot be deleted")@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        self.logger.warn('No item selected for removal')@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb31a}{31a}\NWlink{nuweb34}{, 34}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
One of the mentioned other components is the scene graph controller. He needs to
be informed whenever a scene was added, removed or selected, so that he is able to
manage his data model correspondingly.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap41}\raggedright\small
\NWtarget{nuweb35}{} $\langle\,${\itshape Scene graph controller slots}\nobreak\ {\footnotesize {35}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot(QtCore.QModelIndex)@\\
\mbox{}\lstinline@def on_tree_item_added(self, selected_item):@\\
\mbox{}\lstinline@    # TODO: Document method.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.insertRows(0, 1, selected_item)@\\
\mbox{}\lstinline@    self.logger.debug("Added new scene")@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot(QtCore.QModelIndex)@\\
\mbox{}\lstinline@def on_tree_item_removed(self, selected_item):@\\
\mbox{}\lstinline@    # TODO: Document method.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not selected_item.isValid():@\\
\mbox{}\lstinline@        self.logger.warn("Selected scene is not valid, note removing")@\\
\mbox{}\lstinline@        return False@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    row = selected_item.row()@\\
\mbox{}\lstinline@    parent = selected_item.parent()@\\
\mbox{}\lstinline@    self.removeRows(row, 1, parent)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot(QtCore.QModelIndex)@\\
\mbox{}\lstinline@def on_tree_item_selected(self, selected_item):@\\
\mbox{}\lstinline@    # TODO: Document method.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not selected_item.isValid():@\\
\mbox{}\lstinline@        self.logger.warn("Selected scene is not valid")@\\
\mbox{}\lstinline@        return False@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    selected_scene_view_model = selected_item.internalPointer()@\\
\mbox{}\lstinline@    selected_scene_domain_model  = selected_scene_view_model.domain_object@\\
\mbox{}\lstinline@    self.do_select_scene.emit(selected_scene_domain_model)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Having the slots for adding, removing and selecting scene graph items
implemented, the actual methods for adding and removing scenes,
\verb+on_tree_item_added+ and \verb+on_tree_item_removed+, are still missing.

When inserting a new scene graph item, actually a row must be inserted, as the
data model (Qt's) is using rows to represent the data. At the same time the
controller has to keep track of the domain model.

As can be seen in the implementation below, it is not necessary to add the
created model instances to a list of nodes, the usage of
\verb+QAbstractItemModel+ keeps already track of this.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap42}\raggedright\small
\NWtarget{nuweb36a}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {36a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def insertRows(self, row, count, parent=QtCore.QModelIndex()):@\\
\mbox{}\lstinline@    # TODO: Document method.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not parent.isValid():@\\
\mbox{}\lstinline@        return False@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    parent_node = parent.internalPointer()@\\
\mbox{}\lstinline@    self.beginInsertRows(parent, row, row + count - 1)@\\
\mbox{}\lstinline@    domain_model  = domain_scene.SceneModel(parent_node.domain_object)@\\
\mbox{}\lstinline@    view_model = guidomain_scene.SceneGraphViewModel(@\\
\mbox{}\lstinline@        row=row,@\\
\mbox{}\lstinline@        domain_object=domain_model,@\\
\mbox{}\lstinline@        parent=parent_node@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    self.endInsertRows()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.layoutChanged.emit()@\\
\mbox{}\lstinline@    self.do_add_scene.emit(domain_model)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return True@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The same logic applies when removing a scene.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap43}\raggedright\small
\NWtarget{nuweb36b}{} $\langle\,${\itshape Scene graph controller methods}\nobreak\ {\footnotesize {36b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def removeRows(self, row, count, parent=QtCore.QModelIndex()):@\\
\mbox{}\lstinline@    # TODO: Document method.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not parent.isValid():@\\
\mbox{}\lstinline@        self.logger.warn("Cannot remove rows, parent is invalid")@\\
\mbox{}\lstinline@        return False@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.beginRemoveRows(parent, row, row + count - 1)@\\
\mbox{}\lstinline@    parent_node = parent.internalPointer()@\\
\mbox{}\lstinline@    node_index = parent.child(row, parent.column())@\\
\mbox{}\lstinline@    node       = node_index.internalPointer()@\\
\mbox{}\lstinline@    node.setParent(None)@\\
\mbox{}\lstinline@    # TODO: parent_node.child_nodes.remove(node)@\\
\mbox{}\lstinline@    self.endRemoveRows()@\\
\mbox{}\lstinline@    self.logger.debug(@\\
\mbox{}\lstinline@        "Removed {0} rows starting from {1} for parent {2}. Children: {3}".format(@\\
\mbox{}\lstinline@            count, row, parent_node, len(parent_node.children())@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.layoutChanged.emit()@\\
\mbox{}\lstinline@    self.do_remove_scene.emit(node.domain_object)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return True@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb23b}{23b}\NWlink{nuweb24}{, 24}\NWlink{nuweb25a}{, 25a}\NWlink{nuweb25b}{b}\NWlink{nuweb26}{, 26}\NWlink{nuweb27}{, 27}\NWlink{nuweb28a}{, 28a}\NWlink{nuweb36a}{, 36a}\NWlink{nuweb36b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As before, the main application needs connect the components, in this case the
scene graph view with the scene graph controller.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap44}\raggedright\small
\NWtarget{nuweb37a}{} $\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize {37a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.main_window.scene_graph_view.do_add_item.connect(@\\
\mbox{}\lstinline@    self.scene_graph_controller.on_tree_item_added@\\
\mbox{}\lstinline@)@\\
\mbox{}\lstinline@self.main_window.scene_graph_view.do_remove_item.connect(@\\
\mbox{}\lstinline@    self.scene_graph_controller.on_tree_item_removed@\\
\mbox{}\lstinline@)@\\
\mbox{}\lstinline@self.main_window.scene_graph_view.do_select_item.connect(@\\
\mbox{}\lstinline@    self.scene_graph_controller.on_tree_item_selected@\\
\mbox{}\lstinline@)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb17d}{17d}\NWlink{nuweb37a}{, 37a}\NWlink{nuweb56b}{, 56b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb17c}{17c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
To inform other components, such as the node graph for example, the scene graph
controller emits signals when a scene is being added, removed or selected
respectively.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap45}\raggedright\small
\NWtarget{nuweb37b}{} $\langle\,${\itshape Scene graph controller signals}\nobreak\ {\footnotesize {37b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@do_add_scene    = QtCore.pyqtSignal(domain_scene.SceneModel)@\\
\mbox{}\lstinline@do_remove_scene = QtCore.pyqtSignal(domain_scene.SceneModel)@\\
\mbox{}\lstinline@do_select_scene = QtCore.pyqtSignal(domain_scene.SceneModel)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb22a}{22a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% TODO: EDIT MODELS
% For being able edit the nodes of the scene graph and to have a custom header
% displayed, further methods have to be implemented: ``To enable editing in your
% model, you must also implement setData(), and reimplement flags() to ensure that
% ItemIsEditable is returned. You can also reimplement headerData() and
% setHeaderData() to control the way the headers for your model are presented.''

At this point it is possible to manage scenes in terms of adding and removing
them. The scenes are added to (or removed from respectively) the graphical user
interface as well as the data structure.

So far the application (or rather the scene graph) seems to be working as
intended. But how does one ensure, that it really does? Without a doubt, unit
and integration tests are one of the best instruments to ensure functionality of
code.

As stated before, in~\autoref{subsec:literate-programming}, it was an intention
of this project to develop the application test driven. Due to required amount
of work for developing test driven, it was abstained from this intention and
regular unit tests are written instead, which can be found in
appendix,~\autoref{sec:test-cases}.

But nevertheless, it would be very handy to have at least some idea what the
code is doing at certain places and at certain times.

One of the simplest approaches to achieve this, is a verbose output at various
places of the application, which may be as simple as using Python's
\verb+print+ function. Using the \verb+print+ function may allow
printing something immediately, but it lacks of flexibility and demands each
time a bit of effort to format the output accordingly (e.g. adding the class and
the function name and so on).

Python's logging facility provides much more functionality while being able to
keep things simple as well --- if needed. The usage of the logging facility to
log messages throughout the application may later even be used to implement a
widget which outputs those messages. So logging using Python's logging facility
will be implemented and applied for being able to have feedback when needed.

\subsubsection{Logging}
\label{ssubsec:logging}

It is always very useful to have a facility which allows tracing of errors or
even just the flow of an application. Logging does allow such aspects by
outputting text messages to a defined output, such as STDERR, STDOUT, streams or
files.

Logging shall be provided on a class-basis, meaning that each class (which wants
to log something) needs to instantiate a logger and use a corresponding handler.

As logging is a very central aspect of the application, it is the task of the
main application to set up the logging facility which may then be used by other
classes through a decorator.

The main application shall therefore set up the logging facility as follows:
\begin{itemize}
  \item Use either an external logging configuration or the default logging
        configuration.
  \item When using an external logging configuration
    \begin{itemize}
      \item The location of the external logging configuration may be set by the
            environment variable \verb+QDE_LOG_CFG+.
      \item Is no such environment variable set, the configuration file is
            assumed to be named \verb+logging.json+ and to reside in the
            application's main directory.
    \end{itemize}
  \item When using no external logging configuration, the default logging
        configuration defined by \verb+basicConfig+ is used.
  \item Always set a level when using no external logging configuration, the
        default being \verb+INFO+.
\end{itemize}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap46}\raggedright\small
\NWtarget{nuweb38a}{} $\langle\,${\itshape Main application methods}\nobreak\ {\footnotesize {38a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def setup_logging(self,@\\
\mbox{}\lstinline@                  default_path='logging.json',@\\
\mbox{}\lstinline@                  default_level=logging.INFO):@\\
\mbox{}\lstinline@    """Setup logging configuration"""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    env_key  = 'QDE_LOG_CFG'@\\
\mbox{}\lstinline@    env_path = os.getenv(env_key, None)@\\
\mbox{}\lstinline@    path     = env_path or default_path@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if os.path.exists(path):@\\
\mbox{}\lstinline@        with open(path, 'rt') as f:@\\
\mbox{}\lstinline@            config = json.load(f)@\\
\mbox{}\lstinline@            logging.config.dictConfig(config)@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        logging.basicConfig(level=default_level)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb15a}{15a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
For not having only basic logging available, a logging configuration is defined.
The logging configuration provides three handlers: a console handler, which logs
debug messages to STDOUT, a info file handler, which logs informational messages
to a file named \verb+info.log+, and a error file handler, which logs errors to
a file named \verb+error.log+. The default level is set to debug and all
handlers are used.

This configuration allows to get an arbitrarily named logger which uses that
configuration.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap47}\raggedright\small
\NWtarget{nuweb38b}{} $\langle\,${\itshape Set up internals for main application}\nobreak\ {\footnotesize {38b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.setup_logging()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb15c}{15c}\NWlink{nuweb38b}{, 38b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb15b}{15b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As stated before, logging shall be provided on a class basis. This has the
consequence, that each class has to instantiate a logging instance. To prevent
the repetition of the same code fragment over and over, Python's decorator
pattern is used~\footnote{https://www.python.org/dev/peps/pep-0318/}.

The decorator will be available as a method named \verb+with_logger+.
The method has the following functionality.

\begin{itemize}
  \item Provide a name based on the current module and class.
    \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap48}\raggedright\small
\NWtarget{nuweb39a}{} $\langle\,${\itshape Set logger name}\nobreak\ {\footnotesize {39a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@logger_name = "{module_name}.{class_name}".format(@\\
\mbox{}\lstinline@    module_name=cls.__module__,@\\
\mbox{}\lstinline@    class_name=cls.__name__@\\
\mbox{}\lstinline@)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb92a}{92a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\item Provide an easy to use interface for logging.
    \begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap49}\raggedright\small
\NWtarget{nuweb39b}{} $\langle\,${\itshape Logger interface}\nobreak\ {\footnotesize {39b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@cls.logger = logging.getLogger(logger_name)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@return cls@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb92a}{92a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\end{itemize}

The implementation of the \verb+with_logger+ method allows the usage of the
logging facility as a decorator, as shown in the example in the following
listing.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap50}\raggedright\small
\NWtarget{nuweb39c}{} $\langle\,${\itshape With logger example}\nobreak\ {\footnotesize {39c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@def SomeClass(object):@\\
\mbox{}\lstinline@    """This class provides literally nothing and is used only to demonstrate the@\\
\mbox{}\lstinline@    usage of the logging decorator."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def some_method():@\\
\mbox{}\lstinline@        """This method does literally nothing and is used only to demonstrate the@\\
\mbox{}\lstinline@        usage of the logging decorator."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        self.logger.debug(("I am some logging entry used for"@\\
\mbox{}\lstinline@                           "demonstration purposes only."))@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The logging facility may now be used wherever it is useful to log something.
Such a place is for example the adding and removal of scenes in the scene graph
view.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap51}\raggedright\small
\NWtarget{nuweb39d}{} $\langle\,${\itshape Scene graph view log tree item added}\nobreak\ {\footnotesize {39d}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.logger.debug("A new scene graph item was added.")@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34}{34}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap52}\raggedright\small
\NWtarget{nuweb40}{} $\langle\,${\itshape Scene graph view log tree item removed}\nobreak\ {\footnotesize {40}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.logger.debug((@\\
\mbox{}\lstinline@    "The scene graph item at row {row} "@\\
\mbox{}\lstinline@    "and column {column} was removed."@\\
\mbox{}\lstinline@).format(@\\
\mbox{}\lstinline@    row=selected_item.row(),@\\
\mbox{}\lstinline@    column=selected_item.column()@\\
\mbox{}\lstinline@))@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb34}{34}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Whenever the \textit{a} or the \textit{delete} key is being pressed now, when
the scene graph view is focused, the corresponding log messages appear in the
standard output, hence the console.

Now, having the scene graph component as well as an interface to log messages
throughout the application implemented, the next component may be approached.

Scenes build the basis for the scene graph and the node graph as well. This is a
good point to begin with the implementation of the node graph.

\subsection{Node graph}
\label{subsec:node-graph}

The functionality of the node graph is, as its name states, to represent a data
structure composed of nodes and edges. Each scene from the scene graph is
represented within the node graph as such a data structure.

The nodes are the building blocks of a real time animation. They represent
different aspects, such as scenes themselves, time line clips, models, cameras,
lights, materials, generic operators and effects. These aspects are only examples
(coming from~\citetitle[p. 30 and 31]{osterwalder_qde_2016}) as the node
structure will be expandable for allowing the addition of new nodes.

The implementation of the scene graph component was relatively straightforward
partly due to its structure and partly due to the used data model and
representation. The node graph component however, seems to be a bit more complex.

To get a first overview and to manage its complexity, it might be good to
identify its sub components first before implementing them.
When thinking about the implementation of the node graph, one may identify the
following sub components:

\begin{description}
\item[Nodes] Building blocks of a real time animation.
  \begin{description}
    \item[Domain model] Holds data of a node, like its definition, its inputs
                        and so on.
    \item[Definitions]  Represents a domain model as JSON data structure.
    \item[Controller]   Handles the loading of node definitions as well as the
                        creation of node instances.
    \item[View model]   Represents a node within the graphical user interface.
  \end{description}
\end{description}

\begin{description}
\item[Scenes] A composition of nodes, connected by edges.
  \begin{description}
    \item[Domain model] Holds the data of a scene, e.g. its nodes.
    \item[Controller]   Handles scene related actions, like when a node is added
                        to a scene, when the scene was changed or when a node
                        within a scene was selected.
    \item[View model]   Defines the graphical representation of scene which can
                        be represented by the corresponding view. Basically the
                        scene view model is a canvas consisting of nodes.
    \item[View]         Represents scenes in terms of scene view models within the
                        graphical user interface.
  \end{description}
\end{description}

\subsubsection{Nodes}
\label{ssubsec:nodes}

As mentioned before, nodes are the building blocks of a real time animation. But
what are those definitions actually? What do they actually define? There is not
only one answer to this question, it is simply a matter of how the
implementation is being done and therefore a set of decisions.

The whole (rendering) system shall not be bound to only one representation of
nodes, e.g. triangle based meshes. Instead it shall let the user decide, what
representation is the most fitting for the goal he wants to achieve.

Therefore the system shall be able to support multiple kinds of node
representations: Images, triangle based meshes and solid modeling through
function modeling (using signed distance functions for modeling implicit
surfaces). Whereas triangle based meshes may either be loaded from externally
defined files (e.g. in the Filmbox (FBX), the Alembic (ABC) or the Object file
format (OBJ)) or directly be generated using procedural mesh generation.

The nodes are always part of a graph, hence the name node graph, and are
therefore typically connected by edges. This means that the graph gets evaluated
recursively by its nodes, starting with the root node within the root scene.
However, the goal is to have OpenGL shading language (GLSL) code at the end,
independent of the node types.

From this point of view it would make sense to let the user define shader
code directly within a node (definition) and to simply evaluate this code, which
adds a lot of (creative) freedom. The problem with this approach is though, that
image and triangle based mesh nodes are not fully implementable by using shader
code only. Instead they have specific requirements, which are only perform-able
on the CPU (e.g. allocating buffer objects).

When thinking of nodes used for solid modeling however, it may appear, that they
may be evaluated directly, without the need for pre-processing, as they are
fully implementable using shader code only. This is kind of misleading however,
as each node has its own definition which has to be added to shader and this
definition is then used in a mapping function to compose the scene. This would
mean to add a definition of a node over and over again, when spawning multiple
instances of the same node type, which results in overhead bloating the shader.
It is therefore necessary to pre-process solid modeling nodes too, exactly as
triangle mesh based and image nodes, for being able to use multiple instances of
the same node type within a scene while having the definition added only once.

All of these thoughts sum up in one central question for the implementation:
Shall objects be predefined within the code (and therefore only nodes accepted
whose type and sub type match those of predefined nodes) or shall all objects be
defined externally using files?

This is a question which is not that easy to answer. Both methods have their
advantages and disadvantages. Pre-defining nodes within the code minimizes
unexpected behavior of the application. Only known and well-defined nodes are
processed.

But what if someone would like to have a new node type which is not yet defined?
The node type has to be implemented first. As Python is used for the editor
application, this is not really a problem as the code is interpreted each time
and is therefore not being compiled. Nevertheless such changes follow a certain
process, such as making the actual changes within the code, reviewing and
checking-in the code and so on, which the user normally does not want to be
bothered with. Furthermore, when thinking about the player application, the
problem of the necessity to recompile the code is definitively given. The player
will be implemented in C, as there is the need for performance, which Python may
not fulfill satisfactorily.

Considering these aspects, the external definition of nodes is chosen. This may
result in nodes which cannot be evaluated or which have unwanted effects. As it
is (most likely) in the users best interest to create (for his taste) appealing
real time animations, it can be assumed, that the user will try avoiding to
create such nodes or quickly correct faulty nodes or simply does not use such
nodes.

Now, having chosen how to implement nodes, it is important to define what a node
actually is. As a node may be referenced by other nodes, it must be uniquely
identifiable and must therefore have a globally unique identifier. Concerning
the visual representation, a node shall have a name as well as a description.

Each node can have multiple inputs and at least one output. The inputs may be
either be atomic types (which have to be defined) or references to other nodes.
The same applies to the outputs.

A node consists also of a definition. In terms of implicit surfaces this
section contains the actual definition of a node in terms of the implicit
function. In terms of triangle based meshes this is the part where the mesh and
all its prerequisites as vertex array buffers and vertex array objects are set
up or used from a given context.

In addition to a definition, a node contains an invocation part, which is the
call of its defining function (coming from the definition mentioned just
before) while respecing the parameters.

A node shall be able to have one or more parts. A part typically contains the
\enquote{body} of the node in terms of code and represents therefore the code-wise
implementation of the node. A part can be processed when evaluating the node.
This part of the node is mainly about evaluating inputs and passing them on to
a shader.

Furthermore a node may contain children, child-nodes, which are actually
references to other nodes combined with properties such as a name, states and so
on.

Each node can have multiple connections. A connection is composed of an input
and an output plus a reference to a part.
The input respectively the output may be zero, what means that the part of the
input or output is internal.

Or, a bit more formal:

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap53}\raggedright\small
\NWtarget{nuweb42}{} $\langle\,${\itshape Connections between nodes in EBNF notation}\nobreak\ {\footnotesize {42}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@input = internal input | external input@\\
\mbox{}\lstinline@internal input = zero reference, part reference@\\
\mbox{}\lstinline@external input = node reference, part reference@\\
\mbox{}\lstinline@zero reference = "0"@\\
\mbox{}\lstinline@node reference = "uuid4"@\\
\mbox{}\lstinline@part reference = "uuid4"@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% Reference to a node X + Reference to /output/ A of node X.
% or
% No reference to another node + Reference to an /input/ of the current node.
%
% Output:
% Reference to a node Y + Reference to /input/ B of node Y.
% or
% No reference to another node + Reference to an /output/ or to /part/ of the
% current node.

Recapitulating the above made thoughts, a node is essentially composed by the
following elements:

\begin{table*}\centering
  \ra{1.3}
  \begin{tabularx}{\textwidth}{@{}lX@{}}
    \toprule
    Component & Description \\
    \hline
    ID & A global unique identifier
         (UUID~\footnote{https://docs.python.org/3/library/uuid.html}) \\
    Name & The name of the node, e.g. "Cube". \\
    Description & A description of the node's purpose. \\
    Inputs & A list of the node's inputs. The inputs may either be parameters
             (which are atomic types such as float values or text input) or
             references to other nodes. \\
    Outputs & A list of the node's outputs. The outputs may also either be
              parameters or references to other nodes. \\
    Definitions & A list of the node's definitions. This may be an actual
                 definition by a (shader-) function in terms of an implicit
                 surface or prerequisites as vertex array buffers in terms of a
                 triangle based mesh. \\
    Invocation & A list of the node's invocations or calls respectively.\\
    Parts & Defines parts that may be processed when evaluating the node.
            Contains code which can be interpreted directly. \\
    Nodes & The children a node has (child nodes). These entries are
            references to other nodes only. \\
    Connections & A list of connections of the node's inputs and outputs.

                  Each connection is composed by two parts: A reference to another
                  node and a reference to an input or an output of that node. Is
                  the reference not set, that is, its value is zero, this means
                  that the connection is internal. \\
    \bottomrule
  \end{tabularx}
\end{table*}

The inputs and outputs may be parameters of an atomic type, as stated above. This
seems like a good point to define the atomic types the system will have:

\begin{itemize}
  \item{Generic}
  \item{Float}
  \item{Text}
  \item{Scene}
  \item{Image}
  \item{Dynamic}
  \item{Mesh}
\end{itemize}

As these atomic types are the foundation of all other nodes, the system must
ensure, that they are initialized before all other nodes. Before being able to
create instances of atomic types, there must be classes defining them.

For identification of the atomic types, an enumerator is used. Python provides
the \verb+enum+ module, which provides a convenient interface for using
enumerations\footnote{https://docs.python.org/3/library/enum.html}.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap54}\raggedright\small
\NWtarget{nuweb43}{} $\langle\,${\itshape Node type declarations}\nobreak\ {\footnotesize {43}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeType(enum.Enum):@\\
\mbox{}\lstinline@    """Atomic types which a parameter may be made of."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    GENERIC  = 0@\\
\mbox{}\lstinline@    FLOAT    = 1@\\
\mbox{}\lstinline@    TEXT     = 2@\\
\mbox{}\lstinline@    SCENE    = 3@\\
\mbox{}\lstinline@    IMAGE    = 4@\\
\mbox{}\lstinline@    DYNAMIC  = 5@\\
\mbox{}\lstinline@    MESH     = 6@\\
\mbox{}\lstinline@    IMPLICIT = 7@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb92c}{92c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Now, having identifiers for the atomic types available, the atomic types
themselves can be implemented. The atomic types will be used for defining
various properties of a node and are therefore its parameters.

Each node may contain one or more parameters as inputs and at least one
parameter as output. Each parameter will lead back to its atomic type by
referencing the unique identifier of the atomic type. For being able to
distinguish multiple parameters using the same atomic type, it is necessary that
each instance of an atomic type has its own identifier in form of an instance
identifier (instance ID).

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap55}\raggedright\small
\NWtarget{nuweb44}{} $\langle\,${\itshape Parameter declarations}\nobreak\ {\footnotesize {44}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class AtomicType(object):@\\
\mbox{}\lstinline@    """Represents an atomic type and is the basis for each node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self, id_, type_):@\\
\mbox{}\lstinline@        """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param id_: the globally unique identifier of the atomic type.@\\
\mbox{}\lstinline@        :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@        :param type_: the type of the atomic type, e.g. "float".@\\
\mbox{}\lstinline@        :type  type_: types.NodeType@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        self.id_   = id_@\\
\mbox{}\lstinline@        self.type_ = type_@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb44}{44}\NWlink{nuweb45a}{, 45a}\NWlink{nuweb94}{, 94}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As the word atomic indicates, these types are atomic, meaning there only exists
one explicit instance per type, which is therefore static. As can be seen in
the code fragment below, the atomic types are parts of node definitions
themselves. Only the creation of the generict atomic type is shown, the rest is
omitted and can be found at~\todo{Add reference to code fragments.}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap56}\raggedright\small
\NWtarget{nuweb45a}{} $\langle\,${\itshape Parameter declarations}\nobreak\ {\footnotesize {45a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class AtomicTypes(object):@\\
\mbox{}\lstinline@    """Creates and holds all atomic types of the system."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @{\normalfont \fontfamily @}\lstinline@staticmethod@\\
\mbox{}\lstinline@    def create_node_definition_part(id_, type_):@\\
\mbox{}\lstinline@        """Creates a node definition part based on the given identifier and@\\
\mbox{}\lstinline@        type.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param id_: the identifiert to use for the part.@\\
\mbox{}\lstinline@        :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@        :param type_: the type of the part.@\\
\mbox{}\lstinline@        :tpye type_: qde.editor.domain.parameter.AtomicType@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a node definition part.@\\
\mbox{}\lstinline@        :rtype: qde.editor.domain.node.NodeDefinitionPart@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        def create_func(id_, default_function, name, type_):@\\
\mbox{}\lstinline@            node_part = node.NodePart(id_, default_function)@\\
\mbox{}\lstinline@            node_part.type_ = type_@\\
\mbox{}\lstinline@            node_part.name = name@\\
\mbox{}\lstinline@            return node_part@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        node_definition_part = node.NodeDefinitionPart(id_)@\\
\mbox{}\lstinline@        node_definition_part.type_ = type_@\\
\mbox{}\lstinline@        node_definition_part.creator_function = create_func@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return node_definition_part@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    Generic = create_node_definition_part.__func__(@\\
\mbox{}\lstinline@        id_="54b20acc-5867-4535-861e-f461bdbf3bf3",@\\
\mbox{}\lstinline@        type_=types.NodeType.GENERIC@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb44}{44}\NWlink{nuweb45a}{, 45a}\NWlink{nuweb94}{, 94}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Having the atomic types defined, nodes may now be defined.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap57}\raggedright\small
\NWtarget{nuweb45b}{} $\langle\,${\itshape Node domain model declarations}\nobreak\ {\footnotesize {45b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class Node(object):@\\
\mbox{}\lstinline@    """Represents a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node domain model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb46a}{46a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node domain model methods}\nobreak\ {\footnotesize \NWlink{nuweb48a}{48a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap58}\raggedright\small
\NWtarget{nuweb46a}{} $\langle\,${\itshape Node domain model constructor}\nobreak\ {\footnotesize {46a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, id_, name="New node"):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the globally unique identifier of the node.@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@    :param name: the name of the node.@\\
\mbox{}\lstinline@    :type  name: str@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.id_   = id_@\\
\mbox{}\lstinline@    self.name = name@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.definition = None@\\
\mbox{}\lstinline@    self.description = ""@\\
\mbox{}\lstinline@    self.parent = None@\\
\mbox{}\lstinline@    self.inupts = []@\\
\mbox{}\lstinline@    self.outputs = []@\\
\mbox{}\lstinline@    self.parts = []@\\
\mbox{}\lstinline@    self.nodes = []@\\
\mbox{}\lstinline@    self.connections = []@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb46a}{46a}\NWlink{nuweb49b}{, 49b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb45b}{45b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
While the details of a node are rather unclear at the moment, it is clear that
a node needs to have a view model, which renders a node within a scene of the
node graph.

As Qt does not offer a graph view by default, it is necessary to implement such
a graph view.

The most obvious choice for this implementation is the
\verb+QGraphicsView+ component, which displays the contents of a
\verb+QGraphicsScene+, whereas \verb+QGraphicsScene+ manages \verb+QGraphicsObject+
components.

It is therefore obvious to use the \verb+QGraphicsObject+ component
for representing graph nodes through a view model.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap59}\raggedright\small
\NWtarget{nuweb46b}{} $\langle\,${\itshape Node view model declarations}\nobreak\ {\footnotesize {46b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeViewModel(Qt.QGraphicsObject):@\\
\mbox{}\lstinline@    """Class representing a single node within GUI."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Constants@\\
\mbox{}\lstinline@    WIDTH = 20@\\
\mbox{}\lstinline@    HEIGHT = 17@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node view model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node view model constructor}\nobreak\ {\footnotesize \NWlink{nuweb47a}{47a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize \NWlink{nuweb47b}{47b}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98b}{98b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap60}\raggedright\small
\NWtarget{nuweb47a}{} $\langle\,${\itshape Node view model constructor}\nobreak\ {\footnotesize {47a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, id_, domain_object, parent=None):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the globally unique identifier of the atomic type.@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@    :param domain_object: Reference to a scene model.@\\
\mbox{}\lstinline@    :type  domain_object: qde.editor.domain.scene.SceneModel@\\
\mbox{}\lstinline@    :param parent: The parent of the current view widget.@\\
\mbox{}\lstinline@    :type parent:  QtCore.QObject@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    super(NodeViewModel, self).__init__(parent)@\\
\mbox{}\lstinline@    self.id_ = id_@\\
\mbox{}\lstinline@    self.domain_object = domain_object@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.position = QPoint(0, 0)@\\
\mbox{}\lstinline@    self.width = 4@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47a}{47a}\NWlink{nuweb48c}{, 48c}\NWlink{nuweb98c}{, 98c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
To distinguish nodes, the name and the type of a node is used. It makes sense to
access both attributes directly via the domain model instead of duplicating them.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap61}\raggedright\small
\NWtarget{nuweb47b}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {47b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@property@\\
\mbox{}\lstinline@def type_(self):@\\
\mbox{}\lstinline@    """Return the type of the node, determined by its domain model.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the type of the node.@\\
\mbox{}\lstinline@    :rtype: types.NodeType@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return self.domain_model.type_@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47b}{47b}\NWlink{nuweb47c}{c}\NWlink{nuweb48b}{, 48b}\NWlink{nuweb49a}{, 49a}\NWlink{nuweb49c}{c}\NWlink{nuweb100}{, 100}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap62}\raggedright\small
\NWtarget{nuweb47c}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {47c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@property@\\
\mbox{}\lstinline@def name(self):@\\
\mbox{}\lstinline@    """Return the name of the node, determined by its domain model.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the name of the node.@\\
\mbox{}\lstinline@    :rtype: str@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return self.domain_model.name@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47b}{47b}\NWlink{nuweb47c}{c}\NWlink{nuweb48b}{, 48b}\NWlink{nuweb49a}{, 49a}\NWlink{nuweb49c}{c}\NWlink{nuweb100}{, 100}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
However, the domain model does not provide access to its type at the moment. The
type is directly derived from the primary output of a node. If a node has no
outputs at all, its type is assumed to be generic.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap63}\raggedright\small
\NWtarget{nuweb48a}{} $\langle\,${\itshape Node domain model methods}\nobreak\ {\footnotesize {48a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @{\normalfont \fontfamily @}\lstinline@property@\\
\mbox{}\lstinline@    def type_(self):@\\
\mbox{}\lstinline@        """Return the type of the node, determined by its primary output.@\\
\mbox{}\lstinline@        If no primary output is given, it is assumed that the node is of@\\
\mbox{}\lstinline@        generic type."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        type_ = types.NodeType.GENERIC@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        if len(self.outputs) > 0:@\\
\mbox{}\lstinline@            type_ = self.outputs[0].type_@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return type_@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb45b}{45b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Concerning the drawing of nodes (or painting, as Qt calls it) , each node type
may be used multiple times. But instead of re-creating the same image
representation over and over again, it makes sense to create it only once per
node type. Qt provides \verb+QtPixmap+ and \verb+QtPixmapCache+ for this use case.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap64}\raggedright\small
\NWtarget{nuweb48b}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {48b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def paint(self, painter, option, widget):@\\
\mbox{}\lstinline@    """Paint the node.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    First a pixmap is loaded from cache if available, otherwise@\\
\mbox{}\lstinline@    a new pixmap gets created. If the current node is selected a@\\
\mbox{}\lstinline@    rectangle gets additionally drawn on it. Finally the name, the type@\\
\mbox{}\lstinline@    as well as the subtype gets written on the node.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize \NWlink{nuweb50a}{50a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47b}{47b}\NWlink{nuweb47c}{c}\NWlink{nuweb48b}{, 48b}\NWlink{nuweb49a}{, 49a}\NWlink{nuweb49c}{c}\NWlink{nuweb100}{, 100}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Each node has a cache key assigned, which is used to identify that node.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap65}\raggedright\small
\NWtarget{nuweb48c}{} $\langle\,${\itshape Node view model constructor}\nobreak\ {\footnotesize {48c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.cache_key = None@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47a}{47a}\NWlink{nuweb48c}{, 48c}\NWlink{nuweb98c}{, 98c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The cache key is composed of the type of the node, its status and whether it is
selected or not.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap66}\raggedright\small
\NWtarget{nuweb49a}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {49a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def create_cache_key(self):@\\
\mbox{}\lstinline@    """Create an attribute based cache key for finding and creating@\\
\mbox{}\lstinline@    pixmaps."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return "{type_name}{status}{selected}".format(@\\
\mbox{}\lstinline@        type_name=self.type_,@\\
\mbox{}\lstinline@        status=self.status,@\\
\mbox{}\lstinline@        selected=self.isSelected(),@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47b}{47b}\NWlink{nuweb47c}{c}\NWlink{nuweb48b}{, 48b}\NWlink{nuweb49a}{, 49a}\NWlink{nuweb49c}{c}\NWlink{nuweb100}{, 100}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As can be seen in the above code fragment, the status property of the node is
used to create a cache key, but currently nodes do not have a status.

It may make sense although to provide a status for each node, which allows to
output eventual problems like a node not having required connections and so on.

This status is added to the constructor of the domain model of a node.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap67}\raggedright\small
\NWtarget{nuweb49b}{} $\langle\,${\itshape Node domain model constructor}\nobreak\ {\footnotesize {49b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.status = flag.NodeStatus.OK@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb46a}{46a}\NWlink{nuweb49b}{, 49b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb45b}{45b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Concerning the view model, again the status of the domain model is used as
otherwise different states between user interface and domain model would be
possible in the worst case.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap68}\raggedright\small
\NWtarget{nuweb49c}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {49c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@property@\\
\mbox{}\lstinline@def status(self):@\\
\mbox{}\lstinline@    """Return the current status of the node.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the current status of the node.@\\
\mbox{}\lstinline@    :rtype: flag.NodeStatus@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return self.domain_object.status@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47b}{47b}\NWlink{nuweb47c}{c}\NWlink{nuweb48b}{, 48b}\NWlink{nuweb49a}{, 49a}\NWlink{nuweb49c}{c}\NWlink{nuweb100}{, 100}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Therefore it can now be checked, whether a node has a cache key or not. If it
has no cache key, a new cache key is created.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap69}\raggedright\small
\NWtarget{nuweb50a}{} $\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize {50a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if self.cache_key is None:@\\
\mbox{}\lstinline@        self.cache_key = self.create_cache_key()@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb50a}{50a}\NWlink{nuweb50b}{b}\NWlink{nuweb50c}{c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb48b}{48b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The cache key itself is then used to find a corresponding pixmap.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap70}\raggedright\small
\NWtarget{nuweb50b}{} $\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize {50b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    pixmap = Qt.QPixMapCache.find(self.cache_key)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb50a}{50a}\NWlink{nuweb50b}{b}\NWlink{nuweb50c}{c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb48b}{48b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
If no pixmap with the given cache key exists, a new pixmap is being created and
added to the cache using the cache key created before.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap71}\raggedright\small
\NWtarget{nuweb50c}{} $\langle\,${\itshape Node view model methods paint}\nobreak\ {\footnotesize {50c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if pixmap is None:@\\
\mbox{}\lstinline@        pixmap = self.create_pixmap()@\\
\mbox{}\lstinline@        Qt.QPixmapCache.insert(self.cache_key, pixmap)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb50a}{50a}\NWlink{nuweb50b}{b}\NWlink{nuweb50c}{c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb48b}{48b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
For actually displaying the nodes, another component is necessary: the scene
view which is a graph consisting the nodes and edges.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap72}\raggedright\small
\NWtarget{nuweb50d}{} $\langle\,${\itshape Scene view declarations}\nobreak\ {\footnotesize {50d}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@class SceneView(Qt.QGraphicsView):@\\
\mbox{}\lstinline@    """Scene view widget.@\\
\mbox{}\lstinline@    A widget for displaying and managing scenes including their nodes and@\\
\mbox{}\lstinline@    connections between nodes."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene view signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene view constructor}\nobreak\ {\footnotesize \NWlink{nuweb51a}{51a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene view methods}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene view slots}\nobreak\ {\footnotesize \NWlink{nuweb56c}{56c}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb90}{90}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap73}\raggedright\small
\NWtarget{nuweb51a}{} $\langle\,${\itshape Scene view constructor}\nobreak\ {\footnotesize {51a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, parent=None):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param parent: the parent of this scene view.@\\
\mbox{}\lstinline@    :type parent: Qt.QObject@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    super(SceneView, self).__init__(parent)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb50d}{50d}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The scene view can now be set up by the main window and is then added to its
vertical splitter.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap74}\raggedright\small
\NWtarget{nuweb51b}{} $\langle\,${\itshape Set up scene view in main window}\nobreak\ {\footnotesize {51b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.scene_view = guiscene.SceneView()@\\
\mbox{}\lstinline@self.scene_view.setObjectName('scene_view')@\\
\mbox{}\lstinline@size_policy = QtWidgets.QSizePolicy(@\\
\mbox{}\lstinline@    QtWidgets.QSizePolicy.Expanding,@\\
\mbox{}\lstinline@    QtWidgets.QSizePolicy.Expanding@\\
\mbox{}\lstinline@)@\\
\mbox{}\lstinline@size_policy.setHorizontalStretch(2)@\\
\mbox{}\lstinline@size_policy.setVerticalStretch(0)@\\
\mbox{}\lstinline@size_policy.setHeightForWidth(self.scene_view.sizePolicy().hasHeightForWidth())@\\
\mbox{}\lstinline@self.scene_view.setSizePolicy(size_policy)@\\
\mbox{}\lstinline@self.scene_view.setMinimumSize(Qt.QSize(0, 0))@\\
\mbox{}\lstinline@self.scene_view.setAutoFillBackground(False)@\\
\mbox{}\lstinline@self.scene_view.setFrameShape(QtWidgets.QFrame.StyledPanel)@\\
\mbox{}\lstinline@self.scene_view.setFrameShadow(QtWidgets.QFrame.Sunken)@\\
\mbox{}\lstinline@self.scene_view.setLineWidth(1)@\\
\mbox{}\lstinline@self.scene_view.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)@\\
\mbox{}\lstinline@self.scene_view.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)@\\
\mbox{}\lstinline@brush = QtGui.QBrush(Qt.QColor(0, 0, 0, 255))@\\
\mbox{}\lstinline@brush.setStyle(QtCore.Qt.NoBrush)@\\
\mbox{}\lstinline@self.scene_view.setBackgroundBrush(brush)@\\
\mbox{}\lstinline@self.scene_view.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)@\\
\mbox{}\lstinline@self.scene_view.setDragMode(QtWidgets.QGraphicsView.RubberBandDrag)@\\
\mbox{}\lstinline@self.scene_view.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)@\\
\mbox{}\lstinline@self.scene_view.setOptimizationFlags(QtWidgets.QGraphicsView.DontAdjustForAntialiasing)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap75}\raggedright\small
\NWtarget{nuweb51c}{} $\langle\,${\itshape Add scene view to vertical splitter in main window}\nobreak\ {\footnotesize {51c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@vertical_splitter.addWidget(self.scene_view)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb19}{19}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
At this point the scene view does not react whenever the scene is changed by the
scene graph view. As before, the main application needs connect the components.

As the scene graph view and the scene view have use both different view models,
it would not make much sense to connect them directly. Instead it makes sense to
connect the \verb+do_select_scene+ signal of the scene graph controller with the
\verb+on_scene_changed+ slot of the scene controller as they both use the
domain model of the scene.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap76}\raggedright\small
\NWtarget{nuweb52a}{} $\langle\,${\itshape Connect controllers for main application}\nobreak\ {\footnotesize {52a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@self.scene_graph_controller.do_select_scene.connect(@\\
\mbox{}\lstinline@    self.scene_controller.on_scene_changed@\\
\mbox{}\lstinline@)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb52a}{52a}\NWlink{nuweb52b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb17b}{17b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The scene controller does not manage scene models directly, as the scene graph
controller does. Instead it reacts on signals sent by the latter and manages
its own scene view models.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap77}\raggedright\small
\NWtarget{nuweb52b}{} $\langle\,${\itshape Connect controllers for main application}\nobreak\ {\footnotesize {52b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.scene_graph_controller.do_add_scene.connect(@\\
\mbox{}\lstinline@    self.scene_controller.on_scene_added@\\
\mbox{}\lstinline@)@\\
\mbox{}\lstinline@self.scene_graph_controller.do_remove_scene.connect(@\\
\mbox{}\lstinline@    self.scene_controller.on_scene_removed@\\
\mbox{}\lstinline@)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb52a}{52a}\NWlink{nuweb52b}{b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb17b}{17b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap78}\raggedright\small
\NWtarget{nuweb52c}{} $\langle\,${\itshape Scene controller declarations}\nobreak\ {\footnotesize {52c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@class SceneController(Qt.QObject):@\\
\mbox{}\lstinline@    """The scene controller.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    A controller for switching scenes and managing the nodes of a scene by@\\
\mbox{}\lstinline@    adding, editing and removing nodes to / from a scene.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene controller signals}\nobreak\ {\footnotesize \NWlink{nuweb55c}{55c}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene controller constructor}\nobreak\ {\footnotesize \NWlink{nuweb54b}{54b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene controller methods}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize \NWlink{nuweb55a}{55a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb89c}{89c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap79}\raggedright\small
\NWtarget{nuweb52d}{} $\langle\,${\itshape Set up controllers for main application}\nobreak\ {\footnotesize {52d}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.scene_controller = scene.SceneController(self)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb29b}{29b}\NWlink{nuweb52d}{, 52d}\NWlink{nuweb84b}{, 84b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb17b}{17b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The scene view models are of type \verb+QGraphicsScene+ and are used to manage
nodes. They represent a certain scene of the scene graph and hold the nodes of
that scene.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap80}\raggedright\small
\NWtarget{nuweb53a}{} $\langle\,${\itshape Scene view model declarations}\nobreak\ {\footnotesize {53a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@class SceneViewModel(Qt.QGraphicsScene):@\\
\mbox{}\lstinline@    """Scene view model.@\\
\mbox{}\lstinline@    Represents a certain scene from the scene graph and is used to manage the@\\
\mbox{}\lstinline@    nodes of that scene."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Constants@\\
\mbox{}\lstinline@    WIDTH = 15@\\
\mbox{}\lstinline@    HEIGHT = 15@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene view model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene view model constructor}\nobreak\ {\footnotesize \NWlink{nuweb53b}{53b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Scene view model methods}\nobreak\ {\footnotesize \NWlink{nuweb54a}{54a}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb88c}{88c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap81}\raggedright\small
\NWtarget{nuweb53b}{} $\langle\,${\itshape Scene view model constructor}\nobreak\ {\footnotesize {53b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, domain_object, parent=None):@\\
\mbox{}\lstinline@   """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@   :param domain_object: Reference to a scene model.@\\
\mbox{}\lstinline@   :type  domain_object: qde.editor.domain.scene.SceneModel@\\
\mbox{}\lstinline@   :param parent:        The parent of the current view model.@\\
\mbox{}\lstinline@   :type parent:         qde.editor.gui_domain.scene.SceneViewModel@\\
\mbox{}\lstinline@   """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@   super(SceneViewModel, self).__init__(parent)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@   self.id_ = domain_object.id_@\\
\mbox{}\lstinline@   self.nodes = []@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@   self.width = SceneViewModel.WIDTH * 20@\\
\mbox{}\lstinline@   self.height = SceneViewModel.HEIGHT * 17@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@   self.setSceneRect(0, 0, self.width, self.height)@\\
\mbox{}\lstinline@   self.setItemIndexMethod(self.NoIndex)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb53a}{53a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
For being able to distinguish different scenes, their identifier will be drawn
at the top left position.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap82}\raggedright\small
\NWtarget{nuweb54a}{} $\langle\,${\itshape Scene view model methods}\nobreak\ {\footnotesize {54a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@def drawBackground(self, painter, rect):@\\
\mbox{}\lstinline@    # io = Qt.QGraphicsTextItem()@\\
\mbox{}\lstinline@    # io.setPos(0, 0)@\\
\mbox{}\lstinline@    # io.setDefaultTextColor(Qt.QColor(102, 102, 102))@\\
\mbox{}\lstinline@    # io.setPlainText(@\\
\mbox{}\lstinline@    #     "Scene: {0}".format(str(self))@\\
\mbox{}\lstinline@    # )@\\
\mbox{}\lstinline@    # self.addItem(io)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    scene_rect = self.sceneRect()@\\
\mbox{}\lstinline@    text_rect = QtCore.QRectF(scene_rect.left()   + 4,@\\
\mbox{}\lstinline@                              scene_rect.top()    + 4,@\\
\mbox{}\lstinline@                              scene_rect.width()  - 4,@\\
\mbox{}\lstinline@                              scene_rect.height() - 4)@\\
\mbox{}\lstinline@    message = str(self)@\\
\mbox{}\lstinline@    font = painter.font()@\\
\mbox{}\lstinline@    font.setBold(True)@\\
\mbox{}\lstinline@    font.setPointSize(14)@\\
\mbox{}\lstinline@    painter.setFont(font)@\\
\mbox{}\lstinline@    painter.setPen(QtCore.Qt.lightGray)@\\
\mbox{}\lstinline@    painter.drawText(text_rect.translated(2, 2), message)@\\
\mbox{}\lstinline@    painter.setPen(QtCore.Qt.black)@\\
\mbox{}\lstinline@    painter.drawText(text_rect, message)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb54a}{54a}\NWlink{nuweb89b}{, 89b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb53a}{53a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As the scene controller does not directly manages scenes, it has to react upon
the signals sent by the scene graph controller.

Additionally it needs to keep track of the currently selected scene, by holding
a reference to that. The common identifier is the identifier of the domain
model.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap83}\raggedright\small
\NWtarget{nuweb54b}{} $\langle\,${\itshape Scene controller constructor}\nobreak\ {\footnotesize {54b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, parent):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param parent: the parent of this scene controller.@\\
\mbox{}\lstinline@    :type parent: Qt.QObject@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    super(SceneController, self).__init__(parent)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.scenes = {}@\\
\mbox{}\lstinline@    self.current_scene = None@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb52c}{52c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Whenever a new scene is created, the scene controller needs to create a scene of
type \verb+QGraphicsScene+ and needs to keep track of that scene.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap84}\raggedright\small
\NWtarget{nuweb55a}{} $\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize {55a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot(domain_scene.SceneModel)@\\
\mbox{}\lstinline@def on_scene_added(self, scene_domain_model):@\\
\mbox{}\lstinline@    """React when a scene was added.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param scene_domain_model: the scene that was added.@\\
\mbox{}\lstinline@    :type scene_domain_model:  qde.domain.scene.SceneModel@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if scene_domain_model.id_ not in self.scenes:@\\
\mbox{}\lstinline@        scene_view_model = guidomain_scene.SceneViewModel(@\\
\mbox{}\lstinline@            domain_object=scene_domain_model@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        self.scenes[scene_domain_model.id_] = scene_view_model@\\
\mbox{}\lstinline@        self.logger.debug("Scene '%s' was added" % scene_view_model)@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        self.logger.debug("Scene '%s' already known" % scene)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb55a}{55a}\NWlink{nuweb55b}{b}\NWlink{nuweb56a}{, 56a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb52c}{52c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Whenever a scene is deleted, it needs to delete the scene from its known scenes
as well.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap85}\raggedright\small
\NWtarget{nuweb55b}{} $\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize {55b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot(domain_scene.SceneModel)@\\
\mbox{}\lstinline@def on_scene_removed(self, scene_domain_model):@\\
\mbox{}\lstinline@    """React when a scene was removed/deleted.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param scene_domain_model: the scene that was removed.@\\
\mbox{}\lstinline@    :type scene_domain_model:  qde.domain.scene.SceneModel@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if scene_domain_model.id_ in self.scenes:@\\
\mbox{}\lstinline@        del(self.scenes[scene_domain_model.id_])@\\
\mbox{}\lstinline@        self.logger.debug("Scene '%s' was removed" % scene_domain_model)@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        self.logger.warn((@\\
\mbox{}\lstinline@            "Scene '%s' should be removed, "@\\
\mbox{}\lstinline@            "but is not known"@\\
\mbox{}\lstinline@        ) % scene_domain_model)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb55a}{55a}\NWlink{nuweb55b}{b}\NWlink{nuweb56a}{, 56a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb52c}{52c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
To actually change the scene, the scene controller needs to react whenever the
scene was changed. This happens by reacting to the \verb+do_select_scene+
signal sent by the scene graph controller.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap86}\raggedright\small
\NWtarget{nuweb55c}{} $\langle\,${\itshape Scene controller signals}\nobreak\ {\footnotesize {55c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@do_change_scene = QtCore.pyqtSignal(guidomain_scene.SceneViewModel)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb52c}{52c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap87}\raggedright\small
\NWtarget{nuweb56a}{} $\langle\,${\itshape Scene controller slots}\nobreak\ {\footnotesize {56a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot(domain_scene.SceneModel)@\\
\mbox{}\lstinline@def on_scene_changed(self, scene_domain_model):@\\
\mbox{}\lstinline@    """Gets triggered when the scene was changed by the view.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param scene_domain_model: The currently selected scene.@\\
\mbox{}\lstinline@    :type  scene_domain_model: qde.editor.domain.scene.SceneModel@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if scene_domain_model.id_ in self.scenes:@\\
\mbox{}\lstinline@        self.current_scene = self.scenes[scene_domain_model.id_]@\\
\mbox{}\lstinline@        self.do_change_scene.emit(self.current_scene)@\\
\mbox{}\lstinline@        self.logger.debug("Scene changed: %s", self.current_scene)@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        self.logger.warn((@\\
\mbox{}\lstinline@            "Should change to scene '%s', "@\\
\mbox{}\lstinline@            "but that scene is not known"@\\
\mbox{}\lstinline@        ) % scene_domain_model)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb55a}{55a}\NWlink{nuweb55b}{b}\NWlink{nuweb56a}{, 56a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb52c}{52c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As can be seen in the fragment above, the scene controller actually emits
another signal, \verb+do_change_scene+, which provides the view model of the
currently set scene.
The \verb+do_change_scene+ signal is then in turn consumed by the
\verb+on_scene_changed+ slot of the scene view for actually changing the
displayed scene.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap88}\raggedright\small
\NWtarget{nuweb56b}{} $\langle\,${\itshape Connect main window components}\nobreak\ {\footnotesize {56b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.scene_controller.do_change_scene.connect(@\\
\mbox{}\lstinline@    self.main_window.scene_view.on_scene_changed@\\
\mbox{}\lstinline@)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb17d}{17d}\NWlink{nuweb37a}{, 37a}\NWlink{nuweb56b}{, 56b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb17c}{17c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap89}\raggedright\small
\NWtarget{nuweb56c}{} $\langle\,${\itshape Scene view slots}\nobreak\ {\footnotesize {56c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@QtCore.pyqtSlot(scene.SceneViewModel)@\\
\mbox{}\lstinline@def on_scene_changed(self, scene_view_model):@\\
\mbox{}\lstinline@    # TODO: Document method@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.setScene(scene_view_model)@\\
\mbox{}\lstinline@    # TODO: self.scrollTo(scene_view_model.view_position)@\\
\mbox{}\lstinline@    self.scene().invalidate()@\\
\mbox{}\lstinline@    self.logger.debug("Scene has changed: %s", scene_view_model)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb50d}{50d}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
At this point scenes can be managed and displayed but they still cannot be
rendered as nodes cannot be added yet. First of all as there are no nodes yet
and second as there exists no possibility to add nodes.

Thinking of the definition of what shall be achieved, as defined at the
beginning of this chapter, a node defining a sphere is implemented.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap90}\raggedright\small
\NWtarget{nuweb57a}{} $\langle\,${\itshape Implicit sphere node}\nobreak\ {\footnotesize {57a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@{@\\
\mbox{}\lstinline@    "name": "Implicit sphere",@\\
\mbox{}\lstinline@    "id_": "16d90b34-a728-4caa-b07d-a3244ecc87e3",@\\
\mbox{}\lstinline@    "description": "Definition of a sphere by using implicit surfaces",@\\
\mbox{}\lstinline@    "inputs": [@\\
\mbox{}\lstinline@        @\hbox{$\langle\,${\itshape Implicit sphere node inputs}\nobreak\ {\footnotesize \NWlink{nuweb57b}{57b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    ],@\\
\mbox{}\lstinline@    "outputs": [@\\
\mbox{}\lstinline@        @\hbox{$\langle\,${\itshape Implicit sphere node outputs}\nobreak\ {\footnotesize \NWlink{nuweb57c}{57c}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    ],@\\
\mbox{}\lstinline@    "definitions": [@\\
\mbox{}\lstinline@        @\hbox{$\langle\,${\itshape Implicit sphere node definitions}\nobreak\ {\footnotesize \NWlink{nuweb58a}{58a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    ],@\\
\mbox{}\lstinline@    "invocations": [@\\
\mbox{}\lstinline@        @\hbox{$\langle\,${\itshape Implicit sphere node invocations}\nobreak\ {\footnotesize \NWlink{nuweb58b}{58b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    ],@\\
\mbox{}\lstinline@    "parts": [@\\
\mbox{}\lstinline@        @\hbox{$\langle\,${\itshape Implicit sphere node parts}\nobreak\ {\footnotesize \NWlink{nuweb59a}{59a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    ],@\\
\mbox{}\lstinline@    "nodes": [@\\
\mbox{}\lstinline@        @\hbox{$\langle\,${\itshape Implicit sphere node nodes}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    ],@\\
\mbox{}\lstinline@    "connections": [@\\
\mbox{}\lstinline@        @\hbox{$\langle\,${\itshape Implicit sphere node connections}\nobreak\ {\footnotesize \NWlink{nuweb59b}{59b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    ]@\\
\mbox{}\lstinline@}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb101a}{101a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
At the current point the sphere node will only have one input: the radius of
the sphere. The positition of the sphere will be at the center (meaning the
X-, the Y- and the Z-position are all 0). For being able to change the
positition, another node will be introduced.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap91}\raggedright\small
\NWtarget{nuweb57b}{} $\langle\,${\itshape Implicit sphere node inputs}\nobreak\ {\footnotesize {57b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@{@\\
\mbox{}\lstinline@    "name": "radius",@\\
\mbox{}\lstinline@    "atomic_id": "468aea9e-0a03-4e63-b6b4-8a7a76775a1a",@\\
\mbox{}\lstinline@    "default_value": {@\\
\mbox{}\lstinline@        "type_": "float",@\\
\mbox{}\lstinline@        "value": "1"@\\
\mbox{}\lstinline@    },@\\
\mbox{}\lstinline@    "id_": "f5c6a538-1dbc-4add-a15d-ddc4a5e553da",@\\
\mbox{}\lstinline@    "description": "The radius of the sphere",@\\
\mbox{}\lstinline@    "min_value": "-1000",@\\
\mbox{}\lstinline@    "max_value": "1000"@\\
\mbox{}\lstinline@}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb57a}{57a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The output of the sphere node is of type implicit as the node represents an
implicit surface.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap92}\raggedright\small
\NWtarget{nuweb57c}{} $\langle\,${\itshape Implicit sphere node outputs}\nobreak\ {\footnotesize {57c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@{@\\
\mbox{}\lstinline@    "name": "output",@\\
\mbox{}\lstinline@    "id_": "a3ac68e5-5afe-4779-9e9f-5b619e041ae6",@\\
\mbox{}\lstinline@    "atomic_id": "c019271c-35b6-425c-9ff2-a1d893111adb"@\\
\mbox{}\lstinline@}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb57a}{57a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The definition of the node is the actual implementation of a sphere as a
implicit surface.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap93}\raggedright\small
\NWtarget{nuweb58a}{} $\langle\,${\itshape Implicit sphere node definitions}\nobreak\ {\footnotesize {58a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@{@\\
\mbox{}\lstinline@    "id_": "99d20a26-f233-4310-adb2-5e540726d079",@\\
\mbox{}\lstinline@    "script": [@\\
\mbox{}\lstinline@        "// Returns the signed distance to a sphere with given radius for the",@\\
\mbox{}\lstinline@        "// given position.",@\\
\mbox{}\lstinline@        "float sphere(vec3 position, float radius)",@\\
\mbox{}\lstinline@        "{",@\\
\mbox{}\lstinline@        "    return length(position) - radius;",@\\
\mbox{}\lstinline@        "}"@\\
\mbox{}\lstinline@    ]@\\
\mbox{}\lstinline@}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb57a}{57a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The invocation of the node is simply calling the above definition using the
parameters of the node, which is in this case the radius.

The parameters are in case of implicit surfaces uniform variables of the type
of the parameter, as implicit surfaces are rendered by the fragment shader. The
uniform variables are defined by a type and an identifier, whereas in the case
of paramaters their identifier is used.

The position of the node is an indirect parameter, which is not defined by the
node's inputs. It will be setup by the node's parts.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap94}\raggedright\small
\NWtarget{nuweb58b}{} $\langle\,${\itshape Implicit sphere node invocations}\nobreak\ {\footnotesize {58b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@{@\\
\mbox{}\lstinline@    "id_": "4cd369d2-c245-49d8-9388-6b9387af8376",@\\
\mbox{}\lstinline@    "type": "implicit",@\\
\mbox{}\lstinline@    "script": [@\\
\mbox{}\lstinline@        "float s = sphere(",@\\
\mbox{}\lstinline@        "    16d90b34-a728-4caa-b07d-a3244ecc87e3-position,",@\\
\mbox{}\lstinline@        "    5c6a538-1dbc-4add-a15d-ddc4a5e553da",@\\
\mbox{}\lstinline@        ");"@\\
\mbox{}\lstinline@    ]@\\
\mbox{}\lstinline@}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb57a}{57a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The parts of the node, in this case it is only one part, contain the body of
the node. The body is about evaluating the inputs and passing them on to a
shader.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap95}\raggedright\small
\NWtarget{nuweb59a}{} $\langle\,${\itshape Implicit sphere node parts}\nobreak\ {\footnotesize {59a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@{@\\
\mbox{}\lstinline@    "id_": "74b73ce7-8c9d-4202-a533-c77aba9035a6",@\\
\mbox{}\lstinline@    "name": "Implicit sphere node function",@\\
\mbox{}\lstinline@    "type_": "implicit",@\\
\mbox{}\lstinline@    "script": [@\\
\mbox{}\lstinline@        "# -*- coding: utf-8 -*-",@\\
\mbox{}\lstinline@        "",@\\
\mbox{}\lstinline@        "from PyQt5 import QtGui",@\\
\mbox{}\lstinline@        "",@\\
\mbox{}\lstinline@        "",@\\
\mbox{}\lstinline@        "class Class_ImplicitSphere(object):",@\\
\mbox{}\lstinline@        "    def __init__(self):",@\\
\mbox{}\lstinline@        "        self.position = QtGui.QVector3D()",@\\
\mbox{}\lstinline@        "",@\\
\mbox{}\lstinline@        "    def process(self, context, inputs):",@\\
\mbox{}\lstinline@        "        shader = context.current_shader.program",@\\
\mbox{}\lstinline@        "        ",@\\
\mbox{}\lstinline@        "        radius = inputs[0].process(context).value",@\\
\mbox{}\lstinline@        "        shader_radius_location = shader.uniformLocation(\"f5c6a538-1dbc-4add-a15d-ddc4a5e553da\")",@\\
\mbox{}\lstinline@        "        shader.setUniformValue(shader_radius_location, radius)",@\\
\mbox{}\lstinline@        "        ",@\\
\mbox{}\lstinline@        "        position = self.position",@\\
\mbox{}\lstinline@        "        shader_position_location = shader.uniformLocation(",@\\
\mbox{}\lstinline@        "            \"16d90b34-a728-4caa-b07d-a3244ecc87e3-position\"",@\\
\mbox{}\lstinline@        "        )",@\\
\mbox{}\lstinline@        "        shader.setUniformValue(shader_position_location, position)",@\\
\mbox{}\lstinline@        "        ",@\\
\mbox{}\lstinline@        "        return context"@\\
\mbox{}\lstinline@    ]@\\
\mbox{}\lstinline@}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb57a}{57a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Connections are composed of an input and an output plus a reference to a part,
as stated in \todo{Add reference}. In this case there is exactly one input, the
radius, and one output, an object defined by implicit functions.

The radius is being defined by an input, which is therefore being referenced as
source. There is although no external node being referenced, as the radius is
of the atomic type float. Therefore the source node is 0, meaning it is an
internal reference. The input itself is used as part for the input. 

The very same applies for the output of that connection. The radius is being
consumed by the first part of the node's part (which has only this part). As
this definition is within the same node, the target node is also 0. The part is
then being referenced by its identifier.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap96}\raggedright\small
\NWtarget{nuweb59b}{} $\langle\,${\itshape Implicit sphere node connections}\nobreak\ {\footnotesize {59b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@{@\\
\mbox{}\lstinline@    "source_node": "00000000-0000-0000-0000-000000000000",@\\
\mbox{}\lstinline@    "source_part": "f5c6a538-1dbc-4add-a15d-ddc4a5e553da",@\\
\mbox{}\lstinline@    "target_node": "00000000-0000-0000-0000-000000000000",@\\
\mbox{}\lstinline@    "target_part": "74b73ce7-8c9d-4202-a533-c77aba9035a6"@\\
\mbox{}\lstinline@}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb57a}{57a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Now a very basic node is avaialble, but the node does not get recognized by the
application yet. As nodes are defined by external files, they need to be
searched, loaded and registered to make them available to the application.

Therefore the node controller is introduced, which will manage the node
definitions.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap97}\raggedright\small
\NWtarget{nuweb60a}{} $\langle\,${\itshape Node controller declarations}\nobreak\ {\footnotesize {60a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@class NodeController(object):@\\
\mbox{}\lstinline@    """The node controller.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    A controller managing nodes.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Constants@\\
\mbox{}\lstinline@    NODES_PATH = "nodes"@\\
\mbox{}\lstinline@    NODES_EXTENSION = "node"@\\
\mbox{}\lstinline@    ROOT_NODE_ID = uuid.UUID("026c04d0-36d2-49d5-ad15-f4fb87fe8eeb")@\\
\mbox{}\lstinline@    ROOT_NODE_OUTPUT_ID = uuid.UUID("a8fadcfc-4e19-4862-90cf-a262eef2219b")@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node controller signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize \NWlink{nuweb60b}{60b}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize \NWlink{nuweb60c}{60c}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node controller slots}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb101b}{101b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The node controller assumes, that all node definitions are placed within the
\verb+nodes+ subdirectory of the application's working directory. Further it
assumes, that node definition files use the \verb+node+ extension.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap98}\raggedright\small
\NWtarget{nuweb60b}{} $\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize {60b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self):@\\
\mbox{}\lstinline@    """ Constructor. """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.nodes_path = "{current_dir}{sep}{nodes_path}".format(@\\
\mbox{}\lstinline@        current_dir=os.getcwd(),@\\
\mbox{}\lstinline@        sep=os.sep,@\\
\mbox{}\lstinline@        nodes_path=NodeController.NODES_PATH@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    self.nodes_extension = NodeController.NODES_EXTENSION@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb60b}{60b}\NWlink{nuweb61c}{, 61c}\NWlink{nuweb68b}{, 68b}\NWlink{nuweb82}{, 82}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60a}{60a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The node controller will then scan that directory containing the node
definitions and load each one.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap99}\raggedright\small
\NWtarget{nuweb60c}{} $\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize {60c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def load_nodes(self):@\\
\mbox{}\lstinline@    """Loads all files with the ending NodeController.NODES_EXTENSION@\\
\mbox{}\lstinline@    within the NodeController.NODES_PATH directory, relative to the current@\\
\mbox{}\lstinline@    working directory.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node controller load nodes method}\nobreak\ {\footnotesize \NWlink{nuweb67a}{67a}, \ldots\ }$\,\rangle$}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb60c}{60c}\NWlink{nuweb70}{, 70}\NWlink{nuweb73}{, 73}\NWlink{nuweb81}{, 81}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60a}{60a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Node definitons will contain parts. The parts within node definition are
used to create corresponding parts within instances of themselves. The parts
are able to create values based on the atomic types through functions.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap100}\raggedright\small
\NWtarget{nuweb61a}{} $\langle\,${\itshape Node definition part domain model declarations}\nobreak\ {\footnotesize {61a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeDefinitionPart(object):@\\
\mbox{}\lstinline@    """Represents a part of the definition of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition part domain model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition part domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb61b}{61b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition part domain model methods}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The part of a node definition holds an identifier as well as an expression to
create a function for creating and handling values which will be used when
evaluating a node. Further it provides a function which allows to instantiate
itself as part of a node (instance).

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap101}\raggedright\small
\NWtarget{nuweb61b}{} $\langle\,${\itshape Node definition part domain model constructor}\nobreak\ {\footnotesize {61b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, id_):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the globally unique identifier of the part of the node@\\
\mbox{}\lstinline@                definition.@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.id_    = id_@\\
\mbox{}\lstinline@    self.type_  = None@\\
\mbox{}\lstinline@    self.name   = None@\\
\mbox{}\lstinline@    self.parent = None@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # This property is used when evaluating node instances using this node@\\
\mbox{}\lstinline@    # definition@\\
\mbox{}\lstinline@    self.function_creator = lambda: create_value_function(@\\
\mbox{}\lstinline@        parameter.FloatValue(0)@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # This property will be used to create/instantiate a part of a node@\\
\mbox{}\lstinline@    # instance@\\
\mbox{}\lstinline@    self.creator_function = None@\\
\mbox{}\lstinline@    @{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb61a}{61a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The node controller needs to keep track of node defintion parts, as they are a
central aspect and may be reused.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap102}\raggedright\small
\NWtarget{nuweb61c}{} $\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize {61c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.node_definition_parts = {}@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb60b}{60b}\NWlink{nuweb61c}{, 61c}\NWlink{nuweb68b}{, 68b}\NWlink{nuweb82}{, 82}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60a}{60a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The code snippet defining the constructor of a node definition part uses a
function called \verb+create_value_function+ of the \verb+functions+ module.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap103}\raggedright\small
\NWtarget{nuweb62}{} $\langle\,${\itshape Node domain module methods}\nobreak\ {\footnotesize {62}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def create_value_function(value):@\\
\mbox{}\lstinline@    """Creates a new value function using the provided value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param value: the value which the function shall have.@\\
\mbox{}\lstinline@    :type  value: qde.editor.domain.parameter.Value@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    value_function = NodePart.ValueFunction()@\\
\mbox{}\lstinline@    value_function.value = value.clone()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return value_function@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb62}{62}\NWlink{nuweb78a}{, 78a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
That brings up the concept of value functions. Value functions are one of the
building blocks of a node. They are used to evaluate a node value-wise through
its inputs.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap104}\raggedright\small
\NWtarget{nuweb63}{} $\langle\,${\itshape Node part domain model value function declarations}\nobreak\ {\footnotesize {63}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class ValueFunction(Function):@\\
\mbox{}\lstinline@    """Class representing a value function for nodes."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(NodePart.ValueFunction, self).__init__()@\\
\mbox{}\lstinline@        self.value = None@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value function.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value function.@\\
\mbox{}\lstinline@        :rtype: qde.editor.domain.node.NodePart.Function@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        new_function = create_value_function(self.value)@\\
\mbox{}\lstinline@        new_function.node_part = self.node_part@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return new_function@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def process(self, context, inputs, output_index):@\\
\mbox{}\lstinline@        """Processes the value function for the given context, the given inputs@\\
\mbox{}\lstinline@        and the given index of the output.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param context: the context of the processing@\\
\mbox{}\lstinline@        :type  context: qde.editor.domain.node.NodePartContext@\\
\mbox{}\lstinline@        :param inputs: a list of inputs to process@\\
\mbox{}\lstinline@        :type inputs: list@\\
\mbox{}\lstinline@        :param output_index: the index of the output which shall be used@\\
\mbox{}\lstinline@        :type output_index: int@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: the context@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.node.NodePartContext@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        if not self.value.is_cachable or self.has_changed:@\\
\mbox{}\lstinline@            if len(inputs) > 0:@\\
\mbox{}\lstinline@                inputs[0].process(context, self.processing_index)@\\
\mbox{}\lstinline@                value.set_value_from_context(context)@\\
\mbox{}\lstinline@            else:@\\
\mbox{}\lstinline@                self.value.set_value_in_context(context)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@            self.has_changed = False@\\
\mbox{}\lstinline@        else:@\\
\mbox{}\lstinline@            self.value.set_value_in_context(context)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        # TODO: Handle events@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return context@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb65a}{65a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
During the initialization of a node, its value function may not be clear or it
is simply subject to change. Therefore it makes sense to provide a default
value function which gets used by default.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap105}\raggedright\small
\NWtarget{nuweb64}{} $\langle\,${\itshape Node part domain model default value function declarations}\nobreak\ {\footnotesize {64}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class DefaultValueFunction(ValueFunction):@\\
\mbox{}\lstinline@    """The default value function of a node part."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(NodePart.DefaultValueFunction, self).__init__()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Returns itself as a default value function may not be cloned.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a self-reference.@\\
\mbox{}\lstinline@        :rtype: DefaultValueFunction@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return self@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def process(self, context, inputs, output_index):@\\
\mbox{}\lstinline@        """Processes the default value function for the given context, the given inputs@\\
\mbox{}\lstinline@        and the given index of the output.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param context: the context of the processing@\\
\mbox{}\lstinline@        :type  context: qde.editor.domain.node.NodePartContext@\\
\mbox{}\lstinline@        :param inputs: a list of inputs to process@\\
\mbox{}\lstinline@        :type inputs: list@\\
\mbox{}\lstinline@        :param output_index: the index of the output which shall be used@\\
\mbox{}\lstinline@        :type output_index: int@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: the context@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.node.NodePartContext@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        self.value.set_value_in_context(context)@\\
\mbox{}\lstinline@        self.has_changed = False@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return context@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb65a}{65a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The value function relies strongly on the conecpt of node parts, which is not
defined yet. A part of a node is actually an instance of an atomic type
(which is usually an input) within an instance of a node definition.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap106}\raggedright\small
\NWtarget{nuweb65a}{} $\langle\,${\itshape Node part domain model declarations}\nobreak\ {\footnotesize {65a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodePart(object):@\\
\mbox{}\lstinline@    """Represents a part of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node part domain model function declarations}\nobreak\ {\footnotesize \NWlink{nuweb66a}{66a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node part domain model value function declarations}\nobreak\ {\footnotesize \NWlink{nuweb63}{63}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node part domain model default value function declarations}\nobreak\ {\footnotesize \NWlink{nuweb64}{64}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node part domain model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node part domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb65b}{65b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node part domain model methods}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap107}\raggedright\small
\NWtarget{nuweb65b}{} $\langle\,${\itshape Node part domain model constructor}\nobreak\ {\footnotesize {65b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, id_, default_function):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the identifier of the node part.@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@    :param default_function: the default function of the part@\\
\mbox{}\lstinline@    :type default_function: Function@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.id_              = id_@\\
\mbox{}\lstinline@    self.function_        = default_function@\\
\mbox{}\lstinline@    self.default_function = default_function@\\
\mbox{}\lstinline@    self.type_            = types.NodeType.GENERIC@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb65a}{65a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
A part of a node has a function, which gets called whenever a part of a node is
being processed.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap108}\raggedright\small
\NWtarget{nuweb66a}{} $\langle\,${\itshape Node part domain model function declarations}\nobreak\ {\footnotesize {66a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class Function(object):@\\
\mbox{}\lstinline@    """Represents the function of a part of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        self.has_changed = True@\\
\mbox{}\lstinline@        self.evaluation_index = 0@\\
\mbox{}\lstinline@        self.changed_state = types.StateChange.VALUE.value | types.StateChange.SUBTREE.value@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set function."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        message = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@            __class__.__name__,@\\
\mbox{}\lstinline@            "This method must be implemented in a child class"@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        raise NotImplementedError(message)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def process(self, context, inputs, output_index):@\\
\mbox{}\lstinline@        """Processes the value function for the given context, the given@\\
\mbox{}\lstinline@        inputs."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        message = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@            __class__.__name__,@\\
\mbox{}\lstinline@            "This method must be implemented in a child class"@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        raise NotImplementedError(message)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb65a}{65a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
When a part of a node is being processed, also its inputs are processed.
Whenever an input (value) changes, the node part needs to handle the changes.
There are three possible types of changes: nothing has changed, the value (of
the function) has changed or the subtree (inputs) has changed.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap109}\raggedright\small
\NWtarget{nuweb66b}{} $\langle\,${\itshape Node part state changed declarations}\nobreak\ {\footnotesize {66b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class StateChange(enum.Enum):@\\
\mbox{}\lstinline@    """Possible changes of state."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    NOTHING  = 0@\\
\mbox{}\lstinline@    VALUE    = 1@\\
\mbox{}\lstinline@    SUBTREE  = 2@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb92c}{92c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
At the end, all (end-) nodes will be composed of parts of atomic type.
When building the node definition from the JSON input, the (atomic) part of the
node definition is fetched from the node controller. Therefore it is necessary
to provide parts for the atomic types before loading all the node definitions.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap110}\raggedright\small
\NWtarget{nuweb67a}{} $\langle\,${\itshape Node controller load nodes method}\nobreak\ {\footnotesize {67a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@for atomic_type in parameter.AtomicTypes.atomic_types:@\\
\mbox{}\lstinline@    if atomic_type.id_ not in self.node_definition_parts:@\\
\mbox{}\lstinline@        self.node_definition_parts[atomic_type.id_] = atomic_type@\\
\mbox{}\lstinline@        self.logger.info(@\\
\mbox{}\lstinline@            "Added atomic type %s: %s",@\\
\mbox{}\lstinline@            atomic_type.type_, atomic_type.id_@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        self.logger.warn((@\\
\mbox{}\lstinline@            "Already knowing node part for atomic type %s. This should not"@\\
\mbox{}\lstinline@            "happen"@\\
\mbox{}\lstinline@        ), atomic_type.type_)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb67a}{67a}\NWlink{nuweb69}{, 69}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60c}{60c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Having the atomic types avaialble as parts, the node definitions themselves may
be loaded. There is only one problem to that: there is nothing to hold the
node defintions. Therefore the node definition domain model is introduced.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap111}\raggedright\small
\NWtarget{nuweb67b}{} $\langle\,${\itshape Node definition domain model declarations}\nobreak\ {\footnotesize {67b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeDefinition(object):@\\
\mbox{}\lstinline@    """Represents the definition of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition domain model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb68a}{68a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition domain model methods}\nobreak\ {\footnotesize \NWlink{nuweb83}{83}}$\,\rangle$}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The definition of a node is quite similar to a node itself. As the definiton of
a node may be changed, the flag \verb+was_changed+ is added. Further a node
definition holds all instances of itself, meaning nodes.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap112}\raggedright\small
\NWtarget{nuweb68a}{} $\langle\,${\itshape Node definition domain model constructor}\nobreak\ {\footnotesize {68a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, id_):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the globally unique identifier of the node.@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.id_         = id_@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.name        = ""@\\
\mbox{}\lstinline@    self.description = ""@\\
\mbox{}\lstinline@    self.parent      = None@\\
\mbox{}\lstinline@    self.inupts      = []@\\
\mbox{}\lstinline@    self.outputs     = []@\\
\mbox{}\lstinline@    self.definitions = []@\\
\mbox{}\lstinline@    self.invocations = []@\\
\mbox{}\lstinline@    self.parts       = []@\\
\mbox{}\lstinline@    self.nodes       = []@\\
\mbox{}\lstinline@    self.connections = []@\\
\mbox{}\lstinline@    self.instances   = []@\\
\mbox{}\lstinline@    self.was_changed = False@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb67b}{67b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Now the controller is able to instantiate nodes definitions and keep them in a
list.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap113}\raggedright\small
\NWtarget{nuweb68b}{} $\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize {68b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@    self.node_definitions = {}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb60b}{60b}\NWlink{nuweb61c}{, 61c}\NWlink{nuweb68b}{, 68b}\NWlink{nuweb82}{, 82}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60a}{60a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The controller scans the \verb+node+ subdirectory, containing the node
definitions, for files ending in \verb+node+.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap114}\raggedright\small
\NWtarget{nuweb69}{} $\langle\,${\itshape Node controller load nodes method}\nobreak\ {\footnotesize {69}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@if os.path.exists(self.nodes_path):@\\
\mbox{}\lstinline@    node_definition_files = glob.glob("{path}{sep}*.{ext}".format(@\\
\mbox{}\lstinline@        path=self.nodes_path,@\\
\mbox{}\lstinline@        sep=os.sep,@\\
\mbox{}\lstinline@        ext=self.nodes_extension@\\
\mbox{}\lstinline@    ))@\\
\mbox{}\lstinline@    num_node_definitions = len(node_definition_files)@\\
\mbox{}\lstinline@    if num_node_definitions > 0:@\\
\mbox{}\lstinline@        self.logger.info(@\\
\mbox{}\lstinline@            "Found %d node definition(s), loading.",@\\
\mbox{}\lstinline@            num_node_definitions@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        t0 = time.perf_counter()@\\
\mbox{}\lstinline@        for file_name in node_definition_files:@\\
\mbox{}\lstinline@            self.logger.debug(@\\
\mbox{}\lstinline@                "Found node definition %s, trying to load",@\\
\mbox{}\lstinline@                file_name@\\
\mbox{}\lstinline@            )@\\
\mbox{}\lstinline@            node_definition = self.load_node_definition_from_file_name(file_name)@\\
\mbox{}\lstinline@            if node_definition is not None:@\\
\mbox{}\lstinline@                self.node_definitions[node_definition.id_] = node_definition@\\
\mbox{}\lstinline@        t1 = time.perf_counter()@\\
\mbox{}\lstinline@        self.logger.info(@\\
\mbox{}\lstinline@            "Loading node definitions took %.10f seconds",@\\
\mbox{}\lstinline@            (t1 - t0)@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        message = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@            __class__.__name__, "No node definitions found."@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        self.logger.warn(message)@\\
\mbox{}\lstinline@else:@\\
\mbox{}\lstinline@    message = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@        __class__.__name__, "No node definitions found."@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    self.logger.warn(message)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb67a}{67a}\NWlink{nuweb69}{, 69}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60c}{60c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
If such a file is found, its identifier is extracted from the file name. If the
node definition is not known yet, it gets loaded and added to the list of known
node definitions.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap115}\raggedright\small
\NWtarget{nuweb70}{} $\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize {70}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def load_node_definition_from_file_name(self, file_name):@\\
\mbox{}\lstinline@    """Loads a node definition from the given file name.@\\
\mbox{}\lstinline@    If no such file exists, an FileNotFoundError is raised.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param file_name: the file name to load.@\\
\mbox{}\lstinline@    :type  file_name: str@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the loaded node definition and its identifier or None@\\
\mbox{}\lstinline@    :rtype:  qde.editor.domain.node.NodeDefinition or None@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if not os.path.exists(file_name):@\\
\mbox{}\lstinline@        self.logger.warn((@\\
\mbox{}\lstinline@            "Tried to load node defintion from file %s, "@\\
\mbox{}\lstinline@            "but the file does not exist"@\\
\mbox{}\lstinline@        ), file_name)@\\
\mbox{}\lstinline@        return None@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Extract the defintion identifier from the file name, which is@\\
\mbox{}\lstinline@    # "uuid4.node".@\\
\mbox{}\lstinline@    definition_id = os.path.splitext(os.path.basename(file_name))[0]@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if definition_id in self.node_definitions:@\\
\mbox{}\lstinline@        self.logger.warn(@\\
\mbox{}\lstinline@            "Should load node definition from file %s, but is already loaded",@\\
\mbox{}\lstinline@            file_name@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        return self.node_definitions[definition_id]@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    try:@\\
\mbox{}\lstinline@        with open(file_name) as definition_fh:@\\
\mbox{}\lstinline@            node_definition = json.Json.load_node_definition(@\\
\mbox{}\lstinline@                self, definition_fh@\\
\mbox{}\lstinline@            )@\\
\mbox{}\lstinline@            self.logger.debug(@\\
\mbox{}\lstinline@                "Loaded node definition %s from file %s",@\\
\mbox{}\lstinline@                definition_id, file_name@\\
\mbox{}\lstinline@            )@\\
\mbox{}\lstinline@            # TODO: Trigger (loading) callback@\\
\mbox{}\lstinline@            return node_definition@\\
\mbox{}\lstinline@    except json.json.decoder.JSONDecodeError as exc:@\\
\mbox{}\lstinline@        self.logger.warn(@\\
\mbox{}\lstinline@            "There was an error loading the node definition %s: %s",@\\
\mbox{}\lstinline@            definition_id, exc@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        return None@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb60c}{60c}\NWlink{nuweb70}{, 70}\NWlink{nuweb73}{, 73}\NWlink{nuweb81}{, 81}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60a}{60a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The loading of the node definiton is simply about parsing the various sections
and handling them correspondingly. To prevent the node controller from being
bloated, the parsing is done in a separate module responsible for JSON specific
tasks.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap116}\raggedright\small
\NWtarget{nuweb71}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {71}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@classmethod@\\
\mbox{}\lstinline@def load_node_definition(cls, node_controller, json_file_handle):@\\
\mbox{}\lstinline@    """Loads a node definition from given JSON input.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param node_controller: reference to the node controller@\\
\mbox{}\lstinline@    :type node_controller: qde.editor.application.node.NodeController@\\
\mbox{}\lstinline@    :param json_file_handle: an open file handle containing JSON data@\\
\mbox{}\lstinline@    :type json_file_handle: file@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: a node definition@\\
\mbox{}\lstinline@    :rtype: qde.editor.domain.node.NodeDefinition@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    o = json.load(json_file_handle)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    name        = str(o['name'])@\\
\mbox{}\lstinline@    id_         = uuid.UUID(o['id_'])@\\
\mbox{}\lstinline@    description = str(o['description'])@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    inputs = []@\\
\mbox{}\lstinline@    for input in o['inputs']:@\\
\mbox{}\lstinline@        node_definition_input = cls.build_node_definition_input(@\\
\mbox{}\lstinline@            node_controller, input@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        inputs.append(node_definition_input)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    outputs = []@\\
\mbox{}\lstinline@    for output in o['outputs']:@\\
\mbox{}\lstinline@        node_definition_output = cls.build_node_definition_output(@\\
\mbox{}\lstinline@            node_controller, output@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        outputs.append(node_definition_output)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_definitions = {}@\\
\mbox{}\lstinline@    for node_def in o['nodes']:@\\
\mbox{}\lstinline@        definition_id, node_definition = cls.build_node_definition(node_def)@\\
\mbox{}\lstinline@        node_definitions[definition_id] = node_definition@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    connections = []@\\
\mbox{}\lstinline@    for conn in o['connections']:@\\
\mbox{}\lstinline@        connection = cls.build_node_definition_connection(conn)@\\
\mbox{}\lstinline@        connections.append(connection)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    definitions = []@\\
\mbox{}\lstinline@    for d in o['definitions']:@\\
\mbox{}\lstinline@        definition = cls.build_node_definition_definition(d)@\\
\mbox{}\lstinline@        definitions.append(definition)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    invocations = []@\\
\mbox{}\lstinline@    for i in o['invocations']:@\\
\mbox{}\lstinline@        invocation = cls.build_node_definition_invocation(i)@\\
\mbox{}\lstinline@        invocations.append(invocation)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_definition             = node.NodeDefinition(id_)@\\
\mbox{}\lstinline@    node_definition.name        = name@\\
\mbox{}\lstinline@    node_definition.description = description@\\
\mbox{}\lstinline@    node_definition.inputs      = inputs@\\
\mbox{}\lstinline@    node_definition.outputs     = outputs@\\
\mbox{}\lstinline@    node_definition.nodes       = node_definitions@\\
\mbox{}\lstinline@    node_definition.connections = connections@\\
\mbox{}\lstinline@    node_definition.definitions = definitions@\\
\mbox{}\lstinline@    node_definition.invocations = invocations@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # TODO: Check if this part can be abve the def. instance@\\
\mbox{}\lstinline@    parts = []@\\
\mbox{}\lstinline@    for p in o['parts']:@\\
\mbox{}\lstinline@        part = cls.build_node_definition_part(node_controller, node_definition, p)@\\
\mbox{}\lstinline@        parts.append(part)@\\
\mbox{}\lstinline@    node_definition.parts = parts@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # TODO: Do a consistency check@\\
\mbox{}\lstinline@    node_definition.was_changed = False@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return node_definition@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb71}{71}\NWlink{nuweb72}{, 72}\NWlink{nuweb78b}{, 78b}\NWlink{nuweb80}{, 80}\NWlink{nuweb84a}{, 84a}\NWlink{nuweb103a}{, 103a}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb105}{, 105}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb102a}{102a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As can be seen in the above listing, there are parts, that are not yet defined:
inputs, outputs, other node definitions, connections, definitions, invocations
and parts.

First the building of the node definition inputs is defined.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap117}\raggedright\small
\NWtarget{nuweb72}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {72}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@classmethod@\\
\mbox{}\lstinline@def build_node_definition_input(cls, node_controller, json_input):@\\
\mbox{}\lstinline@    """Builds and returns a node definition input from the given JSON input@\\
\mbox{}\lstinline@    data.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param node_controller: a reference to the node controller@\\
\mbox{}\lstinline@    :type  node_controller: qde.editor.application.node.NodeController@\\
\mbox{}\lstinline@    :param json_input: the input in JSON format@\\
\mbox{}\lstinline@    :type  json_input: dict@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: a node definition input@\\
\mbox{}\lstinline@    :rtype:  qde.editor.domain.node.NodeDefinitionInput@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    input_id             = uuid.UUID(json_input['id_'])@\\
\mbox{}\lstinline@    name                 = str(json_input['name'])@\\
\mbox{}\lstinline@    atomic_id            = uuid.UUID(json_input['atomic_id'])@\\
\mbox{}\lstinline@    description          = str(json_input['description'])@\\
\mbox{}\lstinline@    node_definition_part = node_controller.get_node_definition_part(atomic_id)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    default_value_str = ""@\\
\mbox{}\lstinline@    default_value_entry = json_input['default_value']@\\
\mbox{}\lstinline@    default_value = parameter.create_value(@\\
\mbox{}\lstinline@        default_value_entry['type_'],@\\
\mbox{}\lstinline@        default_value_entry['value']@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    min_value = float(json_input['min_value'])@\\
\mbox{}\lstinline@    max_value = float(json_input['max_value'])@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_definition_input = node.NodeDefinitionInput(@\\
\mbox{}\lstinline@        input_id,@\\
\mbox{}\lstinline@        name,@\\
\mbox{}\lstinline@        node_definition_part,@\\
\mbox{}\lstinline@        default_value@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    node_definition_input.description = description@\\
\mbox{}\lstinline@    node_definition_input.min_value = min_value@\\
\mbox{}\lstinline@    node_definition_input.max_value = max_value@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    cls.logger.debug(@\\
\mbox{}\lstinline@        "Built node definition input for node definition %s",@\\
\mbox{}\lstinline@        atomic_id@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    return node_definition_input@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb71}{71}\NWlink{nuweb72}{, 72}\NWlink{nuweb78b}{, 78b}\NWlink{nuweb80}{, 80}\NWlink{nuweb84a}{, 84a}\NWlink{nuweb103a}{, 103a}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb105}{, 105}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb102a}{102a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
However, there are a few things missing, which are used in the above code
fragments. The possibility to create values from given parameters, the actual
node definition input as domain model and getting the node definition part
identified by the given atomic identifier.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap118}\raggedright\small
\NWtarget{nuweb73}{} $\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize {73}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def get_node_definition_part(self, id_):@\\
\mbox{}\lstinline@    """Returns the node definition part identified by the given identifier.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    If no such part is available, a generic part with that identifier is being@\\
\mbox{}\lstinline@    created.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the identifier of the part of the node definition to get.@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the node definition part identified by the given identifier.@\\
\mbox{}\lstinline@    :rtype: qde.editor.domain.node.NodeDefinitionPart@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if str(id_) not in self.node_definition_parts:@\\
\mbox{}\lstinline@        self.logger.warn((@\\
\mbox{}\lstinline@            "Part %s of the node definition was not found. Creating a"@\\
\mbox{}\lstinline@            "generic one."@\\
\mbox{}\lstinline@        ), id_)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        type_ = types.NodeType.GENERIC@\\
\mbox{}\lstinline@        def create_func(id_, default_function, name, type_):@\\
\mbox{}\lstinline@            node_part = node.NodePart(id_, None)@\\
\mbox{}\lstinline@            node_part.type_ = type_@\\
\mbox{}\lstinline@            node_part.name = name@\\
\mbox{}\lstinline@            return node_part@\\
\mbox{}\lstinline@        node_definition_part = node.NodeDefinitionPart(id_)@\\
\mbox{}\lstinline@        node_definition_part.type_ = type_@\\
\mbox{}\lstinline@        node_definition_part.creator_function = create_func@\\
\mbox{}\lstinline@        self.node_definition_parts[id_] = node_definition_part@\\
\mbox{}\lstinline@        return node_definition_part@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        return self.node_definition_parts[str(id_)]@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb60c}{60c}\NWlink{nuweb70}{, 70}\NWlink{nuweb73}{, 73}\NWlink{nuweb81}{, 81}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60a}{60a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The creation of values from given parameters is done within the parameter
module, as this is something very parameter specific. Therefore a static method
is defined, which returns an instance of an atomic type, e.g. a float value or
a scene. \todo{instance of atomic type, ok?}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap119}\raggedright\small
\NWtarget{nuweb74}{} $\langle\,${\itshape Parameter domain module methods}\nobreak\ {\footnotesize {74}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def create_value(type_, value_string):@\\
\mbox{}\lstinline@    """Creates an object of the given type with the given value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param type_: the type of the value to create.@\\
\mbox{}\lstinline@    :type  type_: str@\\
\mbox{}\lstinline@    :param value_string: the value that the value shall have.@\\
\mbox{}\lstinline@    "type  value_string: str@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: a value-type of the given type with the given value.@\\
\mbox{}\lstinline@    :rtype: qde.editor.domain.parameter.Value@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if type_.lower() == "float":@\\
\mbox{}\lstinline@        float_value = float(value_string)@\\
\mbox{}\lstinline@        return FloatValue(float_value)@\\
\mbox{}\lstinline@    elif type_.lower() == "text":@\\
\mbox{}\lstinline@        return TextValue(value_string)@\\
\mbox{}\lstinline@    elif type_.lower() == "image":@\\
\mbox{}\lstinline@        return ImageValue()@\\
\mbox{}\lstinline@    elif type_.lower() == "scene":@\\
\mbox{}\lstinline@        return SceneValue()@\\
\mbox{}\lstinline@    elif type_.lower() == "generic":@\\
\mbox{}\lstinline@        return GenericValue()@\\
\mbox{}\lstinline@    elif type_.lower() == "dynamic":@\\
\mbox{}\lstinline@        return DynamicValue()@\\
\mbox{}\lstinline@    elif type_.lower() == "mesh":@\\
\mbox{}\lstinline@        return MeshValue()@\\
\mbox{}\lstinline@    elif type_.lower() == "implicit":@\\
\mbox{}\lstinline@        return ImplicitValue()@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        message = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@            __module__.__name__, "Unknown type for value provided"@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        raise Exception(message)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Further the instanciable classes of the atomic types are defined at the very same
place.

First, a generic value interface is defined. This interface holds a refernce to
the atomic type of the value and defines what type the function of a value is.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap120}\raggedright\small
\NWtarget{nuweb75a}{} $\langle\,${\itshape Paramater domain model value generic interface}\nobreak\ {\footnotesize {75a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class ValueInterface(object):@\\
\mbox{}\lstinline@    """Generic value interface."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        self.function_type = None@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        message = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@            __module__.__name__,@\\
\mbox{}\lstinline@            "This method must be implemented in a child class"@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        raise NotImplementedError(message)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Then an interface for setting and getting values is defined.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap121}\raggedright\small
\NWtarget{nuweb75b}{} $\langle\,${\itshape Paramater domain model value interface}\nobreak\ {\footnotesize {75b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class Value(ValueInterface):@\\
\mbox{}\lstinline@    """Value interface for setting and getting values."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self, value):@\\
\mbox{}\lstinline@        """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param value: the value that shall be held@\\
\mbox{}\lstinline@        :type  value: object@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(Value, self).__init__()@\\
\mbox{}\lstinline@        self.value = value@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Then the specific value types are implemented, based either on the generic or
the concrete value interface, depending on the type. Here just two
implementations are given as an example. The other implementations can be found
at~\todo{link to fragments}.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap122}\raggedright\small
\NWtarget{nuweb76a}{} $\langle\,${\itshape Paramater domain model float value}\nobreak\ {\footnotesize {76a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@# Python@\\
\mbox{}\lstinline@class FloatValue(Value):@\\
\mbox{}\lstinline@    """A class holding float values."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self, float_value):@\\
\mbox{}\lstinline@        """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param float_value: the float value that shall be held@\\
\mbox{}\lstinline@        :type  float_value: float@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(FloatValue, self).__init__(float_value)@\\
\mbox{}\lstinline@        self.function_type = types.NodeType.FLOAT@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return FloatValue(self.value)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap123}\raggedright\small
\NWtarget{nuweb76b}{} $\langle\,${\itshape Paramater domain model scene value}\nobreak\ {\footnotesize {76b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class SceneValue(ValueInterface):@\\
\mbox{}\lstinline@    """A class holding scene values."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(SceneValue, self).__init__()@\\
\mbox{}\lstinline@        self.function_type = types.NodeType.SCENE@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return SceneValue()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
What now still is missing, is the definition of the node definition input
domain model.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap124}\raggedright\small
\NWtarget{nuweb77a}{} $\langle\,${\itshape Node definition input domain model declarations}\nobreak\ {\footnotesize {77a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeDefinitionInput(object):@\\
\mbox{}\lstinline@    """Represents an input of a definition of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition input domain model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition input domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb77b}{77b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition input domain model methods}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap125}\raggedright\small
\NWtarget{nuweb77b}{} $\langle\,${\itshape Node definition input domain model constructor}\nobreak\ {\footnotesize {77b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, id_, name, node_definition_part, default_value):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the identifier of the definition@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@    :param name: the name of the definition@\\
\mbox{}\lstinline@    :type  name: str@\\
\mbox{}\lstinline@    :param node_definition_part: the atomic part of the node definition@\\
\mbox{}\lstinline@    :type node_definition_part: TODO@\\
\mbox{}\lstinline@    :param default_value: the default value of the input@\\
\mbox{}\lstinline@    :type default_value: qde.editor.domain.parameter.Value@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.id_                  = id_@\\
\mbox{}\lstinline@    self.name                 = name@\\
\mbox{}\lstinline@    self.node_definition_part = node_definition_part@\\
\mbox{}\lstinline@    self.description          = ""@\\
\mbox{}\lstinline@    self.min_value            = -100000@\\
\mbox{}\lstinline@    self.max_value            = 100000@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.default_function = create_default_value_function(@\\
\mbox{}\lstinline@        default_value@\\
\mbox{}\lstinline@    )@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb77a}{77a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The code snippet defining the constructor of a node definition input uses a
function called \verb+create_default_value_function+ of the \verb+functions+
module. This function creates a default value function based on the given
default value.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap126}\raggedright\small
\NWtarget{nuweb78a}{} $\langle\,${\itshape Node domain module methods}\nobreak\ {\footnotesize {78a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def create_default_value_function(value):@\\
\mbox{}\lstinline@    """Creates a new default value function using the provided value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param value: the value which the function shall have.@\\
\mbox{}\lstinline@    :type  value: qde.editor.domain.parameter.Value@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    value_function = NodePart.DefaultValueFunction()@\\
\mbox{}\lstinline@    value_function.value = value.clone()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return value_function@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb62}{62}\NWlink{nuweb78a}{, 78a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
With this implementation all the parts needed for creating and handling node
definition inputs are defined, which leads to the next implementation. The
outputs of a node definition. The outputs are in the same way implemented as
the inputs of a node definition.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap127}\raggedright\small
\NWtarget{nuweb78b}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {78b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@classmethod@\\
\mbox{}\lstinline@def build_node_definition_output(cls, node_controller, json_input):@\\
\mbox{}\lstinline@    """Builds and returns a node definition output from the given JSON input@\\
\mbox{}\lstinline@    data.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param node_controller: a reference to the node controller@\\
\mbox{}\lstinline@    :type  node_controller: qde.editor.application.node.NodeController@\\
\mbox{}\lstinline@    :param json_input: the input in JSON format@\\
\mbox{}\lstinline@    :type  json_input: dict@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: a node definition output@\\
\mbox{}\lstinline@    :rtype:  qde.editor.domain.node.NodeDefinitionOutput@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    output_id             = uuid.UUID(json_input['id_'])@\\
\mbox{}\lstinline@    name                 = str(json_input['name'])@\\
\mbox{}\lstinline@    atomic_id            = uuid.UUID(json_input['atomic_id'])@\\
\mbox{}\lstinline@    node_definition_part = node_controller.get_node_definition_part(atomic_id)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_definition_output = node.NodeDefinitionOutput(@\\
\mbox{}\lstinline@        output_id,@\\
\mbox{}\lstinline@        name,@\\
\mbox{}\lstinline@        node_definition_part@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    cls.logger.debug(@\\
\mbox{}\lstinline@        "Built node definition output for node definition %s",@\\
\mbox{}\lstinline@        atomic_id@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    return node_definition_output@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb71}{71}\NWlink{nuweb72}{, 72}\NWlink{nuweb78b}{, 78b}\NWlink{nuweb80}{, 80}\NWlink{nuweb84a}{, 84a}\NWlink{nuweb103a}{, 103a}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb105}{, 105}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb102a}{102a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
The domain model of the node definition output is very similar to the input,
has less attributes although.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap128}\raggedright\small
\NWtarget{nuweb79a}{} $\langle\,${\itshape Node definition output domain model declarations}\nobreak\ {\footnotesize {79a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeDefinitionOutput(object):@\\
\mbox{}\lstinline@    """Represents an output of a definition of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition output domain model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition output domain model constructor}\nobreak\ {\footnotesize \NWlink{nuweb79b}{79b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition output domain model methods}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap129}\raggedright\small
\NWtarget{nuweb79b}{} $\langle\,${\itshape Node definition output domain model constructor}\nobreak\ {\footnotesize {79b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __init__(self, id_, name, node_definition_part):@\\
\mbox{}\lstinline@    """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the identifier of the definition@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@    :param name: the name of the definition@\\
\mbox{}\lstinline@    :type  name: str@\\
\mbox{}\lstinline@    :param node_definition_part: the atomic part of the node definition@\\
\mbox{}\lstinline@    :type node_definition_part: qde.editor.domain.node.NodeDefinitionPart@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.id_                  = id_@\\
\mbox{}\lstinline@    self.name                 = name@\\
\mbox{}\lstinline@    self.node_definition_part = node_definition_part@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb79a}{79a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As a node definition may contain references to other node defintions, it has to
parse them. The parsing is similar to that of the inputs and outputs.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap130}\raggedright\small
\NWtarget{nuweb80}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {80}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@classmethod@\\
\mbox{}\lstinline@def build_node_definition(cls, node_controller, json_input):@\\
\mbox{}\lstinline@    """Builds and returns a node definition from the given JSON input data.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param node_controller: a reference to the node controller@\\
\mbox{}\lstinline@    :type  node_controller: qde.editor.application.node.NodeController@\\
\mbox{}\lstinline@    :param json_input: the input in JSON format@\\
\mbox{}\lstinline@    :type  json_input: dict@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: a dictionary containg the node definition at the index of the@\\
\mbox{}\lstinline@             definition identifier.@\\
\mbox{}\lstinline@    :rtype:  dict@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    definition_id   = uuid.UUID(json_input['id_'])@\\
\mbox{}\lstinline@    atomic_id       = uuid.UUID(json_input['atomic_id'])@\\
\mbox{}\lstinline@    node_definition = node_controller.get_node_definition(atomic_id)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    cls.logger.debug(@\\
\mbox{}\lstinline@        "Built node definition for node definition %s",@\\
\mbox{}\lstinline@        atomic_id@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    return (definition_id, node_definition)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb71}{71}\NWlink{nuweb72}{, 72}\NWlink{nuweb78b}{, 78b}\NWlink{nuweb80}{, 80}\NWlink{nuweb84a}{, 84a}\NWlink{nuweb103a}{, 103a}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb105}{, 105}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb102a}{102a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As can be seen in the above code fragment, the node definition is returned by
the node controller. This is very similar to getting the node definition part
from the node controller.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap131}\raggedright\small
\NWtarget{nuweb81}{} $\langle\,${\itshape Node controller methods}\nobreak\ {\footnotesize {81}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def get_node_definition(self, id_):@\\
\mbox{}\lstinline@    """Returns the node definition identified by the given identifier.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    If no such definition is available, it will be tried to load the@\\
\mbox{}\lstinline@    definition. If this is not possible as well, None will be returned.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param id_: the identifier of the node definition to get.@\\
\mbox{}\lstinline@    :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the node definition identified by the given identifier or None.@\\
\mbox{}\lstinline@    :rtype:  qde.editor.domain.node.NodeDefinition or None@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.logger.debug(@\\
\mbox{}\lstinline@        "Getting node definition %s",@\\
\mbox{}\lstinline@        id_@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if str(id_) in self.node_definitions:@\\
\mbox{}\lstinline@        return self.node_definitions[str(id_)]@\\
\mbox{}\lstinline@    elif self.root_node is not None and id_ == self.root_node.id_:@\\
\mbox{}\lstinline@        return self.root_node@\\
\mbox{}\lstinline@    else:@\\
\mbox{}\lstinline@        # The node definition was not found, try to load it from node@\\
\mbox{}\lstinline@        # definition files.@\\
\mbox{}\lstinline@        file_name = os.path.join(@\\
\mbox{}\lstinline@            self.nodes_path,@\\
\mbox{}\lstinline@            id_,@\\
\mbox{}\lstinline@            self.nodes_extension@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        node_definition = self.load_node_definition_from_file_name(@\\
\mbox{}\lstinline@            file_name@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@        if node_definition is not None:@\\
\mbox{}\lstinline@            self.node_definitions[node_definition.id_] = node_definition@\\
\mbox{}\lstinline@            return node_definition@\\
\mbox{}\lstinline@        else:@\\
\mbox{}\lstinline@            return None@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb60c}{60c}\NWlink{nuweb70}{, 70}\NWlink{nuweb73}{, 73}\NWlink{nuweb81}{, 81}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60a}{60a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
As can be seen in the above code snippet, the node controller holds the
root node, which is placed within the root scene.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap132}\raggedright\small
\NWtarget{nuweb82}{} $\langle\,${\itshape Node controller constructor}\nobreak\ {\footnotesize {82}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # TODO: Load from coonfiguration?@\\
\mbox{}\lstinline@    self.root_node = node.NodeDefinition(NodeController.ROOT_NODE_ID)@\\
\mbox{}\lstinline@    self.root_node.name = QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@        __class__.__name__,@\\
\mbox{}\lstinline@        'Root'@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    root_node_output = node.NodeDefinitionOutput(@\\
\mbox{}\lstinline@        NodeController.ROOT_NODE_OUTPUT_ID,@\\
\mbox{}\lstinline@        QtCore.QCoreApplication.translate(@\\
\mbox{}\lstinline@            __class__.__name__,@\\
\mbox{}\lstinline@            'Output'@\\
\mbox{}\lstinline@        ),@\\
\mbox{}\lstinline@        parameter.AtomicTypes.Generic@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    self.root_node.add_output(root_node_output)@\\
\mbox{}\lstinline@    self.logger.debug("Created root node %s", NodeController.ROOT_NODE_ID)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb60b}{60b}\NWlink{nuweb61c}{, 61c}\NWlink{nuweb68b}{, 68b}\NWlink{nuweb82}{, 82}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb60a}{60a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Currently there is no possiblity to add outputs to a node definition. Adding an
ouptut simply adds that output to the list of outputs the node definition has.
Furthermore that output needs to added for each instance of that node
definition as well.
\todo{Add inputs as well?}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap133}\raggedright\small
\NWtarget{nuweb83}{} $\langle\,${\itshape Node definition domain model methods}\nobreak\ {\footnotesize {83}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def add_output(self, node_definition_output):@\\
\mbox{}\lstinline@    """Adds the given output to the beginning of the list of outputs and@\\
\mbox{}\lstinline@    also to all instances of this node definition.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param node_definition_output: the output to add.@\\
\mbox{}\lstinline@    :type  node_definition_output: qde.editor.domain.node.NodeDefinitionOutput@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.add_output_at(len(self.outputs), node_definition_output)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def add_output_at(self, index, node_definition_output):@\\
\mbox{}\lstinline@    """Adds the given output to the list of outputs at the given index@\\
\mbox{}\lstinline@    position and also to all instances of this node definition.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param index: the position in the list of outputs where the new output@\\
\mbox{}\lstinline@                  shall be added at.@\\
\mbox{}\lstinline@    :type  index: int@\\
\mbox{}\lstinline@    :param node_definition_output: the output to add.@\\
\mbox{}\lstinline@    :type  node_definition_output: qde.editor.domain.node.NodeDefinitionOutput@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :raise: an index error when the given index is not valid.@\\
\mbox{}\lstinline@    :raises: IndexError@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    if index < 0 or index > len(self.outputs):@\\
\mbox{}\lstinline@        raise IndexError()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.outputs.insert(index, node_definition_output)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    for instance in self.instances:@\\
\mbox{}\lstinline@        instance.add_output_at(@\\
\mbox{}\lstinline@            index,@\\
\mbox{}\lstinline@            node_definition_output.create_instance()@\\
\mbox{}\lstinline@        )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # TODO: Insert connection if output is atomic@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.was_changed = True@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb67b}{67b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Having the reading and parsing of inputs, outputs and other node definition
implemented, the reading and parsing of connections, definitions, invocations
and parts still remains.

The reading and parsing of connections, definitions and invocation is very
straightforward and very similar to the one of the node definitions. Therefore
it will not be shown in detail. Details are found at~\todo[inline]{Add
reference to code fragments here}.

The last part when loading a node definition, is reading and parsing the code
part of the node.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap134}\raggedright\small
\NWtarget{nuweb84a}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {84a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@classmethod@\\
\mbox{}\lstinline@def build_node_definition_part(cls, node_controller, parent, json_input):@\\
\mbox{}\lstinline@    """Builds and returns a node definition part from the given JSON input data.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param node_controller: a reference to the node controller@\\
\mbox{}\lstinline@    :type  node_controller: qde.editor.application.node.NodeController@\\
\mbox{}\lstinline@    :param parent: the parent of the node definition part@\\
\mbox{}\lstinline@    :type  parent: qde.editor.domain.node.NodeDefinition@\\
\mbox{}\lstinline@    :param json_input: the input in JSON format@\\
\mbox{}\lstinline@    :type  json_input: dict@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: @\\
\mbox{}\lstinline@    :rtype:  @\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    part_id         = uuid.UUID(json_input['id_'])@\\
\mbox{}\lstinline@    name            = str(json_input['name'])@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    script_lines = []@\\
\mbox{}\lstinline@    for script_line in json_input['script']:@\\
\mbox{}\lstinline@        script_lines.append(str(script_line))@\\
\mbox{}\lstinline@    script = "\n".join(script_lines)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    type_string = json_input['type_']@\\
\mbox{}\lstinline@    type_ = types.NodeType[type_string.upper()]@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_definition_part = node.NodeDefinitionPart(part_id)@\\
\mbox{}\lstinline@    node_definition_part.name = name@\\
\mbox{}\lstinline@    node_definition_part.type_ = type_@\\
\mbox{}\lstinline@    node_definition_part.parent = parent@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_controller.node_definition_parts[part_id] = node_definition_part@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    cls.logger.debug(@\\
\mbox{}\lstinline@        "Built part for node definition %s",@\\
\mbox{}\lstinline@        part_id@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    return node_definition_part@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb71}{71}\NWlink{nuweb72}{, 72}\NWlink{nuweb78b}{, 78b}\NWlink{nuweb80}{, 80}\NWlink{nuweb84a}{, 84a}\NWlink{nuweb103a}{, 103a}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb105}{, 105}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb102a}{102a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
Finally the node controller needs to be instantiated by the main application
and the loading of the node definitions needs to be triggered.

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap135}\raggedright\small
\NWtarget{nuweb84b}{} $\langle\,${\itshape Set up controllers for main application}\nobreak\ {\footnotesize {84b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@self.node_controller = node.NodeController()@\\
\mbox{}\lstinline@self.node_controller.load_nodes()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb29b}{29b}\NWlink{nuweb52d}{, 52d}\NWlink{nuweb84b}{, 84b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb17b}{17b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
% -*- mode: latex; coding: utf-8 -*-

\section{Work log}
\label{sec:work-log}

\begin{loggentry}{2017-02-20}{Mon}
  Set up and structure the document initially.
\end{loggentry}

\begin{loggentry}{2017-02-21}{Tue}
  Re-structure the document, add first contents of the implementation. Add first
  tries to tangle the code. he document initially.
\end{loggentry}

\begin{loggentry}{2017-02-22}{Wed}
  Provide further content concerning the implementation: Introduce
  name-spaces/initializers, first steps for a logging facility.
\end{loggentry}

\begin{loggentry}{2017-02-23}{Thu}
  Extend logging facility, provide (unit-) tests. Restructure the documentation.
\end{loggentry}

\begin{loggentry}{2017-02-24}{Fri}
  Adapt document to output LaTeX code as desired, change styling. Begin
development of the applications' main routine.
\end{loggentry}

\begin{loggentry}{2017-02-27}{Mon}
  Remove (unit-) tests from main document and put them into appendix instead.
  Begin explaining literate programming.
\end{loggentry}

\begin{loggentry}{2017-02-28}{Tue}
  Provide a first draft for objectives and limitations.
  Re-structure the document. Correct LaTeX output.
\end{loggentry}

\begin{loggentry}{2017-03-01}{Wed}
  Remove split files, re-add everything to index, add
  objectives.
\end{loggentry}

\begin{loggentry}{2017-03-02}{Thu}
  Set up project schedule. Tangle everything instead of
  doing things manually. Begin changing language to English instead of German.
  Re-add make targets for cleaning and building the source code.
\end{loggentry}

\begin{loggentry}{2017-03-03}{Fri}
  Keep work log up to date. Revise and finish chapter about
  name-spaces and the project structure for now.
\end{loggentry}

\begin{loggentry}{2017-03-04}{Sat}
  Finish translating all already written texts from German
  to English. Describe the main entry point of the application as well as the
  main application itself.
\end{loggentry}

\begin{loggentry}{2017-03-05}{Sun}
  Finish chapter about the main entry point and the main
  application for now, start describing the main window and implement its
  functionality. Keep the work log up to date. Fiddle with references and
  LaTeX export. Find a bug: main\_window needs to be attached to a class, by
  using the \textit{self} keyword, otherwise the window does not get shown.
  Introduce new make targets: one to clean Python cache files (*.pyc) and one
  to run the editor application directly.
\end{loggentry}

\begin{loggentry}{2017-03-06}{Mon}
  Update the work log. Add an image of the editor as well as
  the project schedule. Add the implementation of the main window's layout.
  Implement the scene domain model. Move keyPressEvent to its own source
  block instead of expanding the methods of the main window directly. Add a
  section about (the architecture's) layers to the principles section. Add
  Dr. Eric Dubuis as an expert to the involved persons. Introduce the 'verb'
  macro for having nicer verbatim blocks. Use the given image-width for
  inline images in org-mode when available.
\end{loggentry}

\begin{loggentry}{2017-03-07}{Tue}
  Expand the layering principles by adding a section about
  the model-view-controller pattern and introduce view models. Explain and
  implement the data- and the view model for scene graph items.
\end{loggentry}

\begin{loggentry}{2017-03-08}{Wed}
  Implement the controller for handling the scene graph.
  Allow the semi-automatic creation of an API documentation by introducing
  Sphinx. Introduce new make targets for creating the API documentation as
  RST and as HTML.
\end{loggentry}

\begin{loggentry}{2017-03-10}{Fri}
  Implement the scene graph view as widget and integrate it
  into the application. Update the work log. Fix typing errors. Start to
  implement missing methods in the scene graph controller for being able to
  use the scene graph widget.
\end{loggentry}

\begin{loggentry}{2017-03-13}{Mon}
  Implement the scene view model. Initialize such a model
  within the scene graph view model. Implement the =headerData= as well as
  the =data= methods of the scene graph controller. Update the work log. Add
  an image of the editor's current state. Continue implementation of the
  scene graph view model.
\end{loggentry}

\begin{loggentry}{2017-03-14}{Tue}
  Continue the implementation of the scene graph view model.
  Implement logging. Implement logging. Implement logging. Implement logging
  functionality. Log whenever a node is added or removed from the scene graph
  view.
\end{loggentry}

\begin{loggentry}{2017-03-15}{Wed}
  Move logging further down in structure. Add connections
  between scene graph view and controller. Finish implementing the adding and
  removal of scene graph items. Update the work log.

  Next steps: (Re-) Introduce logging. Begin implementing the node graph.
\end{loggentry}

\begin{loggentry}{2017-03-16}{Thu}
  Run sphinx apidoc when creating the HTML documentation.
  Add an illustration about the state of the editor after finishing the
  implementation of the scene graph. Change width of the images to be 50% of
  the text width. Name slots of the scene graph view explicitly to maintain
  sanity. Re-add logging chapter with a corresponding introduction. Fix display
  of code listings. Keep work log up to date. Add missing TODO annotations to
  headings.

  Next steps: Continue implementing the node graph.
\end{loggentry}

\begin{loggentry}{2017-03-17}{Fri}
  Change verbatim output to be less intrusive, update to do
  tags, begin adding references do code fragment definitions, begin implement
  the node graph. Move chapters into separate org files.
\end{loggentry}

\begin{loggentry}{2017-03-20}{Mon}
  Re-think how to implement node definitions and revise
  therefore the chapter about the node graph component, fix various
  typographic errors, expand and change the Makefile, keep the work log up
  to date.
\end{loggentry}

\begin{loggentry}{2017-03-21}{Tue}
  Re-think how to implement node definitions.
\end{loggentry}

\begin{loggentry}{2017-03-22}{Wed}
  Re-think how to implement node definitions and nodes. Begin adding
  notes about how to implement nodes.
\end{loggentry}

\begin{loggentry}{2017-03-23}{Thu}
  Expand notes about the node implementation, begin writing
  the actual node implementation down, keep the work log up to date.
\end{loggentry}

\begin{loggentry}{2017-03-24}{Fri}
  Attend a meeting with Prof. Fuhrer, change and expand the
  chapter about node implementation according to the before made thoughts,
  begin implementing the node graph structure, keep the work log up to date.
\end{loggentry}% -*- mode: latex; coding: utf-8 -*-

\section{Code fragments}
\label{sec:code-fragments}

\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap136}\raggedright\small
\NWtarget{nuweb87a}{} \verb@"../src/editor.py"@\nobreak\ {\footnotesize {87a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Main entry point for the QDE editor application. """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@import sys@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.application import application@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Main entry point}\nobreak\ {\footnotesize \NWlink{nuweb14}{14}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap137}\raggedright\small
\NWtarget{nuweb87b}{} \verb@"../src/qde/editor/application/application.py"@\nobreak\ {\footnotesize {87b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@"""Main application module for the QDE editor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@import logging@\\
\mbox{}\lstinline@import logging.config@\\
\mbox{}\lstinline@import os@\\
\mbox{}\lstinline@import json@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@from PyQt5 import QtCore@\\
\mbox{}\lstinline@from PyQt5 import QtGui@\\
\mbox{}\lstinline@from PyQt5 import QtWidgets@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@from qde.editor.application import node@\\
\mbox{}\lstinline@from qde.editor.application import scene@\\
\mbox{}\lstinline@from qde.editor.gui import main_window as qde_main_window@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Main application declarations}\nobreak\ {\footnotesize \NWlink{nuweb15a}{15a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap138}\raggedright\small
\NWtarget{nuweb88a}{} \verb@"../src/qde/editor/gui/main_window.py"@\nobreak\ {\footnotesize {88a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Module holding the main application window. """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@from PyQt5 import QtCore@\\
\mbox{}\lstinline@from PyQt5 import QtGui@\\
\mbox{}\lstinline@from PyQt5 import QtWidgets@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@from qde.editor.gui import scene as guiscene@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Main window declarations}\nobreak\ {\footnotesize \NWlink{nuweb16a}{16a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap139}\raggedright\small
\NWtarget{nuweb88b}{} \verb@"../src/qde/editor/domain/scene.py"@\nobreak\ {\footnotesize {88b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Module holding scene related aspects concerning the domain layer. """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@import uuid@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@from PyQt5 import QtCore@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene model declarations}\nobreak\ {\footnotesize \NWlink{nuweb20a}{20a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap140}\raggedright\small
\NWtarget{nuweb88c}{} \verb@"../src/qde/editor/gui_domain/scene.py"@\nobreak\ {\footnotesize {88c}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Module holding scene related aspects concerning the gui_domain layer. """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@from PyQt5 import QtCore@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene graph view model declarations}\nobreak\ {\footnotesize \NWlink{nuweb21a}{21a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene view model declarations}\nobreak\ {\footnotesize \NWlink{nuweb53a}{53a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap141}\raggedright\small
\NWtarget{nuweb89a}{} $\langle\,${\itshape Scene graph view model methods}\nobreak\ {\footnotesize {89a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __str__(self):@\\
\mbox{}\lstinline@    """Return the string representation of the current object."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return str(self.id_)[0:8]@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb29a}{29a}\NWlink{nuweb89a}{, 89a}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb21a}{21a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap142}\raggedright\small
\NWtarget{nuweb89b}{} $\langle\,${\itshape Scene view model methods}\nobreak\ {\footnotesize {89b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def __str__(self):@\\
\mbox{}\lstinline@    """Return the string representation of the current object."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return str(self.id_)[0:8]@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb54a}{54a}\NWlink{nuweb89b}{, 89b}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb53a}{53a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap143}\raggedright\small
\NWtarget{nuweb89c}{} \verb@"../src/qde/editor/application/scene.py"@\nobreak\ {\footnotesize {89c}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Module holding scene related aspects concerning the application layer.@\\
\mbox{}\lstinline@"""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@from PyQt5 import QtCore@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@from qde.editor.domain     import scene as domain_scene@\\
\mbox{}\lstinline@from qde.editor.gui_domain import scene as guidomain_scene@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene graph controller declarations}\nobreak\ {\footnotesize \NWlink{nuweb22a}{22a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene controller declarations}\nobreak\ {\footnotesize \NWlink{nuweb52c}{52c}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap144}\raggedright\small
\NWtarget{nuweb90}{} \verb@"../src/qde/editor/gui/scene.py"@\nobreak\ {\footnotesize {90}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Module holding scene related aspects concerning the graphical user interface layer.@\\
\mbox{}\lstinline@"""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@from PyQt5 import QtCore@\\
\mbox{}\lstinline@from PyQt5 import QtWidgets@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@from qde.editor.gui_domain import scene@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene graph view declarations}\nobreak\ {\footnotesize \NWlink{nuweb29c}{29c}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Scene view declarations}\nobreak\ {\footnotesize \NWlink{nuweb50d}{50d}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap145}\raggedright\small
\NWtarget{nuweb91}{} \verb@"../logging.json"@\nobreak\ {\footnotesize {91}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@{@\\
\mbox{}\lstinline@    "version": 1,@\\
\mbox{}\lstinline@    "disable_existing_loggers": false,@\\
\mbox{}\lstinline@    "formatters": {@\\
\mbox{}\lstinline@        "simple": {@\\
\mbox{}\lstinline@            "format": "%(asctime)s - %(levelname)-7s - %(name)s.%(funcName)s::%(lineno)s: %(message)s"@\\
\mbox{}\lstinline@        }@\\
\mbox{}\lstinline@    },@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    "handlers": {@\\
\mbox{}\lstinline@        "console": {@\\
\mbox{}\lstinline@            "class": "logging.StreamHandler",@\\
\mbox{}\lstinline@            "level": "DEBUG",@\\
\mbox{}\lstinline@            "formatter": "simple",@\\
\mbox{}\lstinline@            "stream": "ext://sys.stdout"@\\
\mbox{}\lstinline@        },@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        "info_file_handler": {@\\
\mbox{}\lstinline@            "class": "logging.handlers.RotatingFileHandler",@\\
\mbox{}\lstinline@            "level": "INFO",@\\
\mbox{}\lstinline@            "formatter": "simple",@\\
\mbox{}\lstinline@            "filename": "info.log",@\\
\mbox{}\lstinline@            "maxBytes": 10485760,@\\
\mbox{}\lstinline@            "backupCount": 20,@\\
\mbox{}\lstinline@            "encoding": "utf8"@\\
\mbox{}\lstinline@        },@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        "error_file_handler": {@\\
\mbox{}\lstinline@            "class": "logging.handlers.RotatingFileHandler",@\\
\mbox{}\lstinline@            "level": "ERROR",@\\
\mbox{}\lstinline@            "formatter": "simple",@\\
\mbox{}\lstinline@            "filename": "errors.log",@\\
\mbox{}\lstinline@            "maxBytes": 10485760,@\\
\mbox{}\lstinline@            "backupCount": 20,@\\
\mbox{}\lstinline@            "encoding": "utf8"@\\
\mbox{}\lstinline@        }@\\
\mbox{}\lstinline@    },@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    "root": {@\\
\mbox{}\lstinline@        "level": "DEBUG",@\\
\mbox{}\lstinline@        "handlers": ["console", "info_file_handler", "error_file_handler"],@\\
\mbox{}\lstinline@        "propagate": "no"@\\
\mbox{}\lstinline@    }@\\
\mbox{}\lstinline@}@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap146}\raggedright\small
\NWtarget{nuweb92a}{} \verb@"../src/qde/editor/foundation/common.py"@\nobreak\ {\footnotesize {92a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@"""Module holding common helper methods."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@import logging@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@from PyQt5 import QtCore@\\
\mbox{}\lstinline@from PyQt5 import QtWidgets@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def with_logger(cls):@\\
\mbox{}\lstinline@    """Add a logger instance (using a stream handler) to the given class.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param cls: the class which the logger shall be added to.@\\
\mbox{}\lstinline@    :type  cls: a class of type cls.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the class with the logger instance added.@\\
\mbox{}\lstinline@    :rtype:  a class of type cls.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Set logger name}\nobreak\ {\footnotesize \NWlink{nuweb39a}{39a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Logger interface}\nobreak\ {\footnotesize \NWlink{nuweb39b}{39b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap147}\raggedright\small
\NWtarget{nuweb92b}{} $\langle\,${\itshape Scene graph view decorators}\nobreak\ {\footnotesize {92b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb29c}{29c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap148}\raggedright\small
\NWtarget{nuweb92c}{} \verb@"../src/qde/editor/foundation/type.py"@\nobreak\ {\footnotesize {92c}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@"""Module for type-specific aspects."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@import enum@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node type declarations}\nobreak\ {\footnotesize \NWlink{nuweb43}{43}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node part state changed declarations}\nobreak\ {\footnotesize \NWlink{nuweb66b}{66b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap149}\raggedright\small
\NWtarget{nuweb93}{} \verb@"../src/qde/editor/domain/parameter.py"@\nobreak\ {\footnotesize {93}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@"""Module for parameter-specific aspects."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import type as types@\\
\mbox{}\lstinline@from qde.editor.domain import node@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Parameter declarations}\nobreak\ {\footnotesize \NWlink{nuweb44}{44}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Paramater domain model value generic interface}\nobreak\ {\footnotesize \NWlink{nuweb75a}{75a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Paramater domain model value interface}\nobreak\ {\footnotesize \NWlink{nuweb75b}{75b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Paramater domain model float value}\nobreak\ {\footnotesize \NWlink{nuweb76a}{76a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Paramater domain model text value}\nobreak\ {\footnotesize \NWlink{nuweb95a}{95a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Paramater domain model scene value}\nobreak\ {\footnotesize \NWlink{nuweb76b}{76b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Parameter domain module methods}\nobreak\ {\footnotesize \NWlink{nuweb74}{74}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap150}\raggedright\small
\NWtarget{nuweb94}{} $\langle\,${\itshape Parameter declarations}\nobreak\ {\footnotesize {94}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    FloatValue = create_node_definition_part.__func__(@\\
\mbox{}\lstinline@        id_="468aea9e-0a03-4e63-b6b4-8a7a76775a1a",@\\
\mbox{}\lstinline@        type_=types.NodeType.FLOAT@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    Text = create_node_definition_part.__func__(@\\
\mbox{}\lstinline@        id_="e43bdd1b-a895-4bd8-8d5a-b401a63f7a6f",@\\
\mbox{}\lstinline@        type_=types.NodeType.TEXT@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    Scene = create_node_definition_part.__func__(@\\
\mbox{}\lstinline@        id_="bfb47e7text7-1b05-4864-8397-de30bf005ff8",@\\
\mbox{}\lstinline@        type_=types.NodeType.SCENE@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    Image = create_node_definition_part.__func__(@\\
\mbox{}\lstinline@        id_="21fd1960-1307-4b53-b7bf-d08f02757335",@\\
\mbox{}\lstinline@        type_=types.NodeType.IMAGE@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    DynamicValue = create_node_definition_part.__func__(@\\
\mbox{}\lstinline@        id_="68720ae3-8068-43ce-94d8-8705dc3b8bfe",@\\
\mbox{}\lstinline@        type_=types.NodeType.DYNAMIC@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    Mesh = create_node_definition_part.__func__(@\\
\mbox{}\lstinline@        id_="9791d341-b92c-43dd-954a-9d83b9020e43",@\\
\mbox{}\lstinline@        type_=types.NodeType.MESH@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    Implicit = create_node_definition_part.__func__(@\\
\mbox{}\lstinline@        id_="c019271c-35b6-425c-9ff2-a1d893111adb",@\\
\mbox{}\lstinline@        type_=types.NodeType.IMPLICIT@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    atomic_types = [@\\
\mbox{}\lstinline@        FloatValue,@\\
\mbox{}\lstinline@        Text,@\\
\mbox{}\lstinline@        Scene,@\\
\mbox{}\lstinline@        Image,@\\
\mbox{}\lstinline@        DynamicValue,@\\
\mbox{}\lstinline@        Mesh,@\\
\mbox{}\lstinline@        Implicit,@\\
\mbox{}\lstinline@    ]@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb44}{44}\NWlink{nuweb45a}{, 45a}\NWlink{nuweb94}{, 94}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap151}\raggedright\small
\NWtarget{nuweb95a}{} $\langle\,${\itshape Paramater domain model text value}\nobreak\ {\footnotesize {95a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class TextValue(Value):@\\
\mbox{}\lstinline@    """A class holding values for text/string nodes."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self, string_value):@\\
\mbox{}\lstinline@        """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param string_value: the string value that shall be held@\\
\mbox{}\lstinline@        :type  string_value: str@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(TextValue, self).__init__(string_value)@\\
\mbox{}\lstinline@        self.function_type = types.NodeType.TEXT@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return TextValue(self.value)@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb93}{93}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap152}\raggedright\small
\NWtarget{nuweb95b}{} $\langle\,${\itshape Paramater domain model image value}\nobreak\ {\footnotesize {95b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class ImageValue(ValueInterface):@\\
\mbox{}\lstinline@    """A class holding values for image nodes."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(ImageValue, self).__init__()@\\
\mbox{}\lstinline@        self.function_type = types.NodeType.IMAGE@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return ImageValue()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap153}\raggedright\small
\NWtarget{nuweb96a}{} $\langle\,${\itshape Paramater domain model generic value}\nobreak\ {\footnotesize {96a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class GenericValue(ValueInterface):@\\
\mbox{}\lstinline@    """A class holding values for generic nodes."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(GenericValue, self).__init__()@\\
\mbox{}\lstinline@        self.function_type = types.NodeType.GENERIC@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return GenericValue()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap154}\raggedright\small
\NWtarget{nuweb96b}{} $\langle\,${\itshape Paramater domain model dynamic value}\nobreak\ {\footnotesize {96b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class DynamicValue(ValueInterface):@\\
\mbox{}\lstinline@    """A class holding values for dynamic nodes."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(DynamicValue, self).__init__()@\\
\mbox{}\lstinline@        self.function_type = types.NodeType.DYNAMIC@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return DynamicValue()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap155}\raggedright\small
\NWtarget{nuweb97a}{} $\langle\,${\itshape Paramater domain model mesh value}\nobreak\ {\footnotesize {97a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class MeshValue(ValueInterface):@\\
\mbox{}\lstinline@    """A class holding values for mesh nodes."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(MeshValue, self).__init__()@\\
\mbox{}\lstinline@        self.function_type = types.NodeType.MESH@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return MeshValue()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap156}\raggedright\small
\NWtarget{nuweb97b}{} $\langle\,${\itshape Paramater domain model implicit value}\nobreak\ {\footnotesize {97b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class ImplicitValue(ValueInterface):@\\
\mbox{}\lstinline@    """A class holding values for implicit surface nodes."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self):@\\
\mbox{}\lstinline@        """Constructor."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        super(ImplicitValue, self).__init__()@\\
\mbox{}\lstinline@        self.function_type = types.NodeType.IMPLICIT@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def clone(self):@\\
\mbox{}\lstinline@        """Clones the currently set value.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :return: a clone of the currently set value@\\
\mbox{}\lstinline@        :rtype:  qde.editor.domain.parameter.ValueInterface@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        return ImplicitValue()@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item {\NWtxtMacroNoRef}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap157}\raggedright\small
\NWtarget{nuweb98a}{} \verb@"../src/qde/editor/domain/node.py"@\nobreak\ {\footnotesize {98a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@"""Module for node-specific aspects."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import type as types@\\
\mbox{}\lstinline@from qde.editor.foundation import flag@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb45b}{45b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node part domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb65a}{65a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node definition domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb67b}{67b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node definition part domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb61a}{61a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node definition input domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb77a}{77a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node definition output domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb79a}{79a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node definition connection domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb102b}{102b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node definition definition domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb103b}{103b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node definition invocation domain model declarations}\nobreak\ {\footnotesize \NWlink{nuweb104b}{104b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node domain module methods}\nobreak\ {\footnotesize \NWlink{nuweb62}{62}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap158}\raggedright\small
\NWtarget{nuweb98b}{} \verb@"../src/qde/editor/gui_domain/node.py"@\nobreak\ {\footnotesize {98b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Module holding node related aspects concerning the gui_domain layer. """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node view model declarations}\nobreak\ {\footnotesize \NWlink{nuweb46b}{46b}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap159}\raggedright\small
\NWtarget{nuweb98c}{} $\langle\,${\itshape Node view model constructor}\nobreak\ {\footnotesize {98c}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    self.setPos(self.position)@\\
\mbox{}\lstinline@    self.setAcceptHoverEvents(True)@\\
\mbox{}\lstinline@    self.setFlag(QGraphicsObject.ItemIsFocusable)@\\
\mbox{}\lstinline@    self.setFlag(QGraphicsObject.ItemIsMovable)@\\
\mbox{}\lstinline@    self.setFlag(QGraphicsObject.ItemIsSelectable)@\\
\mbox{}\lstinline@    self.setFlag(QGraphicsObject.ItemClipsToShape)@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47a}{47a}\NWlink{nuweb48c}{, 48c}\NWlink{nuweb98c}{, 98c}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap160}\raggedright\small
\NWtarget{nuweb99}{} \verb@"../src/qde/editor/foundation/flag.py"@\nobreak\ {\footnotesize {99}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@"""Module for flag-specific aspects."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@import enum@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeStatus(enum.Enum):@\\
\mbox{}\lstinline@    """Statues which a node can have."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    OK              = 0@\\
\mbox{}\lstinline@    NO_INPUTS       = 1@\\
\mbox{}\lstinline@    WRONG_INPUT     = 2@\\
\mbox{}\lstinline@    INPUT_ERRONEOUS = 3@\\
\mbox{}\lstinline@    INPUT_CYCLIC    = 4@\\
\mbox{}\lstinline@    LINK_MISSING    = 5@\\
\mbox{}\lstinline@    TOO_MANY_INPUTS = 6@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap161}\raggedright\small
\NWtarget{nuweb100}{} $\langle\,${\itshape Node view model methods}\nobreak\ {\footnotesize {100}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def boundingRect(self):@\\
\mbox{}\lstinline@    """Return the bounding rectangle of the node.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the bounding rectangle of the node.@\\
\mbox{}\lstinline@    :rtype: Qt.QRectF@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return Qt.QRectF(@\\
\mbox{}\lstinline@        0, 0, self.width * NodeViewModel.WIDTH, NodeViewModel.HEIGHT@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@def create_pixmap(self):@\\
\mbox{}\lstinline@    """Creation of the pixmap (=bitmap, the actual 'image')"""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    image = QImage(self.boundingRect().size().toSize(),@\\
\mbox{}\lstinline@                    QImage.Format_ARGB32_Premultiplied)@\\
\mbox{}\lstinline@    pixmap = QPixmap.fromImage(image)@\\
\mbox{}\lstinline@    pixmap.fill(Qt.transparent)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    rect = self.boundingRect()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    painter = QPainter()@\\
\mbox{}\lstinline@    painter.begin(pixmap)@\\
\mbox{}\lstinline@    painter.setRenderHint(QPainter.Antialiasing)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Shape@\\
\mbox{}\lstinline@    path = QPainterPath()@\\
\mbox{}\lstinline@    path.addRect(rect)@\\
\mbox{}\lstinline@    # path.addRoundedRect(rect, 5, 5)@\\
\mbox{}\lstinline@    painter.drawPath(path)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Color / gradient@\\
\mbox{}\lstinline@    color = QColor(255, 0, 0, 128)@\\
\mbox{}\lstinline@    color.setHsv(color.hsvHue(), 160, 255)@\\
\mbox{}\lstinline@    color_desaturated = color@\\
\mbox{}\lstinline@    color_desaturated.setHsv(color.hsvHue(), 40, 255)@\\
\mbox{}\lstinline@    top_color = QColor(60, 70, 80)@\\
\mbox{}\lstinline@    if self.status is not flag.NodeStatus.OK:@\\
\mbox{}\lstinline@        top_color = QColor(255, 0, 0)@\\
\mbox{}\lstinline@    gradient_top_color = cmn.multiply_colors(@\\
\mbox{}\lstinline@        top_color, color_desaturated@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    gradient_bottom_color = cmn.multiply_colors(@\\
\mbox{}\lstinline@        QColor(110, 120, 130), color_desaturated@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    rect_gradient = QLinearGradient(@\\
\mbox{}\lstinline@        QPoint(0.0, 0.0), QPoint(0.0, rect.height())@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@    rect_gradient.setColorAt(0.0, gradient_top_color)@\\
\mbox{}\lstinline@    rect_gradient.setColorAt(1.0, gradient_bottom_color)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    brush = QBrush(rect_gradient)@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    painter.fillPath(path, brush)@\\
\mbox{}\lstinline@    painter.end()@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    return pixmap@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb47b}{47b}\NWlink{nuweb47c}{c}\NWlink{nuweb48b}{, 48b}\NWlink{nuweb49a}{, 49a}\NWlink{nuweb49c}{c}\NWlink{nuweb100}{, 100}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb46b}{46b}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap162}\raggedright\small
\NWtarget{nuweb101a}{} \verb@"../nodes/16d90b34-a728-4caa-b07d-a3244ecc87e3.node"@\nobreak\ {\footnotesize {101a}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Implicit sphere node}\nobreak\ {\footnotesize \NWlink{nuweb57a}{57a}}$\,\rangle$}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap163}\raggedright\small
\NWtarget{nuweb101b}{} \verb@"../src/qde/editor/application/node.py"@\nobreak\ {\footnotesize {101b}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Module holding node related aspects concerning the application layer.@\\
\mbox{}\lstinline@"""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@import glob@\\
\mbox{}\lstinline@import os@\\
\mbox{}\lstinline@import time@\\
\mbox{}\lstinline@import uuid@\\
\mbox{}\lstinline@from PyQt5 import Qt@\\
\mbox{}\lstinline@from PyQt5 import QtCore@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@from qde.editor.foundation import type as types@\\
\mbox{}\lstinline@from qde.editor.technical import json@\\
\mbox{}\lstinline@from qde.editor.domain import parameter@\\
\mbox{}\lstinline@from qde.editor.domain import node@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape Node controller declarations}\nobreak\ {\footnotesize \NWlink{nuweb60a}{60a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap164}\raggedright\small
\NWtarget{nuweb101c}{} \verb@"../src/qde/editor/technical/json.py"@\nobreak\ {\footnotesize {101c}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\lstinline@#!/usr/bin/python@\\
\mbox{}\lstinline@# -*- coding: utf-8 -*-@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@""" Module holding JSON related aspects.@\\
\mbox{}\lstinline@"""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# System imports@\\
\mbox{}\lstinline@import json@\\
\mbox{}\lstinline@import uuid@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@# Project imports@\\
\mbox{}\lstinline@from qde.editor.foundation import common@\\
\mbox{}\lstinline@from qde.editor.foundation import type as types@\\
\mbox{}\lstinline@from qde.editor.domain import node@\\
\mbox{}\lstinline@from qde.editor.domain import parameter@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@\hbox{$\langle\,${\itshape JSON module declarations}\nobreak\ {\footnotesize \NWlink{nuweb102a}{102a}}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap165}\raggedright\small
\NWtarget{nuweb102a}{} $\langle\,${\itshape JSON module declarations}\nobreak\ {\footnotesize {102a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@common.with_logger@\\
\mbox{}\lstinline@class Json(object):@\\
\mbox{}\lstinline@    """Class handling JSON relevant tasks.@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize \NWlink{nuweb71}{71}, \ldots\ }$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb101c}{101c}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap166}\raggedright\small
\NWtarget{nuweb102b}{} $\langle\,${\itshape Node definition connection domain model declarations}\nobreak\ {\footnotesize {102b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeDefinitionConnection(object):@\\
\mbox{}\lstinline@    """Represents a connection of a definition of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    # Signals@\\
\mbox{}\lstinline@    @\hbox{$\langle\,${\itshape Node definition connection domain model signals}\nobreak\ {\footnotesize ?}$\,\rangle$}\lstinline@@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self,@\\
\mbox{}\lstinline@                 source_node_id, source_part_id,@\\
\mbox{}\lstinline@                 target_node_id, target_part_id):@\\
\mbox{}\lstinline@        """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param source_node_id: the identifier of the source node.@\\
\mbox{}\lstinline@        :type  source_node_id: uuid.uuid4@\\
\mbox{}\lstinline@        :param source_part_id: the identifier of the part of the source node.@\\
\mbox{}\lstinline@        :type  source_part_id: uuid.uuid4@\\
\mbox{}\lstinline@        :param target_node_id: the identifier of the target node.@\\
\mbox{}\lstinline@        :type  target_node_id: uuid.uuid4@\\
\mbox{}\lstinline@        :param target_part_id: the identifier of the part of the target node.@\\
\mbox{}\lstinline@        :type  target_part_id: uuid.uuid4@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        self.source_node_id = source_node_id@\\
\mbox{}\lstinline@        self.source_part_id = source_part_id@\\
\mbox{}\lstinline@        self.target_node_id = target_node_id@\\
\mbox{}\lstinline@        self.target_part_id = target_part_id@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap167}\raggedright\small
\NWtarget{nuweb103a}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {103a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@classmethod@\\
\mbox{}\lstinline@def build_node_definition_connection(cls, json_input):@\\
\mbox{}\lstinline@    """Builds and returns a connection for a node definition from the given@\\
\mbox{}\lstinline@    JSON input data.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param json_input: the input in JSON format@\\
\mbox{}\lstinline@    :type  json_input: dict@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the connection of a node definition.@\\
\mbox{}\lstinline@    :rtype:  qde.editor.domain.node.NodeDefinitionConnection@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    source_node_id = uuid.UUID(json_input['source_node'])@\\
\mbox{}\lstinline@    source_part_id = uuid.UUID(json_input['source_part'])@\\
\mbox{}\lstinline@    target_node_id = uuid.UUID(json_input['target_node'])@\\
\mbox{}\lstinline@    target_part_id = uuid.UUID(json_input['target_part'])@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_definition_connection = node.NodeDefinitionConnection(@\\
\mbox{}\lstinline@        source_node_id,@\\
\mbox{}\lstinline@        source_part_id,@\\
\mbox{}\lstinline@        target_node_id,@\\
\mbox{}\lstinline@        target_part_id@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    cls.logger.debug("Built node definition connection")@\\
\mbox{}\lstinline@    return node_definition_connection@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb71}{71}\NWlink{nuweb72}{, 72}\NWlink{nuweb78b}{, 78b}\NWlink{nuweb80}{, 80}\NWlink{nuweb84a}{, 84a}\NWlink{nuweb103a}{, 103a}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb105}{, 105}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb102a}{102a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap168}\raggedright\small
\NWtarget{nuweb103b}{} $\langle\,${\itshape Node definition definition domain model declarations}\nobreak\ {\footnotesize {103b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeDefinitionDefinition(object):@\\
\mbox{}\lstinline@    """Represents a definition part of a definition of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self, id_, script):@\\
\mbox{}\lstinline@        """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param id_: the globally unique identifier of the definition.@\\
\mbox{}\lstinline@        :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@        :param script: the script part of the definition.@\\
\mbox{}\lstinline@        :param script: str@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        self.id_ = id_@\\
\mbox{}\lstinline@        self.script = script@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap169}\raggedright\small
\NWtarget{nuweb104a}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {104a}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@classmethod@\\
\mbox{}\lstinline@def build_node_definition_definition(cls, json_input):@\\
\mbox{}\lstinline@    """Builds and returns a definition for a node definition from the given@\\
\mbox{}\lstinline@    JSON input data.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param json_input: the input in JSON format@\\
\mbox{}\lstinline@    :type  json_input: dict@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the definition of a node definition.@\\
\mbox{}\lstinline@    :rtype:  qde.editor.domain.node.NodeDefinitionDefinition@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    definition_id = uuid.UUID(json_input['id_'])@\\
\mbox{}\lstinline@    script        = str(json_input['script'])@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_definition_definition = node.NodeDefinitionDefinition(@\\
\mbox{}\lstinline@        definition_id,@\\
\mbox{}\lstinline@        script@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    cls.logger.debug("Built node definition definition")@\\
\mbox{}\lstinline@    return node_definition_definition@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb71}{71}\NWlink{nuweb72}{, 72}\NWlink{nuweb78b}{, 78b}\NWlink{nuweb80}{, 80}\NWlink{nuweb84a}{, 84a}\NWlink{nuweb103a}{, 103a}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb105}{, 105}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb102a}{102a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap170}\raggedright\small
\NWtarget{nuweb104b}{} $\langle\,${\itshape Node definition invocation domain model declarations}\nobreak\ {\footnotesize {104b}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@class NodeDefinitionInvocation(object):@\\
\mbox{}\lstinline@    """Represents an invocation of a definition of a node."""@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    def __init__(self, id_, script):@\\
\mbox{}\lstinline@        """Constructor.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        :param id_: the globally unique identifier of the definition.@\\
\mbox{}\lstinline@        :type  id_: uuid.uuid4@\\
\mbox{}\lstinline@        :param script: the script part of the invocation.@\\
\mbox{}\lstinline@        :param script: str@\\
\mbox{}\lstinline@        """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@        self.id_ = id_@\\
\mbox{}\lstinline@        self.script = script@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroRefIn\ \NWlink{nuweb98a}{98a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap171}\raggedright\small
\NWtarget{nuweb105}{} $\langle\,${\itshape JSON methods}\nobreak\ {\footnotesize {105}}$\,\rangle\equiv$
\vspace{-1exm}
\begin{list}{}{} \item
\mbox{}\lstinline@@\\
\mbox{}\lstinline@@{\normalfont \fontfamily @}\lstinline@classmethod@\\
\mbox{}\lstinline@def build_node_definition_invocation(cls, json_input):@\\
\mbox{}\lstinline@    """Builds and returns a invocation for a node definition from the given@\\
\mbox{}\lstinline@    JSON input data.@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :param json_input: the input in JSON format@\\
\mbox{}\lstinline@    :type  json_input: dict@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    :return: the invocation of a node definition.@\\
\mbox{}\lstinline@    :rtype:  qde.editor.domain.node.NodeDefinitionInvocation@\\
\mbox{}\lstinline@    """@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    invocation_id = uuid.UUID(json_input['id_'])@\\
\mbox{}\lstinline@    script        = str(json_input['script'])@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    node_definition_invocation = node.NodeDefinitionInvocation(@\\
\mbox{}\lstinline@        invocation_id,@\\
\mbox{}\lstinline@        script@\\
\mbox{}\lstinline@    )@\\
\mbox{}\lstinline@@\\
\mbox{}\lstinline@    cls.logger.debug("Built node definition invocation")@\\
\mbox{}\lstinline@    return node_definition_invocation@\\
\mbox{}\lstinline@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtMacroDefBy\ \NWlink{nuweb71}{71}\NWlink{nuweb72}{, 72}\NWlink{nuweb78b}{, 78b}\NWlink{nuweb80}{, 80}\NWlink{nuweb84a}{, 84a}\NWlink{nuweb103a}{, 103a}\NWlink{nuweb104a}{, 104a}\NWlink{nuweb105}{, 105}.
\item \NWtxtMacroRefIn\ \NWlink{nuweb102a}{102a}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\section{Test cases}
\label{sec:test-cases}

\blindtext{}

\section{Requirements}
\label{sec:requirements}
% 
% This chapter describes the requirements to extract the source code out of this
% documentation using /tangling/.
% 
% At the current point of time, the requirements are the following:
% 
% - A Unix derivative as operating system (Linux, macOS).
% - Python version 3.5.x or up[fn:3:https://www.python.org].
% - Pyenv[fn:4:https://github.com/yyuu/pyenv].
% - Pyenv-virtualenv[fn:5:https://github.com/yyuu/pyenv-virtualenv].
% 
% The first step is to install a matching version of python for the usage within
% the virtual environment. The available Python versions may be listed as follows.
% 
% #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
% #+CAPTION:    Listing all available versions of Python for use in Pyenv.
% #+NAME:       fig:impl-pyenv-list
% #+BEGIN_SRC bash
% pyenv install --list
% #+END_SRC
% 
% The desired version may be installed as follows. This example shows the
% installation of version 3.6.0.
% 
% #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
% #+CAPTION:    Installation of Python version 3.6.0 for the usage with Pyenv.
% #+NAME:       fig:impl-pyenv-install
% #+BEGIN_SRC bash
% install 3.6.0
% #+END_SRC
% 
% It is highly recommended to create and use a project-specific virtual Python
% environment. All packages, that are required for this project are installed
% within this virtual environment protecting the operating systems' Python
% packages.
% First the desired version of Python has to be specified, then the desired name
% of the virtual environment.
% 
% #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
% #+CAPTION:    Creation of the virtual environment =qde= for Python using version 3.6.0 of Python.
% #+NAME:       fig:impl-pyenv-venv
% #+BEGIN_SRC bash
% pyenv virtualenv 3.6.0 qde
% #+END_SRC
% 
% All required dependencies for the project may now safely be installed. Those are
% listed in the file =python_requirements.txt= and are installed using =pip=.
% 
% #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
% #+CAPTION:    Installation of the projects' required dependencies.
% #+NAME:       fig:impl-pip-install
% #+BEGIN_SRC bash
% pip install -r python_requirements.txt
% #+END_SRC
% 
% All requirements and dependencies are now met and the actual implementation of
% the project may begin now.

\section{Directory structure and name-spaces}
\label{sec:directory-structure}

This chapter describes the planned directory structure as well as how the usage
of name-spaces is intended.

% The whole source code shall be placed in the =src= directory underneath the main
% directory. The creation of the single directories is not explicitly shown
% respectively done, instead the =:mkdirp= option provided by the source code
% block structure is used[fn:11:http://orgmode.org/manual/mkdirp.html#mkdirp]. The
% option has the same effect as would have =mkdir -p [directory/subdirectory]=: It
% creates all needed (sub-) directories, even when tangling a file. This prevents
% the tedious and non-interesting creation of directories within this document.
% 
% When dealing with directories and files, Python uses the term /package/ for a
% (sub-) directories and /module/ for files within directories, that is
% modules.[fn:13:https://docs.python.org/3/reference/import.html#packages]
% 
% To prevent having multiple modules having the same name, name-spaces are
% used[fn:6:https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces].
% The main name-space shall be analogous to the projects' name: =qde=. Underneath
% the source code folder =src=, each sub-folder represents a package and acts
% therefore also as a name-space.
% 
% To actually allow a whole package and its modules being imported /as modules/,
% it needs to have at least a file inside called =__init__.py=. Those files may be
% empty or they may contain regular source code such as classes or methods.
% 
% The first stage of the project shows the creation of the /editor/ component, as
% it provides the possibility of creating and editing real-time animations which
% may then be played back by the /player/ component\cite[p. 29]{osterwalder_qde_2016}.

\end{document}
