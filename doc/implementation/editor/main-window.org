*** TODO Main window

Before implementing the features of the main window, its features will be
described. The main window is the central aspect of the graphical user interface
and is hence part of the {{{verb(gui)}}} package.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Creation of the =gui= name space and initialization of the name space as module.
#+BEGIN_SRC python :tangle ../../../src/qde/editor/gui/__init__.py :noweb tangle :mkdirp yes
#+END_SRC


Its main functionality is to set up the actual user interface, containing all
the components, described by [[Components]], as widgets. Qt offers the class
=QMainWindow= from which =MainWindow= may inherit. The thoughts about the
implementation follow section [[Framework for implementation]].

The first step is setting up the necessary signals. They may not all be known at
this point and may therefore be expanded later on. As described in section
[[Components]], it would be nice if =MainWindow= would react to a request for
closing it, either by a keyboard shortcut or a menu command. However,
=MainWindow= is not able to force the =Application= to quit by itself. It would
be possible to pass =MainWindow= a reference to =Application= but that would
lead to a somewhat tight coupling and is therefore not considered as an option.
Signals and slots allow exactly such cross-layer communication without coupling
components tightly.

First, the outline of =MainWindow= is defined.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Module holding the main application window class, =MainWindow=.
#+BEGIN_SRC python :tangle ../../../src/qde/editor/gui/main_window.py :noweb tangle :mkdirp yes
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding the main application window. """

# System imports
<<main-window-system-imports>>

# Project imports
<<main-window-project-imports>>


class MainWindow(QtWidgets.QMainWindow):
    """The main window class.
    Acts as an entry point for the QDE editor application.
    """

    <<main-window-signals>>

    def __init__(self):
        """Constructor."""

        <<main-window-constructor>>

    <<main-window-methods>>

    <<main-window-slots>>
#+END_SRC

A fitting name for the signal, when the window and therefore the application,
shall be closed might be =window_closing=. The signal is introduced as follows.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition of signals for the main application window class, =MainWindow=.
#+NAME:       main-window-signals
#+BEGIN_SRC python
# Signals
window_closing = QtCore.pyqtSignal()
#+END_SRC

Now, that the signal for closing the window and the application is defined, two
additional things need to be considered: The emission of the signal by
=MainWindow= itself as well as the consumption of the signal by a slots of other
classes.

First, the emission of the signal is implemented. The signal shall be emitted
when the escape key on the keyboard is pressed or when the corresponding menu
item was selected. For the first case, the keyboard event, Qt provides luckily
events which may be used. Their outline is already provided by the parent class
=QMainWindow= and therefore the event(s) simply need to be implemented. The
event which listens to keyboard keys being pressed is called =keyPressEvent= and
provides an event-object of type =QEvent=. All there is to do, is to retrieve
the event's key by calling its =key= method and check if that key is actually
the escape key by comparing it to =Key_Escape=, provided by Qt. If this
comparison is true, the signal shall be emitted.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Implementation of the =keyPressEvent= method on the =MainWindow= class.
#+NAME:       main-window-keypressevent
#+BEGIN_SRC python
def keyPressEvent(self, event):
    """Gets triggered when a key press event is raised.

    :param event: holds the triggered event.
    :type  event: QKeyEvent
    """

    if event.key() == QtCore.Qt.Key_Escape:
        self.window_closing.emit()
    else:
        super(MainWindow, self).keyPressEvent(event)
#+END_SRC

Additionally the signal shall be emitted when selecting a corresponding menu
item. But currently there is no such menu item defined. Qt handles interactions
with menu items by using actions (=QAction=). They provide themselves a couple
of signals, one being =triggered=, which gets emitted as soon as the action was
triggered by a clicking on a menu item. As it is not possible to connect a
signal with another signal, a slot, which receives the signal, needs to be
defined. A slot is an annotated method.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The =on_quit= method, which acts as a slot when the menu item for quitting the application was triggered.
#+NAME:       main-window-slots
#+BEGIN_SRC python
@QtCore.pyqtSlot()
def on_quit(self):
    """Slot which emits the :any:`window_closing` signal.
    This slot gets triggered upon the selection of the menu item to close the
    QDE application.
    """

    self.window_closing.emit()
#+END_SRC

Now the main window is able to emit the signal it is shutting down (or
rather it would like to shut down), but so far no one is listening to that
signal, so nothing happens when that signal is being emitted.

This leads to an expansion of the main application's construction: The main
application has to create a main window an listen to its =window_closing=
signal. Luckily =Application= provides already a =quit= slot through
=QApplication=.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Expansion of setting up the main application's components by the initialization of =MainWindow= and its signals.
#+NAME:       app-application-methods-setup-components
#+BEGIN_SRC python
self.main_window = qde_main_window.MainWindow()
self.main_window.window_closing.connect(self.quit)
#+END_SRC

So far none of the additional modules have been defined as there are no
additional modules imported yet. The missing modules need to be added to the
main application as well as the main window.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Expansion of =<<app-application-project-imports>>= by the missing imports.
#+NAME:       app-application-project-imports
#+BEGIN_SRC   python
from qde.editor.gui import main_window as qde_main_window
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Expansion of =<<main-window-system-imports>>= by the missing imports.
#+NAME:       main-window-system-imports
#+BEGIN_SRC   python
from PyQt5 import QtCore
from PyQt5 import QtWidgets
#+END_SRC

Yet the constructor for the main window is still missing, so running the
application would still do nothing. Therefore the constructor for the main
window is now implemented. At the current point its solely purpose is to call
the its parent's constructor.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Constructor for the main window class =MainWindow=.
#+NAME:       main-window-constructor
#+BEGIN_SRC python
super(MainWindow, self).__init__()
#+END_SRC

Although a Python process is spawned when starting the application, the main
window is still not shown. The problem is, that the main window has no central
widget
set[fn:15:http://doc.qt.io/qt-5/qmainwindow.html#creating-main-window-components].
Setting a central widget and setting a layout for it solves this problem.

The above described task matches perfectly the second point described in section
[[Framework for implementation]]. The described task will therefore be put in a
method named =setup_ui= and the constructor will be expanded correspondingly.
The method =setup_ui= seems also a very good place for setting things like the
size of the window, setting its (object-) name and its title as well as moving
it to a position on the user's screen. To ensure that the window is not hidden
behind other windows, the method =activateWindow= coming from =QWidget= is
called.

As it is not sure at this point, if the main window will receive additional
methods, it may be wise to split =<<main-window-methods>>= up, by inserting the
yet known methods (only =setup_ui= so far) explicitly. This provides the
advantage, that new methods can easily be appended and the implemented methods
may be expanded easily as well.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The placeholder =<<main-window-methods>>= declared explicitly.
#+NAME:       main-window-methods
#+BEGIN_SRC python
<<main-window-keypressevent>>

<<main-window-setupui>>
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The method =setup_ui=, which was added to =<<main-window-methods>> before, for setting up user interface specific tasks within the main window class =MainWindow=.
#+NAME:       main-window-setupui
#+BEGIN_SRC python
def setup_ui(self):
    """Sets up the user interface specific components."""

    self.setObjectName('MainWindow')
    self.setWindowTitle('QDE')
    self.resize(1024, 768)
    self.move(100, 100)
    self.activateWindow()

    central_widget = QtWidgets.QWidget(self)
    central_widget.setObjectName('central_widget')
    grid_layout = QtWidgets.QGridLayout(central_widget)
    central_widget.setLayout(grid_layout)
    self.setCentralWidget(central_widget)
    self.statusBar().showMessage('Ready.')
#+END_SRC

Now the =setup_ui= method simply needs to be added to the constructor of the
class =MainWindow=.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The method =setup_ui= is added to the constructor of main window class =MainWindow=.
#+NAME:       main-window-constructor
#+BEGIN_SRC python
self.setup_ui()
#+END_SRC

Finally the main window has to be shown by calling its {{{verb(show)}}} method
at the end of the main application's construction.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The main window is being shown at the end of the main application's construction.
#+NAME:       app-application-constructor
#+BEGIN_SRC python

    self.main_window.show()
#+END_SRC

#+NAME: fig:editor-alpha-01
#+ATTR_LATEX: :width 0.5\textwidth :placement [H]
#+ATTR_ORG: :width 50px
#+CAPTION: The QDE editor application in a very early stage, containing only a grid layout.
[[./images/qde_alpha_01.png]]

When starting the application a plain window containing a grid layout is shown,
as can be seen in figure [[fig:editor-alpha-01]]. As written in [[Components]] and
shown in \citep[p. 29 ff.]{osterwalder_qde_2016}, the main window will contain all
the components. To ensure, that those components are shown as defined, a simple
grid layout may not provide enough possibilities.

A possible solution to reach the desired layout is to use the horizontal box
layout =QHBoxLayout= in combination with splitters. The horizontal box layout
lines up widgets horizontally where as the splitters allow splitting either
horizontally or vertically. Recalling the components from [[Components]], the following are needed:

- A scene graph, on the left of the window, covering the whole height
- A node graph on the right of the scene graph, covering as much height as
  possible
- A view for showing the properties (and therefore parameters) of the selected
  node on the right of the node graph, covering as much height as possible
- A display for rendering the selected node, on the right of the properties
  view, covering as much height as possible
- A sequencer at the right of the scene graph and below the other components at
  the bottom of the window, covering as much width as possible

To sum up, a horizontally box layout and a vertical splitter allow splitting the
main window in two halves: The left side will be used for the scene graph where
as the other side will hold the remaining components. As the sequencer is
located below the other components of the right side, a horizontal splitter is
needed for proper separation. The components above the sequencer could simply be
added to the right side of the split as a horizontal box layout builds the
layout's basis, for convenience however, additional splitters will be used. This
allows the user to re-arrange the layout to his taste. To achieve the described
layout, the following tasks are necessary:

- Create a widget for the horizontal box layout
- Create the horizontal box layout
- Add the scene graph to the horizontal box layout
- Instantiate the components of the split's right side
  - The node graph
  - The parameter view
  - The rendering view
- Create a horizontal splitter
  - Add the rendering view to it
  - Add the parameter view to it
- Create a vertical splitter
  - Add the horizontally splitter to it
  - Add the scene graph to it
- Add the vertical splitter to the horizontal box layout

The implementation of the explained layout is done in the =setup_ui= method and
is as follows. For the not yet existing widgets placeholders are used.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Lay-outing of the main window by expanding the =setup_ui= method.
#+NAME:       main-window-setupui
#+BEGIN_SRC   python

    horizontal_layout_widget = QtWidgets.QWidget(central_widget)
    horizontal_layout_widget.setObjectName('horizontal_layout_widget')
    horizontal_layout_widget.setGeometry(QtCore.QRect(12, 12, 781, 541))
    horizontal_layout_widget.setSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding,
                                           QtWidgets.QSizePolicy.MinimumExpanding)
    grid_layout.addWidget(horizontal_layout_widget, 0, 0)

    horizontal_layout = QtWidgets.QHBoxLayout(horizontal_layout_widget)
    horizontal_layout.setObjectName('horizontal_layout')
    horizontal_layout.setContentsMargins(0, 0, 0, 0)

    <<main-window-setupui-scenegraph>>
    <<main-window-setupui-nodegraph>>
    <<main-window-setupui-parameterview>>
    <<main-window-setupui-renderview>>

    horizontal_splitter = QtWidgets.QSplitter()
    <<main-window-setupui-add-renderview-to-horizontal-splitter>>
    <<main-window-setupui-add-parameterview-to-horizontal-splitter>>

    vertical_splitter = QtWidgets.QSplitter()
    vertical_splitter.setOrientation(QtCore.Qt.Vertical)
    vertical_splitter.addWidget(horizontal_splitter)
    <<main-window-setupui-add-nodegraph-to-vertical-splitter>>

    horizontal_layout.addWidget(vertical_splitter)
#+END_SRC

All the above taken actions to lay out the main window change nothing in the
window's yet plain appearance. This is quite obvious, as none of the actual
components are implemented yet.

The most straight-forward component to implement may be scene graph, so this is
a good starting point for the implementation of the remaining components.
