As logging is a very central and basic functionality, the module is placed in
the {{{verb(foundation)}}} layer.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+BEGIN_SRC python :tangle ../src/qde/editor/foundation/__init__.py :noweb tangle :comments link :mkdirp yes :exports none
#+END_SRC

Logging shall be provided on a class-basis, meaning that each class (which wants
to log something) needs to instantiate a logger and use a corresponding handler.

Python's logging module uses the basic configuration by default, calling the
{{{verb(basicConfig)}}} whenever something is logged for the first time. This
creates a stream handler with a basic formatter. However, the logging facility
may extensively be
configured[fn:6cacbc0479c63b5:https://docs.python.org/3/library/logging.html].

For example, the logging may be configured by using the ``Configuration API'',
which offers configuring the logging facility by using a dictionary. A
dictionary may very easily be created by using a JSON file.

As mentioned before, logging is a central aspect of the application. Therefore
it is the task of the main application to set up the logging facility which may
then be used by other classes through a decorator.

The main application shall therefore set up the logging facility as follows:

- Use either an external logging configuration or the default logging configuration.

- When using an external logging configuration

  - The location of the external logging configuration may be set by the
    environment variable {{{verb(QDE_LOG_CFG)}}}.

  - Is no such environment variable set, the configuration file is assumed to be
    named {{{verb(logging.json)}}} and to reside in the application's main
    directory.

- When using no external logging configuration, the default logging configuration
  defined by {{{verb(basicConfig)}}} is used.

  - Always set a level when using no external logging configuration, the default
    being {{{verb(INFO)}}}.

This leads to two parameters when setting up the logging configuration: The
default path of the external logging configuration and the default logging
level when using no external logging configuration. The implementation of
setting up the logging facility can be seen in listing
[[lst:app-application-methods-setup-logging]].

:APP_APPLICATION_METHODS_SETUP_LOGGING:
#+NAME:     app-application-methods-setup-logging
#+BEGIN_SRC python :exports none
def setup_logging(self,
                  default_path='logging.json',
                  default_level=logging.INFO):
    """Setup logging configuration"""

    env_key  = 'QDE_LOG_CFG'
    env_path = os.getenv(env_key, None)
    path     = env_path or default_path

    if os.path.exists(path):
        with open(path, 'rt') as f:
            config = json.load(f)
            logging.config.dictConfig(config)
    else:
        logging.basicConfig(level=default_level)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-application-methods
#+BEGIN_SRC python :exports none
<<app-application-methods-setup-logging>>
#+END_SRC

#+NAME:       lst:app-application-methods-setup-logging
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The =setup_logging= method is being added to the main application class =Application=.
#+BEGIN_SRC python :noweb yes

<app-application-methods>+=
   <<app-application-methods-setup-logging>>
#+END_SRC
:END:

:APP_APPLICATION_CONSTRUCTOR_CALL_SETUP_LOGGING:
#+NAME:     app-application-constructor-call-setup-logging
#+BEGIN_SRC python :exports none
    self.setup_logging()
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-application-constructor
#+BEGIN_SRC python :exports none
<<app-application-constructor-call-setup-logging>>
#+END_SRC

#+NAME:       lst:app-application-constructor-call-setup-logging
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The call of the =setup_logging= method is being added to the main application's constructor.
#+BEGIN_SRC python :noweb yes
<app-application-constructor>+=
   <<app-application-constructor-call-setup-logging>>
#+END_SRC
:END:

:APP_APPLICATION_SYSTEM_IMPORTS:
#+NAME:     app-application-system-imports-logging
#+BEGIN_SRC python :exports none
import logging
import logging.config
import os
import json
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-application-system-imports
#+BEGIN_SRC python :exports none
<<app-application-system-imports-logging>>
#+END_SRC

#+NAME:       lst:app-application-system-imports-logging
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The =logging= module is added to the application module's system imports.
#+BEGIN_SRC python :noweb yes
<app-application-system-imports>+=
    <<app-application-system-imports-logging>>
#+END_SRC
:END:

For not having only basic logging available, a logging configuration is defined
and provided by listing [[lst:logging-configuration]]. The logging configuration
provides three handlers: a console handler, which logs debug messages to STDOUT,
a info file handler, which logs informational messages to a file named
{{{verb(info.log)}}}, and a error file handler, which logs errors to a file
named {{{verb(error.log)}}}. The default level is set to debug and all handlers
are used.

:LOGGING_JSON:
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:    lst:logging-configuration
#+CAPTION: The configuration of the logging facility in JSON format.
#+BEGIN_SRC json :tangle ../logging.json :noweb tangle
{
    "version": 1,
    "disable_existing_loggers": false,
    "formatters": {
        "simple": {
            "format": "%(asctime)s - %(levelname)-7s - %(name)s.%(funcName)s::%(lineno)s: %(message)s"
        }
    },

    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "level": "DEBUG",
            "formatter": "simple",
            "stream": "ext://sys.stdout"
        },

        "info_file_handler": {
            "class": "logging.handlers.RotatingFileHandler",
            "level": "INFO",
            "formatter": "simple",
            "filename": "info.log",
            "maxBytes": 10485760,
            "backupCount": 20,
            "encoding": "utf8"
        },

        "error_file_handler": {
            "class": "logging.handlers.RotatingFileHandler",
            "level": "ERROR",
            "formatter": "simple",
            "filename": "errors.log",
            "maxBytes": 10485760,
            "backupCount": 20,
            "encoding": "utf8"
        }
    },

    "root": {
        "level": "DEBUG",
        "handlers": ["console", "info_file_handler", "error_file_handler"],
        "propagate": "no"
    }
}
#+END_SRC
:END:

The logging configuration as shown in listing [[lst:logging-configuration]] allows
to get an arbitrarily named logger which uses that configuration.
 
As stated before, logging shall be provided on a class basis. This has the
consequence, that each class has to instantiate a logging instance. To prevent
the repetition of the same code fragment over and over, Python's decorator
pattern is used[fn:b072baf8ac6840a:https://www.python.org/dev/peps/pep-0318/].

The decorator will be implemented as a method named {{{verb(with_logger)}}} in
the {{{verb(common)}}} module. All, that this method does is to set the logger
name to the name of the module it is in combined with his own name. It then
attaches a property named {{{verb(logger)}}} to the class that calls the method.
The method has therefore the following functionality.

- Provide a name based on the current module and class.
  #+NAME: logger-name
  #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
  #+CAPTION:    Setting of the name based on the current module and class name.
  #+BEGIN_SRC python
logger_name = "{module_name}.{class_name}".format(
    module_name=cls.__module__,
    class_name=cls.__name__
)
  #+END_SRC
- Provide an easy to use interface for logging.
  #+NAME: logger-return-logger
  #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
  #+CAPTION:    The logger is being attached to the class itself.
  #+BEGIN_SRC python
cls.logger = logging.getLogger(logger_name)

return cls
  #+END_SRC

This definition of the functionality allows the actual implementation of the
logging facility which follows in listing [[lst:foundation-common]].
  
:FOUNDATION_COMMON_LOGGING:
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Implementation of the logging facility as a method inside the =common=  module.
#+NAME:       lst:foundation-common
#+BEGIN_SRC python :tangle ../src/qde/editor/foundation/common.py :noweb yes :comments link :mkdirp yes
# -*- coding: utf-8 -*-

"""Module holding common helper methods."""

# System imports
import logging
<<foundation-common-system-imports>>

# Project imports
<<foundation-common-project-imports>>


def with_logger(cls):
    """Add a logger instance (using a stream handler) to the given class.

    :param cls: the class which the logger shall be added to.
    :type  cls: a class of type cls.

    :return: the class with the logger instance added.
    :rtype:  a class of type cls.
    """

    <<logger-name>>
    <<logger-return-logger>>
 #+END_SRC
:END:

The implementation of the {{{verb(with_logger)}}} method allows the usage of the
logging facility as a decorator as shown in the example in listing
[[lst:with-logger-example]].

:WITH_LOGGER_EXAMPLE:
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: lst:with-logger-example
#+CAPTION: The class =SomeClass= gets annotated by the =with_logger= decorator from the =common= module. The whole class is then able to use the =logger= property as can be seen in method =some_method=.
#+BEGIN_SRC python
# Project imports
from qde.editor.foundation import common

@common.with_logger
def SomeClass(object):
    """This class provides literally nothing and is used only to demonstrate the
    usage of the logging decorator."""

    def some_method():
        """This method does literally nothing and is used only to demonstrate the
        usage of the logging decorator."""

        self.logger.debug(("I am some logging entry used for"
                           "demonstration purposes only."))
 #+END_SRC
 :END:

This brings us back to original intention: log whenever a scene is added or
removed in the scene graph view. To implement the logging three steps are
necessary. First, the {{{verb(common)}}} module needs to be imported.

:GUI_SCENE_PROJECT_IMPORTS_02:
#+NAME: gui-scene-project-imports-02
#+BEGIN_SRC python :exports none
from qde.editor.foundation import common
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: gui-scene-project-imports
#+BEGIN_SRC python :exports none
<<gui-scene-project-imports-02>>
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: lst:gui-scene-project-imports-02
#+CAPTION: The =common= module is added to the project imports of the =scene= module residing in the =gui= layer.
#+BEGIN_SRC python :noweb yes
<gui-scene-project-imports>+=
    <<gui-scene-project-imports-02>>
#+END_SRC
:END:

Second, the class needs the {{{verb(with_logger)}}} decorator.

:GUI_SCENE_GRAPH_CLASS_DECORATOR_01:
#+NAME: gui-scene-graph-class-decorators-01
#+BEGIN_SRC python :exports none
@common.with_logger
#+END_SRC

#+NAME: gui-scene-graph-class-decorators
#+BEGIN_SRC python :exports none
<<gui-scene-graph-class-decorators-01>>
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: lst:gui-scene-graph-class-decorators-01
#+CAPTION: The =with_logger= decorator is added to the scene graph view class's decorators, {{{code-ref(fig:gui-scene-graph)}}}.
#+BEGIN_SRC python :noweb yes :tangle yes
<gui-scene-graph-class-decorators>+=
    <<gui-scene-graph-class-decorators-01>>
#+END_SRC
:END:

And third, the actual logging needs to be added to the corresponding methods.

:GUI_SCENE_GRAPH_SLOTS_02_LOGGING:
#+NAME: gui-scene-graph-slots-on-tree-item-added-logging
#+BEGIN_SRC python :exports none
self.logger.debug("A new scene graph item was added.")
#+END_SRC

#+NAME: gui-scene-graph-slots-on-tree-item-added
#+BEGIN_SRC python :exports none
        <<gui-scene-graph-slots-on-tree-item-added-logging>>
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: lst:gui-scene-graph-slots-on-tree-item-added-logging
#+CAPTION: A debug message is being logged, whenever a new scene is added to the scene graph within the scene graph view.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-slots-on-tree-item-added>+=
    <<gui-scene-graph-slots-on-tree-item-added-logging>>
#+END_SRC
:END:

:GUI_SCENE_GRAPH_SLOTS_03_LOGGING:
#+NAME: gui-scene-graph-slots-on-tree-item-removed-logging
#+BEGIN_SRC python :exports none
self.logger.debug((
    "The scene graph item at row {row} "
    "and column {column} was removed."
).format(
    row=selected_item.row(),
    column=selected_item.column()
))
#+END_SRC

#+NAME: gui-scene-graph-slots-on-tree-item-removed
#+BEGIN_SRC python :exports none
        <<gui-scene-graph-slots-on-tree-item-removed-logging>>
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: lst:gui-scene-graph-slots-on-tree-item-removed-logging
#+CAPTION: A debug message is being logged, whenever an existing scene is removed from the scene graph within the scene graph view.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-slots-on-tree-item-removed>+=
    <<gui-scene-graph-slots-on-tree-item-removed-logging>>
#+END_SRC
:END:

Whenever the =a= or the =delete= key is being pressed now, when the scene graph
view is focused, the corresponding log messages appear in the standard output,
hence the console. This behavior can be seen in figure [[fig:editor-alpha-04]].

#+NAME: fig:editor-alpha-04
#+ATTR_LATEX: :width 0.5\textwidth :placement [H]
#+ATTR_ORG: :width 50px
#+CAPTION: The console output when the =a= and the =delete= keys are pressed multiple times with the scene graph view being the active widget.
[[./images/qde_alpha_04.png]]

Now, having the scene graph component as well as an interface to log messages
throughout the application implemented, the next component may be approached. A
very interesting aspect to face would be the rendering. But for being able to
render something, there actually needs to exist something to render: nodes.
Nodes are being represented within the node graph. So this is a good point to
begin with the implementation of the node graph.
