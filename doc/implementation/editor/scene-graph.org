The scene graph component does, as also the other components do, have two
aspects to consider: A graphical aspect as well as its data structure. As
written in section [[Layering]], each component has a view --- residing in the /gui/
package ---, a model --- residing in the /domain/ package --- and a controller
acting as workflow object --- residing in the /application/ package.

The {{{verb(SceneGraphController)}}} class will manage instances of scene models
whereas the {{{verb(SceneGraphView)}}} will display a tree of scenes, starting
with a root scene of type {{{verb(SceneModel)}}}.

The least tedious of those aspects may be the scene model, {{{verb(SceneModel)}}}, so
the scene model is implemented first.

As at this point its functionality is not known, its implementation is rather
dull. It is composed of solely an empty constructor.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Creation of the =domain= name space and initialization of the name space as module.
#+BEGIN_SRC python :tangle ../src/qde/editor/domain/__init__.py :noweb tangle :mkdirp yes
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Scene module inside the =domain= package, holding the =SceneModel= class.
#+BEGIN_SRC python :tangle ../src/qde/editor/domain/scene.py :noweb tangle :mkdirp yes
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding scene related aspects concerning the domain layer. """

# System imports
<<domain-scene-system-imports>>

# Project imports
<<domain-scene-project-imports>>


class SceneModel(object):
    """The scene model.
    It is used as a base class for scene instances within the scene graph.
    """

    <<domain-scene-signals>>

    <<domain-scene-constructor>>

    <<domain-scene-methods>>

    <<domain-scene-slots>>
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Constructor of the scene model class, =SceneModel=.
#+NAME:       domain-scene-constructor
#+BEGIN_SRC python
def __init__(self):
    pass
#+END_SRC

Scenes may now be instantiated, it is however important to do the management of
scenes in a controlled manner. This is where the specific controllers within the
{{{verb(application)}}} layer come in, as described in more detail in section
[[Layering]]. Therefore the class {{{verb(SceneGraphController)}}} will now be
implemented, for being able to manage scenes.

As the scene graph shall be built as a tree structure, an appropriate data
structure is needed. Qt provides the {{{verb(QTreeWidget)}}} class, but that
class is in this case not suitable, as it does not separate the data from its
representation, as stated by Qt: ``Developers who do not need the flexibility of
the Model/View framework can use this class to create simple hierarchical lists
very easily. A more flexible approach involves combining a QTreeView with a
standard item model. This allows the storage of data to be separated from its
representation.''[fn:18:http://doc.qt.io/qt-5/qtreewidget.html#details]

Therefore the class
{{{verb(QAbstractItemModel)}}}[fn:e3eb4d58d8c947d:http://doc.qt.io/qt-5/qabstractitemmodel.html]
is chosen for implementation. Before implementing the actual methods, it is
important to think about the attributes, that the scene graph controller will
have. According to the class's documentation, some methods must be implemented
at very least: ``When subclassing QAbstractItemModel, at the very least you must
implement index(), parent(), rowCount(), columnCount(), and data(). These
functions are used in all read-only models, and form the basis of editable
models.''

For being able edit the nodes of the scene graph and to have a custom header
displayed, further methods have to be implemented: ``To enable editing in your
model, you must also implement setData(), and reimplement flags() to ensure that
ItemIsEditable is returned. You can also reimplement headerData() and
setHeaderData() to control the way the headers for your model are presented.''

From the remarks above the attributes may be defined. As the scene graph is
implemented as a tree structure, it must have a *root node*, which is of type
{{{verb(SceneGraphViewModel)}}} (coming from the {{{verb(gui_domain)}}} layer).
Whenever a scene is added as a node, the item model needs to be informed for
updating the display. This happens by emitting the {{{verb(rowsInserted)}}}
signal, which is already given by the {{{verb(QAbstractItemModel)}}} class. This
signal needs the current model index as well as the first and last position as
parameters. The current model index represents the parent of the item to add,
whereas the item will be inserted between the two given positions, first and
last. Concerning the model index the Qt documentation states: ``An invalid model
index can be constructed with the QModelIndex constructor. Invalid indexes are
often used as parent indexes when referring to top-level items in a model.''
Therefore for creating the initial node of the scene graph, the root node, the
constructor of {{{verb(QModelIndex)}}} will be used.
As *header data* the name of the scenes as well as the number of nodes a scene
contains shall be displayed.

Speaking of signals, brings up the definition of signals for the scene graph
controller. To prevent coupling, two signals are added: {{{verb(scene_added)}}}
and {{{verb(scene_removed)}}}. The first will be emitted whenever a new node is
inserted into the scene graph by {{{verb(insertRows)}}} being called. The latter
is emitted whenever an existing node is removed from the scene graph by calling
the {{{verb(removeRows)}}} method.

But what currently is missing for being able to implement a first draft of the
scene graph, is the view model {{{verb(SceneGraphViewModel)}}}. View models are
used to visually represent something within the graphical user interface and
they provide an interface to the {{{verb(domain)}}} layer. To this point, a
simple reference in terms of an attribute is used, which may be changed later
on. Concerning the user interface, a view model must fulfill the requirements
posed by the user interface's corresponding component. In terms of the scene
graph the view model must provide at least a name and a row. Additionally, as
already mentioned, a reference to the domain object is being added. The class
inherits from {{{verb(QObject)}}} as this base class already provides a tree
structure, which fits the structure of the scene graph perfectly.

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Creation of the =gui_domain= name space and initialization of the name space as module.
#+BEGIN_SRC python :tangle ../src/qde/editor/gui_domain/__init__.py :noweb tangle :mkdirp yes
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Scene module inside the =gui_domain= package.
#+NAME:       guidomain-scene
#+BEGIN_SRC python :tangle ../src/qde/editor/gui_domain/scene.py :noweb tangle :mkdirp yes
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding scene related aspects concerning the gui_domain layer. """

# System imports
from PyQt5 import Qt
from PyQt5 import QtCore
<<guidomain-scene-system-imports>>

# Project imports
<<guidomain-scene-project-imports>>

<<guidomain-scene-body>>
#+END_SRC

#+NAME: guidomain-scene-scenegraphviewmodel
#+BEGIN_SRC python :exports none
class SceneGraphViewModel(Qt.QObject):
    """View model representing scene graph items.

    The SceneGraphViewModel corresponds to an entry within the scene graph. It
    is used by the QAbstractItemModel class and must therefore at least provide
    a name and a row.
    """

    <<guidomain-scene-scenegraphviewmodel-signals>>

    <<guidomain-scene-scenegraphviewmodel-constructor>>

    <<guidomain-scene-scenegraphviewmodel-methods>>

    <<guidomain-scene-scenegraphviewmodel-slots>>
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       guidomain-scene-body
#+BEGIN_SRC python :exports none
<<guidomain-scene-scenegraphviewmodel>>
#+END_SRC

#+NAME:       lst:guidomain-scene-scenegraphviewmodel
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition of the body of the =scene= module, which is in the =gui_domain= layer.
#+BEGIN_SRC python :noweb yes
<guidomain-scene-body>=
    <<guidomain-scene-scenegraphviewmodel>>
#+END_SRC

#+NAME: guidomain-scene-scenegraphviewmodel-constructor
#+CAPTION:    Constructor for the scene graph view model, =SceneGraphViewModel=.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+BEGIN_SRC python
# .. py:function::
def __init__(
        self,
        row,
        domain_object,
        name=QtCore.QCoreApplication.translate('SceneGraphViewModel', 'New scene'),
        parent=None
):
    """Constructor.

    :param row:           The row the view model is in.
    :type  row:           int
    :param domain_object: Reference to a scene model.
    :type  domain_object: qde.editor.domain.scene.SceneModel
    :param name:          The name of the view model, which will be displayed in
                          the scene graph.
    :type  name:          str
    :param parent:        The parent of the current view model within the scene
                          graph.
    :type parent:         qde.editor.gui_domain.scene.SceneGraphViewModel
    """

    super(SceneGraphViewModel, self).__init__(parent)
    self.row  = row
    self.domain_object = domain_object
    self.name = name
#+END_SRC

Now, with the scene graph view model being available, the scene graph controller
may finally be implemented.

:APP_SCENEGRAPH:
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       lst:app-scenegraph
#+CAPTION:    The outline of the =SceneGraphController= class, inside the =application= package.
#+BEGIN_SRC python :tangle ../src/qde/editor/application/scene_graph.py :noweb tangle :mkdirp yes
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding scene graph related aspects concerning the application layer.
"""

# System imports
from PyQt5 import QtCore
<<app-scenegraph-system-imports>>

# Project imports
from qde.editor.domain     import scene as domain_scene
from qde.editor.gui_domain import scene as guidomain_scene
<<app-scenegraph-project-imports>>


class SceneGraphController(QtCore.QAbstractItemModel):
    """The scene graph controller.
    A controller for managing the scene graph by adding, editing and removing
    scenes.
    """

    scene_added = QtCore.pyqtSignal(domain_scene.SceneModel)
    scene_removed = QtCore.pyqtSignal(domain_scene.SceneModel)
    <<app-scenegraph-controller-signals>>

    def __init__(self, root_node_domain_object, parent=None):
        """Constructor.

        :param root_node_domain_object: The domain object of the root node of
                                        the scene graph view model.
        :type root_node_domain_object:  qde.editor.domain.scene.SceneModel
        :param parent: The parent of the current view model within the scene
                       graph.
        :type parent:  qde.editor.gui_domain.scene.SceneGraphViewModel
        """

        super(SceneGraphController, self).__init__(parent)
        self.header_data = [
            QtCore.QCoreApplication.translate(__class__.__name__, 'Name'),
            QtCore.QCoreApplication.translate(__class__.__name__, '# Nodes')
        ]
        self.root_node = guidomain_scene.SceneGraphViewModel(
            row=0,
            domain_object=root_node_domain_object,
            name=QtCore.QCoreApplication.translate(__class__.__name__, 'Root scene')
        )
        self.rowsInserted.emit(QtCore.QModelIndex(), 0, 1)
        <<app-scenegraph-controller-constructor>>

    <<app-scenegraph-controller-methods>>

    <<app-scenegraph-controller-slots>>
#+END_SRC
:END:

At this point data structures in terms of a (data-) model, which holds the
actual, for the scene graph relevant data of a scene, and a view model, which
holds the data relevant for the user interface, are implemented. Further a
controller for handling the flow of the data for both models is implemented.
What is still missing, is the actual representation of the scene graph in terms
of a view.

Qt offers a plethora of widgets for implementing views. One such widget is
{{{verb(QTreeView)}}}, which ``implements a tree representation of items from a
model. This class is used to provide standard hierarchical lists that were
previously provided by the QListView class, but using the more flexible approach
provided by Qt's model/view
architecture.''[fn:f377826acb87691:http://doc.qt.io/qt-5/qtreeview.html#details]

:GUI_SCENE:
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: fig:gui-scene-graph
#+CAPTION:    The outline of the =SceneGraphView= class, within the =scene= module of the =gui= package.
#+BEGIN_SRC python :tangle ../src/qde/editor/gui/scene.py :noweb tangle :mkdirp yes
#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Module holding scene related aspects concerning the graphical user interface layer.
"""

# System imports
from PyQt5 import QtWidgets
<<gui-scene-system-imports>>

# Project imports
<<gui-scene-project-imports>>


<<gui-scene-graph-class-decorators>>
class SceneGraphView(QtWidgets.QTreeView):
    """The scene graph view widget.
    A widget for displaying and managing the scene graph.
    """

    # Signals
    <<gui-scene-graph-signals>>

    def __init__(self, parent=None):
        """Constructor.

        :param parent:        The parent of the current view widget.
        :type parent:         QtCore.QObject
        """

        super(SceneGraphView, self).__init__(parent)
        <<gui-scene-graph-constructor>>

    <<gui-scene-graph-methods>>

    # Slots
    <<gui-scene-graph-slots>>
#+END_SRC
:END:

Having the scene graph view implemented as a widget, it is now necessary to add
the widget to the main window and initializing it. As described in section
TODO, the widget is added to the horizontal layout, using the earlier defined
{{{verb(main-window-setupui-scenegraph)}}} placeholder. For being able to
instantiate a scene graph widget, its module must be imported as well. The
maximum width of the widget is limited by using the {{{verb(setMaximumWidth)}}}
method.

:MAIN_WINDOW_PROJECT_IMPORTS:
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Import of the =scene= module from the =gui= layer.
#+NAME:       main-window-project-imports
#+BEGIN_SRC python
from qde.editor.gui import scene as guiscene
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The scene graph widget is being initialized and added to the horizontal layout.
#+NAME:       main-window-setupui-scenegraph
#+BEGIN_SRC python
self.scene_graph_widget = guiscene.SceneGraphView()
self.scene_graph_widget.setObjectName('scene_graph')
self.scene_graph_widget.setMaximumWidth(300)
horizontal_layout.addWidget(self.scene_graph_widget)
#+END_SRC
:END:

When starting the editor application now, after implementing and adding the
scene graph widget, the widget appears on the left side of the main window. It
does not provide any functionality yet.

#+NAME: fig:editor-alpha-02
#+ATTR_LATEX: :width 0.5\textwidth :placement [H]
#+ATTR_ORG: :width 50px
#+CAPTION: The QDE editor application having the scene graph widget added, which is visible as a blank, white rectangle on the left of the window.
[[./images/qde_alpha_02.png]]

For finally being able to manage scenes within the scene graph, a few aspects
are still missing, which will be tackled now.

First of all, the scene graph appears to hold no data at all. This is not
surprising, as no scene nodes were added by now, which might be a good point to
start with. Actually this is not the entire truth, as the root node (view model)
was already added within the scene graph controller. The controller emits the
signal, that a row was inserted, but no other component is receiving this
signal. Obviously this could be achieved by connecting the scene graph
controller and the scene graph view, but as Qt's model/view approach is at least
partially used, simply setting the view's model leads to the same result while
providing greater functionality.

:APP_APPLICATION_METHODS_SETUP_CONNECTIONS_01:
#+NAME:       app-application-methods-setup-connections-01
#+BEGIN_SRC python :exports none
self.main_window.scene_graph_widget.setModel(
    self.scene_graph_controller
)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       lst:app-application-methods-setup-connections-01
#+CAPTION:    The method =setup_connections= being defined by setting the scene graph widget's model.
#+BEGIN_SRC python
<app-application-methods-setup-connections>=
    <<app-application-methods-setup-connections-01>>
#+END_SRC

#+NAME:       app-application-methods-setup-connections
#+BEGIN_SRC python :exports none
<<app-application-methods-setup-connections-01>>
#+END_SRC
:END:

The component that ties the layers together, is, as previously described, the
main application. This means, that the main application has to provide all the
necessary data structures and controllers. Regarding the scene graph this means
setting up a root scene (as a domain-/data-model) and setting up the scene graph
controller. As the main application's layer, the {{{verb(application)}}} layer,
is directly below the layer of the view models, {{{verb(gui_domain)}}} this
opposes no problem.

Therefore the root scene as well as the scene graph controller will be
implemented in the main application's {{{verb(setup_components)}}} method,
whereas setting the scene graph widget's model will be implemented in the
{{{verb(setup_connections)}}} method.

:APP_APPLICATION_METHODS_SETUP_COMPONENTS:
#+NAME:     app-application-methods-setup-components-01
#+BEGIN_SRC python :exports none
root_scene = scene.SceneModel()
self.scene_graph_controller = scene_graph.SceneGraphController(root_scene)
#+END_SRC

#+CAPTION:    The method =setup_components= being expanded by the creation of the root scene as well as the scene graph controller.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+BEGIN_SRC python
<app-application-methods-setup-components>+=
    <<app-application-methods-setup-components-01>>
#+END_SRC

#+NAME:       app-application-methods-setup-components
#+BEGIN_SRC python :exports none
<<app-application-methods-setup-components-01>>
#+END_SRC
:END:

The necessary imports are still missing however, so those are added to the main
application's imports.

:APP_APPLICATION_PROJECT_IMPORTS:
#+NAME:       app-application-project-imports
#+BEGIN_SRC python :exports none
from qde.editor.domain import scene
from qde.editor.application import scene_graph
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Expansion of the main application's imports by the necessary packages.
#+BEGIN_SRC python :noweb yes
<app-application-project-imports>+=
    <<app-application-project-imports>>
#+END_SRC
:END:

The application is still not showing the desired result: The display of the
scene graph in form of a tree containing the root node. When looking at the
outputs of the application, the messages as seen in listing [[lst:app-error-01]] can
be observed.

#+CAPTION: Output (erroneous) when running the editor application.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: lst:app-error-01
#+BEGIN_SRC bash
NotImplementedError: QAbstractItemModel.columnCount() is abstract and must be overridden
NotImplementedError: QAbstractItemModel.rowCount() is abstract and must be overridden
#+END_src

The messages from listing [[lst:app-error-01]] state, that not all of the necessary
methods from the sub-classed {{{verb(QAbstractItemModel)}}} are implemented yet.
Currently the methods {{{verb(columnCount)}}} and {{{verb(rowCount)}}} are
missing. Those methods return ``the number of columns for the children of the
given
parent''[fn:83abdf14c73abab:http://doc.qt.io/qt-5/qabstractitemmodel.html#columnCount]
and ``the number of rows under the given
parent''[fn:76294354838b8f1:http://doc.qt.io/qt-5/qabstractitemmodel.html#rowCount]
respectively. The implementation of those missing methods are as follows in
listing [[lst:app-scenegraph-controller-methods-01]]. The method
{{{verb(columnCount)}}} is trivial, as there will always be only two columns (as
defined by the header in listing [[lst:app-scenegraph]]): The name of the scene and
the number of nodes it contains. The method {{{verb(rowCount)}}} shall return
=1= if the parent is invalid, otherwise it shall return the parent's children.

:APP_SCENEGRAPH_CONTROLLER_METHODS:
#+NAME:       app-scenegraph-controller-methods-column-count
#+BEGIN_SRC python :exports none
def columnCount(self, parent):
    """Return the number of columns for the children of the given parent.

    :param parent: The index of the item in the scene graph, which the
                    column count shall be returned for.
    :type  parent: QtCore.QModelIndex

    :return: the number of columns for the children of the given parent.
    :rtype:  int
    """

    return len(self.header_data)
#+END_SRC

#+NAME:       app-scenegraph-controller-methods-row-count
#+BEGIN_SRC python :exports none
def rowCount(self, parent):
    """Return the number of rows for the children of the given parent.

    :param parent: The index of the item in the scene graph, which the
                    row count shall be returned for.
    :type  parent: QtCore.QModelIndex

    :return: the number of rows for the children of the given parent.
    :rtype:  int
    """

    if not parent.isValid():
        return 1

    # Get the actual object stored by the parent. In this case it is a
    # SceneGraphViewModel.
    node = parent.internalPointer()

    return len(node.children())
#+END_SRC

#+NAME:       app-scenegraph-controller-methods
#+BEGIN_SRC python :exports none
<<app-scenegraph-controller-methods-column-count>>

<<app-scenegraph-controller-methods-row-count>>
#+END_SRC

#+CAPTION: The code block =<<app-scenegraph-controller-methods>>=, defining the methods =columnCount= and =rowCount= within the scene controller.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       lst:app-scenegraph-controller-methods-01
#+BEGIN_SRC python :noweb yes

<app-scenegraph-controller-methods>=
    <<app-scenegraph-controller-methods-column-count>>

    <<app-scenegraph-controller-methods-row-count>>
#+END_SRC
:END:

When running the application now, there is still an error message, although a
new one as can be seen in listing [[lst:app-error-02]].

#+CAPTION: Output (erroneous) when running the editor application.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: lst:app-error-02
#+BEGIN_SRC bash
NotImplementedError: QAbstractItemModel.index() is abstract and must be overridden
#+END_src

This time the {{{verb(index)}}} method is missing in the scene controller.
According the documentation, the method ``returns the index of the item in the
model specified by the given row, column and parent
index.''[fn:14309fdf586d8fa9:http://doc.qt.io/qt-5/qabstractitemmodel.html#index]
Furthermore, ``when reimplementing this function in a subclass, call
createIndex() to generate model indexes that other components can use to refer
to items in your
model.''[fn:c387c6b498f1eca:http://doc.qt.io/qt-5/qabstractitemmodel.html#index]

The implementation of the missing method {{{verb(index)}}} is as follows in
listing [[lst:app-scenegraph-controller-methods-02]]. The method needs to return the
index of the given row and column for the given parent. There are two cases
however: either the parent is valid or it is not. In the former case, the scene
graph view model of the parent is extracted and an index based on the row, the
column and the child node at the given row as parent is being created. In the
latter case, when the given parent is not valid, an index based on the scene
graph's root node is created.

:APP_SCENEGRAPH_CONTROLLER_METHODS_INDEX:
#+NAME:       app-scenegraph-controller-methods-index
#+BEGIN_SRC python :exports none
def index(self, row, column, parent=QtCore.QModelIndex()):
    """Return the index of the item in the model specified by the given row,
    column and parent index.

    :param row: The row for which the index shall be returned.
    :type  row: int
    :param column: The column for which the index shall be returned.
    :type column: int
    :param parent: The parent index of the item in the model. An invalid model
                   index is given as the default parameter.
    :type parent: QtQore.QModelIndex

    :return: the model index based on the given row, column and the parent
             index.
    :rtype: QtCore.QModelIndex
    """

    # If the given parent (index) is not valid, create a new index based on the
    # currently set root node
    if not parent.isValid():
        return self.createIndex(row, column, self.root_node)

    # The internal pointer of the the parent (index) returns a scene graph view
    # model
    parent_node = parent.internalPointer()
    child_nodes = parent_node.children()

    return self.createIndex(row, column, child_nodes[row])
#+END_SRC

#+NAME:       app-scenegraph-controller-methods
#+BEGIN_SRC python :exports none

<<app-scenegraph-controller-methods-index>>
#+END_SRC

#+CAPTION: The code block =<<app-scenegraph-controller-methods>>=, is expanded by the =index= method within the scene controller.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       lst:app-scenegraph-controller-methods-02
#+BEGIN_SRC python :noweb yes
<app-scenegraph-controller-methods>+=
    <<app-scenegraph-controller-methods-index>>
#+END_SRC
:END:

Although the scene graph is showing now two columns when running the editor
application, there are still error messages, as shown in listing [[lst:app-error-03]].

#+CAPTION: Output (erroneous) when running the editor application.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME: lst:app-error-03
#+BEGIN_SRC bash
NotImplementedError: QAbstractItemModel.parent() is abstract and must be overridden
NotImplementedError: QAbstractItemModel.data() is abstract and must be overridden
#+END_SRC

The methods {{{verb(parent)}}} and {{{verb(data)}}} are missing from the
implementation. The Qt documentation states about {{{verb(parent)}}}:
``Returns the parent of the model item with the given index. If the item has no
parent, an invalid QModelIndex is returned.

A common convention used in models that expose tree data structures is that only
items in the first column have children. For that case, when reimplementing this
function in a subclass the column of the returned QModelIndex would be 0.

When reimplementing this function in a subclass, be careful to avoid calling
QModelIndex member functions, such as QModelIndex::parent(), since indexes
belonging to your model will simply call your implementation, leading to
infinite
recursion.''[fn:3c3bede78fe52b8:http://doc.qt.io/qt-5/qabstractitemmodel.html#parent]

Those remarks lead to the implementation, that can be seen in listing
[[lst:app-scenegraph-controller-methods-03]].

:APP_SCENEGRAPH_CONTROLLER_METHODS_PARENT:
#+NAME:       app-scenegraph-controller-methods-parent
#+BEGIN_SRC python :exports none
def parent(self, model_index):
    """Return the parent of the model item with the given index. If the item has
    no parent, an invalid QModelIndex is returned.

    :param model_index: The model index which the parent model index shall be
                        derived for.
    :type model_index: int

    :return: the model index of the parent model item for the given model index.
    :rtype: QtCore.QModelIndex
    """

    if not model_index.isValid():
        return QtCore.QModelIndex()

    # The internal pointer of the the model index returns a scene graph view
    # model.
    node = model_index.internalPointer()
    if node.parent() is None:
        return QtCore.QModelIndex()
    else:
        return self.createIndex(node.parent().row, 0, node.parent())
#+END_SRC

#+NAME:       app-scenegraph-controller-methods
#+BEGIN_SRC python :exports none

<<app-scenegraph-controller-methods-parent>>
#+END_SRC

#+CAPTION: The code block =<<app-scenegraph-controller-methods>>=, is expanded by the =parent= method within the scene controller.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       lst:app-scenegraph-controller-methods-03
#+BEGIN_SRC python :noweb yes
<app-scenegraph-controller-methods>+=
    <<app-scenegraph-controller-methods-parent>>
#+END_SRC
:END:

About the {{{verb(data)}}} method, the Qt documentation says the following:

``Returns the data stored under the given role for the item referred to by the
index.

Note: If you do not have a value to return, return an invalid QVariant instead
of returning
0.''[fn:4e8bc3e102075:http://doc.qt.io/qt-5/qabstractitemmodel.html#data]

The scene graph stores two different kinds of data: the name of the scene and its
nodes. Which of the two gets returned depends on the column. The first column,
column 0, returns the name, where as the second column, column 1, returns the
number of nodes the scene contains. It is not yet possible to implement the
second case, as scenes itself do not exist (as view models) and are not yet
provided as a reference within the scene graph view model.

For still being able to follow the current stream of thought, only a minimalist
realization of the scene view model class {{{verb(SceneViewModel)}}} is provided
by now, as can be seen in listing [[lst:guidomain-scene-sceneviewmodel]].

:GUIDOMAIN_SCENE_SCENEVIEWMODEL:
#+NAME:       guidomain-scene-sceneviewmodel
#+BEGIN_SRC python :exports none
class SceneViewModel(Qt.QObject):
    """View model representing a scene.

    The SceneViewModel corresponds to an SceneGraphViewModel entry within the
    scene graph.
    """

    <<guidomain-scene-sceneviewmodel-signals>>

    <<guidomain-scene-sceneviewmodel-constructor>>

    <<guidomain-scene-sceneviewmodel-methods>>

    <<guidomain-scene-sceneviewmodel-slots>>
#+END_SRC

#+NAME:       guidomain-scene-sceneviewmodel-01
#+BEGIN_SRC python :exports none
class SceneViewModel(Qt.QObject):
    """View model representing a scene.

    The SceneViewModel corresponds to an SceneGraphViewModel entry within the
    scene graph.
    """

    pass
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       guidomain-scene-body
#+BEGIN_SRC python :exports none
<<guidomain-scene-sceneviewmodel>>
#+END_SRC

#+NAME:       lst:guidomain-scene-sceneviewmodel
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Expansion of the =scene= module, which is within the =gui_domain= layer, by the =SceneViewModel= class. Note, that the implementation of the class provides no functionality at all at the moment.
#+BEGIN_SRC python :noweb yes

<guidomain-scene-body>+=
    <<guidomain-scene-sceneviewmodel-01>>
#+END_SRC
:END:

Having the scene view model class defined, it may now be used by the scene graph
view model. This reference will then be used by the scene graph controller for
getting the number of nodes a scene contains.

:GUIDOMAIN_SCENE_SCENEGRAPHVIEWMODEL_CONSTRUCTOR:
#+NAME:       guidomain-scene-scenegraphviewmodel-constructor-01
#+BEGIN_SRC   python :exports none
    self.scene_view_model = SceneViewModel()
#+END_SRC

#+NAME:       guidomain-scene-scenegraphviewmodel-constructor
#+BEGIN_SRC   python :exports none
<<guidomain-scene-scenegraphviewmodel-constructor-01>>
#+END_SRC

#+NAME:       lst:guidomain-scene-scenegraphviewmodel-constructor-01
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Expansion of the constructor of the =SceneGraphViewModel= class by a reference to a scene view model.
#+BEGIN_SRC python :noweb yes

<guidomain-scene-scenegraphviewmodel-constructor>+=
    <<guidomain-scene-scenegraphviewmodel-constructor-01>>
#+END_SRC
:END:

All prerequisites for implementing the {{{verb(data)}}} method of the scene
graph controller are now met and the method may therefore now be implemented.
The method has two parameters: the model index and the role. The model index
holds the position of the item within the data model. The role indicates what
type of data is provided. Currently the only role considered is the display of
models (further information may be found
at[fn:1b47276f9eb32ac2:http://doc.qt.io/qt-5/qt.html#ItemDataRole-enum]).
Depending on the column of the model index, either the name of the scene graph
node or the number of nodes its scene holds is returned.

:APP_SCENEGRAPH_CONTROLLER_METHODS_DATA:
#+NAME:       app-scenegraph-controller-methods-data
#+BEGIN_SRC python :exports none
def data(self, model_index, role=QtCore.Qt.DisplayRole):
    """Return the data stored unter the given role for the item referred by the
    index.

    :param model_index: The (data-) model index of the item.
    :type model_index: int
    :param role: The role which shall be used for representing the data. The
                 default (and currently only supported) is displaying the data.
    :type role:  QtCore.Qt.DisplayRole

    :return: the data stored under the given role for the item referred by the
             given index.
    :rtype:  str
    """

    if not model_index.isValid():
        return None

    # The internal pointer of the model index returns a scene graph view
    # model.
    node = model_index.internalPointer()

    if role == QtCore.Qt.DisplayRole:
        # Return either the name of the scene or its number of nodes.
        column = model_index.column()

        if column == 0:
            return node.name
        elif column == 1:
            return node.scene_view_model.graph_node_count
#+END_SRC

#+NAME:       app-scenegraph-controller-methods
#+BEGIN_SRC python :exports none

<<app-scenegraph-controller-methods-data>>
#+END_SRC

#+CAPTION: The code block =<<app-scenegraph-controller-methods>>= is expanded by the =data= method within the scene controller.
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       lst:app-scenegraph-controller-methods-04
#+BEGIN_SRC python :noweb yes
<app-scenegraph-controller-methods>+=
    <<app-scenegraph-controller-methods-data>>
#+END_SRC
:END:

The editor application would at this point still produce an error when being
run. The {{{verb(data)}}} method accesses a property of the scene view model
when getting the second column, the number of nodes a scene contains:
{{{verb(graph_node_count)}}}. As the scene view model is only a placeholder at the
moment, it is necessary to implement that property first. As the name says, the
property {{{verb(graph_node_count)}}} returns the number of graph nodes a scene view
model contains. Therefore the scene view model needs to hold graph nodes as a
list which leads to the definition of its constructor before implementing the
{{{verb(graph_node_count)}}} method.

:GUIDOMAIN_SCENE_SCENEVIEWMODEL_CONSTRUCTOR:
#+NAME:       guidomain-scene-sceneviewmodel-constructor
#+BEGIN_SRC   python :exports none
def __init__(self):
    """Constructor."""

    self.graph_nodes = []
#+END_SRC

#+NAME:       lst:guidomain-scene-scenegraphviewmodel-constructor
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition of the constructor of the =SceneViewModel= class.
#+BEGIN_SRC python :noweb yes

<guidomain-scene-sceneviewmodel-constructor>=
    <<guidomain-scene-sceneviewmodel-constructor>>
#+END_SRC
:END:

The method {{{verb(graph_node_count)}}} then simply returns the length of the
graph node list, as can be seen in listing
[[lst:guidomain-scene-sceneviewmodel-methods-graphnodecount]].

:GUIDOMAIN_SCENE_SCENEVIEWMODEL_METHODS_GRAPHNODECOUNT:
#+NAME:       guidomain-scene-sceneviewmodel-methods-graphnodecount
#+BEGIN_SRC python :exports none
@property
def graph_node_count(self):
    """Return the number of graph nodes, that this scene contains."""

    return len(self.graph_nodes)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       guidomain-scene-sceneviewmodel-methods
#+BEGIN_SRC python :exports none
<<guidomain-scene-sceneviewmodel-methods-graphnodecount>>
#+END_SRC

#+NAME:       lst:guidomain-scene-sceneviewmodel-methods-graphnodecount
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Expansion of the scene view model's methods by adding the =graph_node_count= property.
#+BEGIN_SRC python :noweb yes

<guidomain-scene-sceneviewmodel-methods>+=
    <<guidomain-scene-sceneviewmodel-methods-graphnodecount>>
#+END_SRC
:END:

When launching the editor application now, the scene graph is shown containing
the root node, as intended. One small detail is still left although. The header
data was defined in the scene graph controller, but it is not shown correctly.
Only the numbers 1 and 2 are shown as header. To get the header display the
column names correctly, the {{{verb(headerData)}}} method has to be implemented.

The Qt documentation states: ``Returns the data for the given role and section
in the header with the specified orientation.

For horizontal headers, the section number corresponds to the column number.
Similarly, for vertical headers, the section number corresponds to the row
number.''[fn:168b7c4ead833d4b:http://doc.qt.io/qt-5/qabstractitemmodel.html#headerData]

At the moment only the displaying-role and a horizontal orientation shall be
supported. The sections are given by the two columns 0 and 1, which correspond
to the header data. The implementation of the {{{verb(headerData)}}} is shown in
listing [[lst:app-scenegraph-controller-methods-header-data]].

:APP_SCENEGRAPH_CONTROLLER_METHODS_HEADERDATA:
#+NAME:      app-scenegraph-controller-methods-header-data
#+BEGIN_SRC python :exports none
def headerData(self, section, orientation=QtCore.Qt.Horizontal,
               role=QtCore.Qt.DisplayRole):
    """Return the data for the given role and section in the header with the
    specified orientation.

    Currently vertical is the only supported orientation. The only supported
    role is DisplayRole. As the sections correspond to the header, there are
    only two supported sections: 0 and 1. If one of those parameters is not
    within the described values, None is returned.

    :param section: the section in the header. Currently only 0 and 1 are
                    supported.
    :type  section: int
    :param orientation: the orientation of the display. Currently only
                        Horizontal is supported.
    :type orientation:  QtCore.Qt.Orientation
    :param role: The role which shall be used for representing the data. The
                 default (and currently only supported) is displaying the data.
    :type role:  QtCore.Qt.DisplayRole

    :return: the header data for the given section using the given role and orientation.
    :rtype:  str
    """

    if (
            orientation == QtCore.Qt.Horizontal  and
            role        == QtCore.Qt.DisplayRole and
            section     in [0, 1]
    ):
        return self.header_data[section]

#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-scenegraph-controller-methods
#+BEGIN_SRC python :exports none

<<app-scenegraph-controller-methods-header-data>>
#+END_SRC

#+NAME:       lst:app-scenegraph-controller-methods-header-data
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Expansion of the scene graph controller's methods by adding the =headerData= method which overwrites the method inherited by =QAbstractItemModel=.
#+BEGIN_SRC python :noweb yes

<app-scenegraph-controller-methods>+=
    <<app-scenegraph-controller-methods-header-data>>
#+END_SRC
:END:

#+NAME: fig:editor-alpha-03
#+ATTR_LATEX: :width 0.5\textwidth :placement [H]
#+ATTR_ORG: :width 50px
#+CAPTION: The QDE editor application showing the scene graph widget, containing the root node of the scene graph.
[[./images/qde_alpha_03.png]]

So far the application creates an instance of a scene model through the main
application, then managed by the scene graph controller. But for having only a
single (root-) scene, the whole scene graph architecture would be a massive
overkill. Instead it shall be possible to have multiple and nested scenes, what
allows the creation of diversified animations. Therefore the scene graph view
needs to provide at least the creation of new nodes, the deletion of existing
nodes and the selection of a existing nodes. First the selection of existing
nodes is implemented.

To detect if a node was selected within the scene tree of the scene graph view,
the selection model provides the {{{verb(selectionChanged)}}} signal. The
selection model is inherent in the data model of the {{{verb(QTreeView)}}}. For
being able to use the signal, the {{{verb(setModel)}}} method of the tree view
must be overridden. It is however very important to call the very same method on
the parent first. When setting the model, the root item of the model is set to be
selected.
For more flexibility, the slot {{{verb(on_tree_item_selected)}}} will be
triggered upon a selection of a tree item. The implementation of those aspects
can be seen in listings [[lst:gui-scene-system-imports-01]],
[[lst:gui-scene-project-imports-01]], [[lst:gui-scene-graph-signals-01]],
[[lst:gui-scene-graph-methods-set-model]] and [[lst:gui-scene-graph-slots-01]].

:GUI_SCENE_SYSTEM_IMPORTS_01:
#+NAME:      gui-scene-system-imports-01
#+BEGIN_SRC python :exports none
from PyQt5 import Qt
from PyQt5 import QtCore
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-system-imports
#+BEGIN_SRC python :exports none
<<gui-scene-system-imports-01>>
#+END_SRC

#+NAME:       lst:gui-scene-system-imports-01
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition of the necessary system imports for selecting tree items within the view's scene package.
#+BEGIN_SRC python :noweb yes
<gui-scene-system-imports>=
    <<gui-scene-system-imports-01>>
#+END_SRC
:END:

:GUI_SCENE_PROJECT_IMPORTS_01:
#+NAME:      gui-scene-project-imports-01
#+BEGIN_SRC python :exports none
from qde.editor.gui_domain import scene
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-project-imports
#+BEGIN_SRC python :exports none
<<gui-scene-project-imports-01>>
#+END_SRC

#+NAME:       lst:gui-scene-project-imports-01
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition of the necessary imports for selecting tree items within the view's scene package.
#+BEGIN_SRC python :noweb yes
<gui-scene-project-imports>=
    <<gui-scene-project-imports-01>>
#+END_SRC
:END:

:GUI_SCENE_GRAPH_SIGNALS_01:
#+NAME:      gui-scene-graph-signals-01
#+BEGIN_SRC python :exports none
tree_item_selected = QtCore.pyqtSignal(scene.SceneViewModel)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-graph-signals
#+BEGIN_SRC python :exports none
<<gui-scene-graph-signals-01>>
#+END_SRC

#+NAME:       lst:gui-scene-graph-signals-01
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition of the signal in case tree items are selected.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-signals>=
    <<gui-scene-graph-signals-01>>
#+END_SRC
:END:

:GUI_SCENE_GRAPH_SETMODEL:
#+NAME:      gui-scene-graph-methods-set-model
#+BEGIN_SRC python :exports none
def setModel(self, model):
    """Set the model for the view to present.

    This method is only used for being able to use the selection model's
    selectionChanged method and setting the current selection to the root node.

    :param model: The item model which the view shall present.
    :type  model: QtCore.QAbstractItemModel
    """

    super(SceneGraphView, self).setModel(model)

    selection_model = self.selectionModel()
    selection_model.selectionChanged.connect(
        self.on_tree_item_selected
    )

    self.setCurrentIndex(model.index(0, 0))
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-graph-methods
#+BEGIN_SRC python :exports none
<<gui-scene-graph-methods-set-model>>
#+END_SRC

#+NAME:       lst:gui-scene-graph-methods-set-model
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The overridden =setModel= method coming from =QTreeView= being added to the methods of the scene graph view class.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-methods>+=
    <<gui-scene-graph-methods-set-model>>
#+END_SRC
:END:

:GUI_SCENE_GRAPH_SLOTS_01:
#+NAME:      gui-scene-graph-slots-01
#+BEGIN_SRC python :exports none
@QtCore.pyqtSlot(QtCore.QItemSelection, QtCore.QItemSelection)
def on_tree_item_selected(self, selected, deselected):
    """Slot which is called when the selection within the scene graph view is
    changed.

    The previous selection (which may be empty) is specified by the deselected
    parameter, the new selection is specified by the selected paramater.

    This method emits the selected scene graph item as scene graph view model.

    :param selected: The new selection of scenes.
    :type  selected: QtCore.QModelIndex
    :param deselected: The previous selected scenes.
    :type  deselected: QtCore.QModelIndex
    """

    selected_item = selected.first()
    selected_index = selected_item.indexes()[0]
    selected_scene_graph_view_model = selected_index.internalPointer()
    self.tree_item_selected.emit(selected_scene_graph_view_model)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-graph-slots
#+BEGIN_SRC python :exports none

<<gui-scene-graph-slots-01>>
#+END_SRC

#+NAME:       lst:gui-scene-graph-slots-01
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Definition of the slot which gets called in case tree items are selected.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-slots>+=
    <<gui-scene-graph-slots-01>>
#+END_SRC
:END:

In the same manner the adding and removal of scenes is implemented. However, the
tree widgets does not provide direct signals for those cases as it is the case
when selecting a tree item, instead actions have to be used. Two actions are
implemented: one for adding a new item and one for removing an existing item.

An action gets triggered, typically by hovering over some item (in terms of a
context menu for example) or by pressing a defined shortcut. For the adding and
the removal the latter will be used. As the particular shortcut shall only be
valid for the widget, the {{{verb(WidgetShortcut)}}} shortcut context is used.
Adding of a scene item shall happen when pressing the =a= key on the keyboard,
removal of a selected node upon the press of the =delete= key on the keyboard.

The actions have to be added to the scene graph view and their
{{{verb(triggered)}}} signal is connected with the slot {{{verb(on_new_tree_item)}}}
and {{{verb(on_tree_item_removed)}}} respectively.

The implementation of the addition and removal of tree items within the scene
graph view is shown in listings [[lst:gui-scene-graph-slots-on-tree-item-added]] and
[[lst:gui-scene-graph-slots-on-tree-item-added]].

Taking a step back at this point, the (main-) functionality of the editor
application is as follows. When starting, an instance of the
{{{verb(Application)}}} class is spawned. As stated before, this class
is a central aspect of the application as it connects the various layers of the
architecture. The {{{verb(Application)}}} class spawns the main window, creates
the root scene of the application and spawns the scene graph controller by
providing it with the root scene.

:GUI_SCENE_GRAPH_SIGNALS_TREE_ITEM_ADDED:
#+NAME:      gui-scene-graph-signals-tree-item-added
#+BEGIN_SRC python :exports none
tree_item_added = QtCore.pyqtSignal(QtCore.QModelIndex)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-graph-signals
#+BEGIN_SRC python :exports none
<<gui-scene-graph-signals-tree-item-added>>
#+END_SRC

#+NAME:       lst:gui-scene-graph-signals-tree-item-removed
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The signal in case a tree item is added gets appended to the scene graph widget's signals.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-signals>+=
    <<gui-scene-graph-signals-tree-item-added>>
#+END_SRC
:END:
:GUI_SCENE_GRAPH_SIGNALS_TREE_ITEM_REMOVED:
#+NAME:      gui-scene-graph-signals-tree-item-removed
#+BEGIN_SRC python :exports none
tree_item_removed = QtCore.pyqtSignal(QtCore.QModelIndex)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-graph-signals
#+BEGIN_SRC python :exports none
<<gui-scene-graph-signals-tree-item-removed>>
#+END_SRC

#+NAME:       lst:gui-scene-graph-signals-tree-item-removed
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The signal in case a tree item is removed gets appended to the scene graph widget's signals.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-signals>+=
    <<gui-scene-graph-signals-tree-item-removed>>
#+END_SRC
:END:

:GUI_SCENE_GRAPH_CONSTRUCTOR_ADD_ACTIONS:
#+NAME:      gui-scene-graph-constructor-01
#+BEGIN_SRC python :exports none
new_action_label = QtCore.QCoreApplication.translate(
    __class__.__name__, 'New scene'
)
new_action = QtWidgets.QAction(new_action_label, self)
new_action.setShortcut(Qt.QKeySequence('a'))
new_action.setShortcutContext(QtCore.Qt.WidgetShortcut)
new_action.triggered.connect(self.on_new_tree_item)
self.addAction(new_action)

remove_action_label = QtCore.QCoreApplication.translate(
    __class__.__name__, 'Remove selected scene(s)'
)
remove_action = QtWidgets.QAction(remove_action_label, self)
remove_action.setShortcut(Qt.QKeySequence('Delete'))
remove_action.setShortcutContext(QtCore.Qt.WidgetShortcut)
remove_action.triggered.connect(self.on_tree_item_removed)
self.addAction(remove_action)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-graph-constructor
#+BEGIN_SRC python :exports none
<<gui-scene-graph-constructor-01>>
#+END_SRC

#+NAME:       lst:gui-scene-graph-constructor-01
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The actions to add a new scene and to remove existing scenes are added to the constructor of the scene graph view.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-constructor>+=
    <<gui-scene-graph-constructor-01>>
#+END_SRC
:END:

:GUI_SCENE_GRAPH_SLOTS_ON_TREE_ITEM_ADDED:
#+NAME:      gui-scene-graph-slots-on-tree-item-added
#+BEGIN_SRC python :exports none
@QtCore.pyqtSlot()
def on_new_tree_item(self):
    """Slot which is called when a new tree item was added by the scene graph
    view.

    This method emits the selected scene graph item as new tree item in form of
    a scene graph view model.
    """

    selected_indexes = self.selectedIndexes()

    # Sanity check: is actually an item selected?
    if len(selected_indexes) > 0:
        selected_item = selected_indexes[0]
        self.tree_item_added.emit(selected_item)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-graph-slots
#+BEGIN_SRC python :exports none

<<gui-scene-graph-slots-on-tree-item-added>>
#+END_SRC

#+NAME:       lst:gui-scene-graph-slots-on-tree-item-added
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The =on_new_tree_item= slot is added to the scene graph view's slots.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-slots>+=
    <<gui-scene-graph-slots-on-tree-item-added>>
#+END_SRC
:END:

:GUI_SCENE_GRAPH_SLOTS_ON_TREE_ITEM_REMOVED:
#+NAME:      gui-scene-graph-slots-on-tree-item-removed
#+BEGIN_SRC python :exports none
@QtCore.pyqtSlot()
def on_tree_item_removed(self):
    """Slot which is called when a one or multiple tree items were removed by
    the scene graph view.

    This method emits the removed scene graph item in form of scene graph view
    models.
    """

    selected_indexes = self.selectedIndexes()

    # Sanity check: is actually an item selected? And has that item a parent?
    # We only allow removal of items with a valid parent, as we do not want to
    # have the root item removed.
    if len(selected_indexes) > 0:
        selected_item = selected_indexes[0]
        if selected_item.parent().isValid():
            self.tree_item_removed.emit(selected_item)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       gui-scene-graph-slots
#+BEGIN_SRC python :exports none

<<gui-scene-graph-slots-on-tree-item-removed>>
#+END_SRC

#+NAME:       lst:gui-scene-graph-slots-on-tree-item-removed
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The =on_tree_item_removed= slot is added to the scene graph view's slots.
#+BEGIN_SRC python :noweb yes
<gui-scene-graph-slots>+=
    <<gui-scene-graph-slots-on-tree-item-removed>>
#+END_SRC
:END:

When launching the editor application now, the root scene is selected within the
scene graph. When pressing the =a= or the =delete= key on the keyboard nothing
happens. But why does nothing happen? Let us reconsider.

Both times, when one of the two keys is pressed, the corresponding slot is
hopefully called. When the scene graph has a selection, one of the two signals,
{{{verb(tree_item_added)}}} or {{{verb(tree_item_removed)}}}, is emitted.
The problem seems to be, that currently no other component is paying attention
to those signals. So let us connect the two signals with a corresponding slot.
As stated before, the {{{verb(Application)}}} class acts as a connection between
layers and therefore inter-layer connections have to happen there. The
implementation of the connections is shown in listing
[[lst:app-application-methods-setup-connections-02]].

:APP_APPLICATION_METHODS_SETUP_CONNECTIONS_02:
#+NAME:     app-application-methods-setup-connections-02
#+BEGIN_SRC python :exports none
self.main_window.scene_graph_widget.tree_item_added.connect(
    self.scene_graph_controller.on_tree_item_added
)
self.main_window.scene_graph_widget.tree_item_removed.connect(
    self.scene_graph_controller.on_tree_item_removed
)
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-application-methods-setup-connections
#+BEGIN_SRC python :exports none
<<app-application-methods-setup-connections-02>>
#+END_SRC

#+NAME:       lst:app-application-methods-setup-connections-02 
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    Connections between the scene graph view and the scene graph controller are added to the =setup_connections= method of the main application.
#+BEGIN_SRC python :noweb yes
<app-application-methods-setup-connections>+=
    <<app-application-methods-setup-connections-02>>
#+END_SRC
:END:

Setting up the connections as shown in listing
[[lst:app-application-methods-setup-connections-02]] connects the scene graph view
with the controller. But currently the controller does not know what to do in
the case an scene graph item is added or removed as the needed slots are
missing.

But what shall actually happen upon those events? In the case a scene graph item
is added, a new scene graph entry (a row) has to be added to the data model. In
the case an existing scene graph item is being removed, the item has to be
removed from the data model.

As the scene graph controller inherits from {{{verb(QAbstractItemModel)}}} the
corresponding methods, {{{verb(insertRows)}}} and {{{verb(removeRows)}}}, have
to be implemented. First, let us implement the slots as they are very easy to
implement. Implementing {{{verb(on_tree_item_added)}}} is straightforward: the
{{{verb(insertRows)}}} method is called by providing the row, the count and
the parent of the new item. Note, that the row is currently always zero. The
implementation can be seen in listing
[[lst:app-scenegraph-controller-slots-01]].

:APP_SCENEGRAPH_CONTROLLER_SLOTS_01:
#+NAME:     app-scenegraph-controller-slots-01
#+BEGIN_SRC python :exports none
@QtCore.pyqtSlot(QtCore.QModelIndex)
def on_tree_item_added(self, parent_index):
    """Add a new row under the given parent.

    :param parent_index: The index of the parent item.
    :type  parent_index: QtCore.QModelIndex
    """

    if parent_index.isValid():
        self.insertRows(0, 1, parent_index)
    else:
        # TODO: Log warning or error
        pass
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-scenegraph-controller-slots
#+BEGIN_SRC python :exports none
<<app-scenegraph-controller-slots-01>>
#+END_SRC

#+NAME:       lst:app-scenegraph-controller-slots-01
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The slot =on_tree_item_added= is being added to the scene graph controller's slots.
#+BEGIN_SRC python :noweb yes
<app-scenegraph-controller-slots>+=
    <<app-scenegraph-controller-slots-01>>
#+END_SRC
:END:

The implementation of {{{verb(on_tree_item_added)}}} is analogous: the
{{{verb(removeRows)}}} method is called by providing the row, the count and
the parent of the new item. The implementation can be seen in listing
[[lst:app-scenegraph-controller-slots-02]].
 
:APP_SCENEGRAPH_CONTROLLER_SLOTS_02:
#+NAME:     app-scenegraph-controller-slots-02
#+BEGIN_SRC python :exports none
@QtCore.pyqtSlot(QtCore.QModelIndex)
def on_tree_item_removed(self, selected_index):
    """Remove the currently selected item from the scene graph.

    :param selected_index: The index of the current selection.
    :type  selected_index: QtCore.QModelIndex
    """

    if selected_index.isValid():
        row    = selected_index.row()
        parent = selected_index.parent()
        self.removeRows(row, 1, parent)
    else:
        # TODO: Log warning or error
        pass
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-scenegraph-controller-slots
#+BEGIN_SRC python :exports none

<<app-scenegraph-controller-slots-02>>
#+END_SRC

#+NAME:       lst:app-scenegraph-controller-slots-02
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The slot =on_tree_item_removed= is being added to the scene graph controller's slots.
#+BEGIN_SRC python :noweb yes
<app-scenegraph-controller-slots>+=
    <<app-scenegraph-controller-slots-02>>
#+END_SRC
:END:

Having the slots for adding and removing scene graph items implemented, the
actual methods for these actions are still missing. So, let us implement these
now.

When inserting a row, the first thing to do is calling
{{{verb(beginInsertRows)}}} by providing the index of the parent item, the
current row and the last row of insertion (which is the current row plus the
count minus one). Then a scene model, representing the actual data structure of
a scene, as well as a scene graph view model is being created, representing the
very same scene model within the graphical user interface. The transaction is
then being ended by calling {{{verb(endInsertRows)}}}. Finally the view widget
is being told to redraw itself by emitting the {{{verb(layoutChanged)}}} signal
and the {{{verb(scene_added)}}} signal is emitting the newly created domain
model to inform other components (subscribers) about the creation. This can be
seen in listing [[lst:app-scenegraph-controller-methods-insert-rows]].

:APP_SCENEGRAPH_CONTROLLER_METHODS_INSERTROWS:
#+NAME:     app-scenegraph-controller-methods-insert-rows
#+BEGIN_SRC python :exports none
def insertRows(self, row, count, parent_index=QtCore.QModelIndex()):
    """ Insert the given number of rows into the scene graph below the given
    parent.

    :param row: The row after which the new rows shall be inserted.
    :type  row: int
    :param count: The number of rows to insert.
    :type  count: int
    :param parent_index: The index of the parent item, under which the rows will
                         be inserted.
    :type parent_index:  QtCore.QModelIndex

    :return: a boolean value. True when the insertion was successful, False otherwise.
    :rtype:  bool
    """

    if parent_index.isValid():
        self.beginInsertRows(parent_index, row, row + count - 1)

        # The internal pointer of the parent index returns a scene graph view
        # model.
        parent_node = parent_index.internalPointer()

        domain_scene_model = domain_scene.SceneModel()
        guidomain_scene.SceneGraphViewModel(
            row=row,
            domain_object=domain_scene_model,
            parent=parent_node
        )

        self.endInsertRows()

        self.layoutChanged.emit()
        self.scene_added.emit(domain_scene_model)
    else:
        return False
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-scenegraph-controller-methods
#+BEGIN_SRC python :exports none

<<app-scenegraph-controller-methods-insert-rows>>
#+END_SRC

#+NAME:       lst:app-scenegraph-controller-methods-insert-rows
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The method =insertRows= is being added to the scene graph controller's methods.
#+BEGIN_SRC python :noweb yes
<app-scenegraph-controller-methods>+=
    <<app-scenegraph-controller-methods-insert-rows>>
#+END_SRC
:END:

Removing a row is very similar. Analogous, the first thing to do is calling
{{{verb(beginRemoveRows)}}} by providing the index of the parent item, the
current row and the last row of insertion (which is the current row plus the
count minus one).
The actual removal of the node is then done by getting that node from its parent
by using the provided row and the parent's column. The node is then removed by
setting its parent to =None=. Qt's data model will therefore then remove the
node. The transaction is then being ended by calling {{{verb(endRemoveRows)}}}.
Finally, again the view widget is being told to redraw itself by emitting the
{{{verb(layoutChanged)}}} signal and the {{{verb(scene_removed)}}} signal is
emitting the linked domain model to inform other components (subscribers) about
the removal. This can be seen in listing
[[lst:app-scenegraph-controller-methods-remove-rows]].

:APP_SCENEGRAPH_CONTROLLER_METHODS_REMOVEROWS:
#+NAME:     app-scenegraph-controller-methods-remove-rows
#+BEGIN_SRC python :exports none
def removeRows(self, row, count, parent_index=QtCore.QModelIndex()):
    """Remove the given number of rows, lying below the given parent, from the
    scene graph.

    :param row: The row which marks the beginning of the removal.
    :type  row: int
    :param count: The number of rows to remove starting from the given row.
    :type  count: int
    :param parent_index: The index of the parent item, under which the rows will
                         be removed.
    :type parent_index:  QtCore.QModelIndex

    :return: a boolean value. True when the removal was successful, False otherwise.
    :rtype:  bool
    """

    if parent_index.isValid():
        self.beginRemoveRows(parent_index, row, row + count - 1)

        node_index = parent_index.child(row, parent_index.column())
        # The internal pointer of the node index returns a scene graph view
        # model.
        node = node_index.internalPointer()
        node.setParent(None)

        self.endRemoveRows()

        self.layoutChanged.emit()
        self.scene_removed.emit(node.domain_object)
    else:
        return False
#+END_SRC

#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+NAME:       app-scenegraph-controller-methods
#+BEGIN_SRC python :exports none

<<app-scenegraph-controller-methods-remove-rows>>
#+END_SRC

#+NAME:       lst:app-scenegraph-controller-methods-remove-rows
#+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
#+CAPTION:    The method =removeRows= is being added to the scene graph controller's methods.
#+BEGIN_SRC python :noweb yes
<app-scenegraph-controller-methods>+=
    <<app-scenegraph-controller-methods-remove-rows>>
#+END_SRC
:END:

The newly added functionality now allows the adding and removal of scenes within
the scene graph, which can be seen in figure [[fig:editor-alpha-04]]. The scenes are
added to (or removed from respectively) the graphical user interface as well as
the data structure.

#+NAME: fig:editor-alpha-04
#+ATTR_LATEX: :width 0.5\textwidth :placement [H]
#+ATTR_ORG: :width 50px
#+CAPTION: The QDE editor application showing the scene graph widget, containing multiple scenes.
[[./images/qde_alpha_05.png]]


So far the application (or rather the scene graph) seems to be working as
intended. But how do we ensure, that it really does? Without a doubt, unit and
integration tests are one of the best instruments to ensure functionality of
code. As stated before, in section [[Literate programming]], it was an intention of
this project to develop the application test driven. Due to required amount of
work for developing test driven, it was abstained from this intention and
regular unit tests are written instead, which can be found in appendix [[Test
cases]].

But nevertheless, it would be very handy to have at least some idea what the
code is doing at certain places and at certain times.
One of the simplest approaches to achieve this, is a verbose output at various
places of the application, which may be as simple as using Python's
{{{verb(print)}}} function. Using the {{{verb(print)}}} function may allow
printing something immediately, but it lacks of flexibility and demands each
time a bit of effort to format the output accordingly (e.g. adding the class and
the function name and so on). Python's logging facility provides much more
functionality while being able to keep things simple as well --- if needed.
The usage of the logging facility to log messages throughout the application may
later even be used to implement a widget which outputs those messages. So
logging using Python's logging facility will be implemented and applied for
being able to have feedback when needed.
