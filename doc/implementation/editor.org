** Editor

 Der Editor soll sich im Verzeichnis /editor/ unterhalb des /src\/qde/-Verzeichnisses
 befinden:

 #+ATTR_LaTeX: :options label={test},fontsize=\footnotesize,linenos,bgcolor=bashcodebg
 #+BEGIN_SRC bash :dir ../../.
 mkdir -p src/qde/editor
 #+END_SRC

 #+RESULTS:

 Um sicherzustellen, dass Module als solche verwendet werden können, muss pro
 Modul und Namepsace eine Initialisierungsdatei vorhanden sein. Es handelt sich
 dabei um Dateien namens /__init__.py/, welche im minimalen Fall leer sind. Diese
 können aber auch regulären Programmcode, wie zum Beispiel Klassen oder Methoden
 enthalten.

 #+ATTR_LaTeX: :options label={test},fontsize=\footnotesize,linenos,bgcolor=bashcodebg
 #+BEGIN_SRC bash :dir ../../.
 touch src/qde/__init__.py
 touch src/qde/editor/__init__.py
 #+END_SRC

 #+RESULTS:

 Im weiteren Dokument wird darauf verzichtet diese Dateien explizit zu erwähnen,
 sie werden direkt in den entsprechenden Codeblöcken erstellt und als gegeben
 angesehen.

 Nun kann mit der eigentlichen Erstellung des Editors begonnen werden. Wie unter
 <<Umsetzung>> beschrieben, werden für alle Funktionalitäten erst (Unit-) Tests
 verfasst und erst dann die eigentliche Funktionalität umgesetzt.

 Der Einstiegspunkt einer Qt-Applikation mit grafischer Oberfläche ist die Klasse
 /QtApplication/. Gemäss [fn:4] kann die Klasse direkt instanziert und benutzt
 werden, es ist unter Umständen jedoch sinnvoller die Klasse zu kapseln, was
 schlussendlich eine höhere Flexibilität bei der Umsetzung bietet. Es soll daher
 die Klasse /QDE/ erstellt werden, welche diese Abstraktion bietet.

 #+BEGIN_SRC bash :dir ../../.
 mkdir -p src/qde/editor/application
 touch src/qde/editor/application/__init__.py
 #+END_SRC

 #+RESULTS:

 Zunächst wird jedoch der entsprechende Unit-Test definiert. Dieser instanziert
 die Klasse und stellt sicher, dass sie ordnungsgemäss gestartet werden kann.
 Der Unit-Test besteht wiederum aus einer Kopfzeile, einem oder mehreren
 Importen sowie den eigentlichen Testfällen.

 #+BEGIN_SRC python :tangle ../../src/qde/editor/application/test_application.py :noweb tangle :comments link
   <<test-app-header>>

   <<test-app-imports>>


   <<test-app-test-cases>>
 #+END_SRC

 Als erster Schritt wird der Header des Test-Modules definiert.

 #+NAME: test-app-header
 #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
 #+CAPTION:    Header des Test-Modules, =<<test-app-header>>=.
 #+NAME:       fig:test-app-header
 #+BEGIN_SRC python
 # -*- coding: utf-8 -*-

 """Module for testing QDE class."""
 #+END_SRC

 #+RESULTS: fig:test-app-header
 : None

 Dann werden die benötigen Module importiert. Es sind dies das System-Modul
 /sys/ und das Modul /application/, bei welchem es sich um die Applikation
 handelt. Das System-Modul /sys/ wird benötigt um der Applikation ggf.
 Start-Argumente mitzugeben, also zum Beispiel:

 #+BEGIN_SRC bash
 python main.py argument1 argument2
 #+END_SRC

 #+RESULTS:

 #+NAME: test-app-imports
 #+BEGIN_SRC python
 <<test-app-system-imports>>

 <<test-app-project-imports>>
 #+END_SRC

 #+RESULTS: test-app-imports

 #+NAME: test-app-system-imports
 #+BEGIN_SRC python
 # System imports
 import sys
 #+END_SRC

 #+NAME: test-app-project-imports
 #+BEGIN_SRC python
 # Project imports
 from qde.editor.application import application
 #+END_SRC

 #+RESULTS: test-app-project-imports

 Somit kann schliesslich getestet werden, ob die Applikation startbar ist.

 #+NAME: test-app-test-constructor
 #+BEGIN_SRC python
 def test_constructor():
     """Test if the QDE application is starting up properly."""
     app = application.QDE(sys.argv)
     assert app.applicationName() == "QDE"
     assert app.applicationDisplayName() == "QDE"
 #+END_SRC

 #+RESULTS: test-app-test-constructor
 : None

 #+NAME: test-app-test-cases
 #+HEADER: :prologue <<test-app-test-cases>>
 #+BEGIN_SRC python
 <<test-app-test-constructor>>
 #+END_SRC

 #+RESULTS: test-app-test-cases

 Führt man die Testfälle nun aus, schlagen diese erwartungsgemäss fehl, da die
 Klasse, und somit die Applikation, als solche noch nicht existiert. Zum jetzigen
 Zeitpunkt kann noch nicht einmal das Modul importiert werden, da diese noch
 nicht existiert.

 #+BEGIN_SRC bash :dir ../../src
   python -m pytest qde/editor/application/test_application.py
 #+END_SRC

 #+RESULTS:

 An dieser Stelle macht es Sinn, sich zu überlegen, welche Funktionalität das
 Applikationsmodul haben soll. Es ist nicht nötig selbst einen Event-Loop zu
 implementieren, da ein solcher bereits durch Qt vorhanden ist.[fn:5]

 Das Applikationsmodul hat die Aufgabe die Kernelemente der Applikation zu
 initialisieren. So fungiert das Modul als Knotenpunkt zwischen den
 verschiedenen Ebenen der Architektur, indem es diese mittels Signalen
 verbindet.\cite[S. 37 bis 38]{osterwalder_qde_2016}

 Weiter soll es nützliche Schnittstellen, wie zum Beispiel das Protokollieren
 von Meldungen, bereitstellen. Und schliesslich soll das Modul eine Möglichkeit
 bieten beim Verlassen der Applikation zusätzliche Aufgaben, wie etwa das
 Entfernen von temporären Dateien, zu bieten.

 Da es sehr nützlich ist, den Zustand einer Applikation jederzeit nachvollziehen
 zu können, bietet es sich an als ersten Schritt ein Modul zur Protokollierung
 zu implementieren. Protokollierung ist ein sehr zentrales Element, daher wird
 das Modul im Namespace /common/ erstellt.

 Die (Datei-) Struktur zur Erstellung der Module erfolgt ab diesem Zeitpunkt
 nach dem Schichten-Modell gemäss \cite[S. 40]{osterwalder_qde_2016}.

 #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
 #+CAPTION:    Erstellung und Initialisierung des common-Namespaces.
 #+NAME:       fig:editor-common-namespace
 #+BEGIN_SRC bash :dir ../../.
 mkdir -p src/qde/editor/foundation
 touch src/qde/editor/foundation/__init__.py
 #+END_SRC

 #+RESULTS: fig:editor-common-namespace

 Grundsätzlich soll die Protokollierung auf Klassen-Basis stattfinden. Vorerst
 sollen Protokollierungen als Stream ausgegeben werden. Pro Klasse muss also
 eine /logging/-Instanz instanziert und mit dem entsprechenden Handler
 ausgestattet werden. Um den Programmcode nicht unnötig wiederholen zu müssen,
 bietet sich hierfür das Decorator-Pattern von Python an[fn:6].

 Die Klasse zur Protokollierung soll also grundsätzlich Folgendes tun:
 - Einen Logger-Namen auf Basis des aktuellen Moduls und der aktuellen Klasse setzten
   #+NAME: logger-name
   #+BEGIN_SRC python
    logger_name = "%s.%s" % (cls.__module__, cls.__name__)
   #+END_SRC

    #+RESULTS: logger-name

 - Einen Stream-Handler nutzen
   #+NAME: logger-stream-handler
   #+BEGIN_SRC python
     stream_handler = logging.StreamHandler()
   #+END_SRC

     #+RESULTS: logger-stream-handler

 - Die Stufe der Protokollierung abhängig von der aktuellen Konfiguration setzen
   #+NAME: logger-set-level
   #+BEGIN_SRC python
     # TODO: Do this according to config.
     stream_handler.setLevel(logging.DEBUG)
   #+END_SRC

     #+RESULTS: logger-set-level

 - Protokoll-Einträge ansprechend formatieren
   #+NAME: logger-set-formatter
   #+BEGIN_SRC python
     # TODO: Set up formatter in debug mode only
     formatter = logging.Formatter("%(asctime)s - %(levelname)-7s - %(name)s.%(funcName)s::%(lineno)s: %(message)s")
     stream_handler.setFormatter(formatter)
   #+END_SRC

     #+RESULTS: logger-set-formatter

 - Eine einfache Schnittstelle zur Protokollierung bieten
   #+NAME: logger-return-logger
   #+BEGIN_SRC python
     cls.logger = logging.getLogger(logger_name)
     cls.logger.propagate = False
     cls.logger.addHandler(stream_handler)

     return cls
   #+END_SRC

     #+RESULTS: logger-return-logger

 Auch hierfür werden wiederum zuerst die Testfälle verfasst.

 #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
 #+CAPTION:    Testfälle der Hilfsmethode zur Protokollierung
 #+NAME:       fig:editor-common-logging-test
 #+BEGIN_SRC python :tangle ../../src/qde/editor/foundation/test_common.py :noweb tangle :comments link
   # -*- coding: utf-8 -*-

   """Module for testing common methods class."""

   # System imports
   import logging

   # Project imports
   from qde.editor.foundation import common


   @common.with_logger
   class FooClass(object):
       """Dummy class for testing the logging decorator."""

       def __init__(self):
           """Constructor."""
           pass

   def test_with_logger():
       """Test if the @with_logger decorator works correctly."""

       foo_instance = FooClass()
       logger = foo_instance.logger
       name = "qde.editor.foundation.test_common.FooClass"
       assert logger is not None
       assert len(logger.handlers) == 1
       handler = logger.handlers[0]
       assert type(handler) == logging.StreamHandler
       assert logger.propagate == False
       assert logger.name == name
 #+END_SRC

 #+RESULTS: fig:editor-common-logging-test

 #+BEGIN_SRC bash :dir ../../src
   python -m pytest qde/editor/foundation/test_common.py
 #+END_SRC

 #+RESULTS:

 Nun kann die eigentliche Funktionalität implementiert werden.

 #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
 #+CAPTION:    Das /common/-Modul und eine Methode zur Protokollierung in Klassen.
 #+NAME:       fig:editor-common-logging
 #+BEGIN_SRC python :tangle ../../src/qde/editor/foundation/common.py :noweb tangle :comments link
   # -*- coding: utf-8 -*-

   """Module holding common helper methods."""

   # System imports
   import logging


   def with_logger(cls):
       """Add a logger instance (using a steam handler) to the given class
       instance.

       :param cls: the class which the logger shall be added to
       :type  cls: a class of type cls

       :return: the class type with the logger instance added
       :rtype:  a class of type cls
       """

       <<logger-name>>
       <<logger-stream-handler>>
       <<logger-set-level>>
       <<logger-set-formatter>>
       <<logger-return-logger>>
 #+END_SRC

 #+RESULTS: fig:editor-common-logging

 Führt man nun die Testfälle erneut aus, so schlagen diese nicht mehr fehl.

 #+BEGIN_SRC bash :dir ../../src
   python -m pytest qde/editor/foundation/test_common.py
 #+END_SRC

 #+RESULTS:

 Der Decorator kann nun direkt auf die Klasse der QDE-Applikation angewendet
 werden.

 #+NAME: app-class-definition
 #+BEGIN_SRC python
 @common.with_logger
 class QDE(QApplication):
   """Main application for QDE."""

   <<app-class-body>>
 #+END_SRC

 #+RESULTS: app-class-definition

 Damit die Protokollierung jedoch nicht nur via STDOUT in der Konsole statt
 findet, muss diese entsprechend konfiguriert werden. Das /logging/-Modul von
 Python bietet hierzu vielfältige Möglichkeiten.[fn:7] So kann die
 Protokollierung mittels der ``Configuration API'' konfiguriert werden. Hier
 bietet sich die Konfiguration via Dictionary an. Ein Dictionary kann zum
 Beispiel sehr einfach aus einer JSON-Datei generiert werden.

 Die Haupt-Applikation soll die Protokollierung folgendermassen vornehmen:
 - Die Konfiguration erfolgt entweder via externer JSON-Datei oder verwendet die
   Standardkonfiguration, welche von Python mittels /basicConfig/ vorgegeben
   wird.
 - Als Name für die JSON-Datei wird /logging.json/ angenommen.
 - Ist in den Umgebungsvariablen des Betriebssystems die Variable /LOG_CFG/
   gesetzt, wird diese als Pfad für die JSON-Datei angenommen. Ansonsten wird
   angenommen, dass sich die Datei /logging.json/ im Hauptverzeichnis befindet.
 - Existiert die JSON-Konfigurationsdatei nicht, wird auf die
   Standardkonfiguration zurückgegeriffen.
 - Die Protokollierung verwendet immer eine Protokollierungsstufe (Log-Level)
   zum Filtern der verschiedenen Protokollnachrichten.

 Die Haupt-Applikation nimmt also die Parameter /Pfad/, /Protokollierungsstufe/
 sowie /Umgebungsvariable/ entgegen.

 Um sicherzustellen, dass die Protokollierung wie gewünscht funktioniert, wird
 diese durch die entsprechenden Testfälle abgedeckt.

 Der einfachste Testfall ist die Standardkonfiguration, also ein Aufruf ohne
 Parameter.

 #+ATTR_LaTeX: :options fontsize=\footnotesize,linenos,bgcolor=bashcodebg
 #+CAPTION:    Testfall 1 der Protkollierung der Hauptapplikation: Aufruf ohne Argumente.
 #+NAME:       test-app-test-logging-default
 #+BEGIN_SRC   python
 def test_setup_logging_without_arguments():
     """Test logging of QDE application without arguments."""
     app = application.QDE(sys.argv)
     root_logger = logging.root
     handlers = root_logger.handlers
     assert len(handlers) == 1
     handler = handlers[0]
 #+END_SRC

 #+RESULTS: test-app-test-logging-default

 Da obige Testfälle das /logging/-Module benötigen, muss das Importieren der Module
 entsprechend erweitert werden.

 #+NAME: test-app-system-imports
 #+HEADER: :prologue <<test-app-system-imports>>
 #+BEGIN_SRC python
 import logging
 #+END_SRC

 Und der Testfall muss den Testfällen hinzugefügt werden.

 #+NAME: test-app-test-cases
 #+HEADER: :prologue <<test-app-test-cases>>
 #+BEGIN_SRC python

 <<test-app-test-logging-default>>
 #+END_SRC

 Nun kann die eigentliche Umsetzung zur Konfiguration der Protokollierung
 umgesetzt und der Klasse hinzugefügt werden.

 #+NAME: app-setup-logging
 #+BEGIN_SRC python
 def setup_logging(self,
     default_path='logging.json',
     default_level=logging.INFO,
     env_key='LOG_CFG'
 ):
     """Setup logging configuration"""

     path = default_path
     value = os.getenv(env_key, None)

     if value:
         path = value

     if os.path.exists(path):
         with open(path, 'rt') as f:

             config = json.load(f)
             logging.config.dictConfig(config)
     else:
         logging.basicConfig(level=default_level)
 #+END_SRC


 #+BEGIN_SRC python :tangle ../../src/qde/editor/application/application.py :noweb tangle :comments link
   # -*- coding: utf-8 -*-

   """Main application module for QDE."""

   <<app-imports>>

   <<app-class-definition>>
 #+END_SRC

 #+RESULTS:

 #+NAME: app-imports
 #+BEGIN_SRC python
 <<app-system-imports>>

 <<app-project-imports>>
 #+END_SRC

 #+NAME: app-system-imports
 #+BEGIN_SRC python
 # System imports
 from   PyQt5.Qt import QApplication
 from   PyQt5.Qt import QIcon
 import logging
 import os
 #+END_SRC

 #+NAME: app-project-imports
 #+BEGIN_SRC python
 # Project imports
 from qde.editor.foundation import common
 #+END_SRC

 #+NAME: app-constructor
 #+BEGIN_SRC python
 def __init__(self, arguments):
     """Constructor.

     :param arguments: a (variable) list of arguments, that are
                       passed when calling this class.
     :type  argv:      list
     """

     super(QDE, self).__init__(arguments)
     self.setWindowIcon(QIcon("assets/icons/im.png"))
     self.setApplicationName("QDE")
     self.setApplicationDisplayName("QDE")

     self.setup_logging()
 #+END_SRC

 Der Konstruktor wird schliesslich der Klasse hinzugefügt.

 #+NAME: app-class-body
 #+HEADER: :prologue <<app-class-body>>
 #+BEGIN_SRC python
 <<app-constructor>>

 <<app-setup-logging>>
 #+END_SRC

 Somit ist es nun möglich die Testfälle der Applikation auszuführen.

 #+BEGIN_SRC bash :dir ../../src :results output silent
   python -m pytest qde/editor/application/test_application.py
 #+END_SRC

* Footnotes

[fn:7] https://docs.python.org/3/library/logging.html

[fn:6] https://www.python.org/dev/peps/pep-0318/

[fn:5] http://doc.qt.io/Qt-5/qapplication.html#exec

[fn:4] http://doc.qt.io/Qt-5/qapplication.html
