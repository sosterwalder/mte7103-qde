** Organization of work
*** Meetings

Various meetings with the supervising professor, Mr. Claude Fuhrer, helped
reaching the defined goals and preventing erroneous directions of the thesis.
The supervisor supported the author of this thesis by providing suggestions
throughout the held meetings. The minutes of the meetings may be found under
<<Meeting minutes>>.

*** Phases of the project and milestones


| Phase                                    | Description | Week / 2017 |
|------------------------------------------+-------------+-------------|
| Start of the project                     |             |           8 |
| Definition of objectives and limitations |             |         8-9 |
| Documentation and development            |             |        8-30 |
| Corrections                              |             |       30-31 |
| Preparation of the thesis' defense       |             |       31-32 |

| Milestone                           | Description | End of week / 2017 |
|-------------------------------------+-------------+--------------------|
| Project structure is set up         |             |                  8 |
| Mandatory project goals are reached |             |                 30 |
| Hand-in of the thesis               |             |                 31 |
| Defense of the thesis               |             |                 32 |

#+NAME: fig:schedule
#+ATTR_LATEX: :placement [H]
#+ATTR_ORG: :width 50px
#+CAPTION: The project's schedule.
[[./images/project_schedule.png]]

Figure [[fig:schedule]] shows the project's schedule.

*** Literate programming

This thesis' implementation is done by a procedure named ``literate
programming'', invented by Donald Knuth. What this means, is that the
documentation as well as the code for the resulting program reside in the same
file. The documentation is then /weaved/ into a separate document, which may be
any by the editor support format. The code of the program is /tangled/ into a
run-able computer program.

*************** TODO Provide more information about literate programming.
                    Citations, explain fragments, explain referencing
                    fragments, code structure does not have to be ``normal''
*************** END

  Originally it was planned to develop this thesis' application test driven,
  providing (unit-) test-cases first and implementing the functionality
  afterwards. Initial trails showed quickly that this method, in company with
  literate programming, would exaggerate the effort needed. Therefore conventional
  testing is used. Test are developed after implementing functionality and run
  separately. A coverage as high as possible is intended. Test cases are /tangled/
  too, and may be found in the appendix.
*************** TODO Insert reference/link to test cases here.
*************** END

** Standards and principles
*** Code

**** TODO Principles

- Classes use camel case.
- Folders / name-spaces use only small letters.
- Methods are all small caps and use underscores as spaces.
- Signals: do_something
- Slots: on_something
- Importing: {{{verb(from Foo import Bar)}}}\\
  As the naming of the PyQt5 modules prefixes them by /Qt/, it is very unlikely
  to have naming conflicts with other modules. Therefore the import format
  {{{verb(from PyQt5 import [QtModuleName])}}} is used. This still provides a
  (relatively) unique naming most probably without any conflicts but reduces the
  effort when writing a bit. The import of system modules is therefore as
  follows.

**** Layering
     :PROPERTIES:
     :CUSTOM_ID: sec:layering
     :END:

Concerning the architecture, a layered architecture is foreseen, as stated in
\cite[p. 38 ff.]{osterwalder_qde_2016}. A relaxed layered architecture leads to
low coupling, reduces dependencies and enhances cohesion as well as clarity.

As the architecture's core [[Components][components]] are all graphical, a graphical user
interface for those components is developed. As the their data shall be
exportable, it would be relatively tedious if the graphical user interface would
hold and control that data. Instead models and model-view separation are used.
Additionally controllers are introduced which act as workflow objects of the
{{{verb(application)}}} layer and interfere between the model and its view.

***** Model-View-Controller

While models may be instantiated anywhere directly, this would although not
contribute to having clean code and sane data structures. Instead controllers,
lying within the {{{verb(application)}}} layer, will manage instances of models.
The instantiating may either be induced by the graphical user interface
or by the player when loading and playing exported animations.

A view may never contain model-data (coming from the {{{verb(domain)}}} layer)
directly, instead view models are used \cite{martin_fowler_presentation_2004}.

The behavior described above corresponds to the well-known model-view-controller
pattern expanded by view models.

As Qt is used as the core for the editor, it may be quite obvious to use Qt's
model/view programming practices, as described by
[fn:20:http://doc.qt.io/qt-5/model-view-programming.html]. However, Qt combines
the controller and the view, meaning the view acts also as a controller while
still separating the storage of data. The editor application does not actually
store data (in a conventional way, e.g. using a database) but solely exports it.
Due to this circumstance the model-view-controller pattern is explicitly used,
as also stated in \cite[p. 38]{osterwalder_qde_2016}.

*************** TODO Describe the exact process of communication between
*************** ViewModel, Controller and Model.
*************** END

To avoid coupling and therefore dependencies, signals and
slots[fn:16:http://doc.qt.io/qt-5/signalsandslots.html] are used in terms of the
observer pattern to allow inter-object and inter-layer communication.

**** Framework for implementation
     :PROPERTIES:
     :CUSTOM_ID: sec:framework-for-implementation
     :END:

To stay consistent when implementing classes, it make sense to define a rough
framework for implementation, which is as follows:

1. Define necessary signals.
2. Within the constructor,
   + Set up the user interface when it is a class concerning the graphical user
     interface.
   + Set up class-specific aspects, such as the name, the tile or an icon.
   + Set up other components, used by that class.
   + Initialize the connections, meaning hooking up the defined signals with
     corresponding methods.
3. Implement the remaining functionality in terms of methods and slots.

*** Diagrams

 [Diagrams.]

*** Project structure

 [Project structure.]
